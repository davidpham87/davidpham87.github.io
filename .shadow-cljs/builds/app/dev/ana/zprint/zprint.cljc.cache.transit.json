["^ ","~:output",["^ ","~:js","goog.provide('zprint.zprint');\ngoog.require('cljs.core');\ngoog.require('clojure.string');\ngoog.require('zprint.zfns');\ngoog.require('zprint.ansi');\ngoog.require('zprint.config');\ngoog.require('zprint.zutil');\ngoog.require('rewrite_clj.parser');\ngoog.require('rewrite_clj.zip');\n/**\n * Produce a blank string of desired size.\n */\nzprint.zprint.blanks = (function zprint$zprint$blanks(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\" \"));\n});\n/**\n * Produce a dot string of desired size.\n */\nzprint.zprint.dots = (function zprint$zprint$dots(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\".\"));\n});\n/**\n * error\n */\nzprint.zprint.indent = (function zprint$zprint$indent(){\nreturn null;\n});\n/**\n * Make a version of conj! that take multiple arguments.\n */\nzprint.zprint.conj_it_BANG_ = (function zprint$zprint$conj_it_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___37666 = arguments.length;\nvar i__4731__auto___37667 = (0);\nwhile(true){\nif((i__4731__auto___37667 < len__4730__auto___37666)){\nargs__4736__auto__.push((arguments[i__4731__auto___37667]));\n\nvar G__37668 = (i__4731__auto___37667 + (1));\ni__4731__auto___37667 = G__37668;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\nzprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar out = cljs.core.first(rest);\nvar more = cljs.core.next(rest);\nwhile(true){\nif(more){\nvar G__37669 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(more));\nvar G__37670 = cljs.core.next(more);\nout = G__37669;\nmore = G__37670;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\nzprint.zprint.conj_it_BANG_.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\nzprint.zprint.conj_it_BANG_.cljs$lang$applyTo = (function (seq37055){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq37055));\n});\n\n/**\n * Do split for newlines, instead of using regular expressions.\n */\nzprint.zprint.split_lf = (function zprint$zprint$split_lf(s){\nvar input = s;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(input)){\nreturn out;\n} else {\nvar next_lf = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(input,\"\\n\");\nvar chunk = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$3(input,(0),next_lf):input);\nvar G__37671 = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$2(input,(next_lf + (1))):null);\nvar G__37672 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,chunk);\ninput = G__37671;\nout = G__37672;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Do split for newlines, instead of using regular expressions.\n *   Maximum split is 2.\n */\nzprint.zprint.split_lf_2 = (function zprint$zprint$split_lf_2(s){\nvar temp__5718__auto__ = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(s,\"\\n\");\nif(cljs.core.truth_(temp__5718__auto__)){\nvar next_lf = temp__5718__auto__;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),next_lf),cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,(next_lf + (1)))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [s], null);\n}\n});\nzprint.zprint.zpmap = (function zprint$zprint$zpmap(var_args){\nvar G__37057 = arguments.length;\nswitch (G__37057) {\ncase 3:\nreturn zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3 = (function (options,f,coll){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,coll);\n});\n\nzprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4 = (function (options,f,coll1,coll2){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,coll1,coll2);\n});\n\nzprint.zprint.zpmap.cljs$lang$maxFixedArity = 4;\n\n/**\n * Takes an option map and the return from zfuture.  If the\n *   options map has (:parallel? options) as true, then deref\n *   the value, otherwise just pass it through.\n */\nzprint.zprint.zat = (function zprint$zprint$zat(options,value){\nreturn value;\n});\nzprint.zprint.fzprint_dbg = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\n/**\n * Accept a style-vec that we are about to hand to style-lines, and\n *   output it if called for, to aid in debugging.\n */\nzprint.zprint.log_lines = (function zprint$zprint$log_lines(p__37058,dbg_output,ind,style_vec){\nvar map__37059 = p__37058;\nvar map__37059__$1 = (((((!((map__37059 == null))))?(((((map__37059.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37059.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37059):map__37059);\nvar options = map__37059__$1;\nvar dbg_print_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37059__$1,new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872));\nvar dbg_indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37059__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37059__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nif(cljs.core.truth_(dbg_print_QMARK_)){\nif(cljs.core.truth_(style_vec)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([dbg_indent,dbg_output,\"--------------\",\"in-hang?\",in_hang_QMARK_], 0));\n\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.str,zprint.zprint.blanks(ind),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,style_vec))], 0));\n} else {\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([dbg_indent,dbg_output,\"--------------- no style-vec\"], 0));\n}\n} else {\nreturn null;\n}\n});\n/**\n * Show this thing as a function?\n */\nzprint.zprint.showfn_QMARK_ = (function zprint$zprint$showfn_QMARK_(fn_map,f){\nif((!(typeof f === 'string'))){\nvar f_str = cljs.core.str.cljs$core$IFn$_invoke$arity$1(f);\nvar or__4131__auto__ = (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(f_str) : fn_map.call(null,f_str));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = cljs.core.re_find(/clojure/,f_str);\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nif((f instanceof cljs.core.Symbol)){\ntry{var or__4131__auto____$2 = cljs.core.re_find(/clojure/,cljs.core.str.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(f))));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar G__37062 = cljs.core.name(f);\nreturn (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(G__37062) : fn_map.call(null,G__37062));\n}\n}catch (e37061){var e = e37061;\nreturn null;\n}} else {\nreturn null;\n}\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Show this thing as a user defined function?  Assumes that we\n *   have already handled any clojure defined functions!\n */\nzprint.zprint.show_user_fn_QMARK_ = (function zprint$zprint$show_user_fn_QMARK_(options,f){\nif((!(typeof f === 'string'))){\nvar f_str = cljs.core.str.cljs$core$IFn$_invoke$arity$1(f);\nvar user_fn_map = new cljs.core.Keyword(null,\"user-fn-map\",\"user-fn-map\",-908243227).cljs$core$IFn$_invoke$arity$1(options);\nvar or__4131__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(user_fn_map,f_str);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nif((f instanceof cljs.core.Symbol)){\ntry{var or__4131__auto____$1 = (!(cljs.core.empty_QMARK_(cljs.core.str.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(f))))));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(user_fn_map,cljs.core.name(f));\n}\n}catch (e37063){var e = e37063;\nreturn null;\n}} else {\nreturn null;\n}\n}\n} else {\nreturn null;\n}\n});\nzprint.zprint.right_separator_map = new cljs.core.PersistentArrayMap(null, 3, [\")\",(1),\"]\",(1),\"}\",(1)], null);\n/**\n * Given the fn-style, is the first output good enough to be worth\n *   doing. p is pretty, which is typically hanging, and b is basic, which\n *   is typically flow. p-count is the number of elements in the hang.\n */\nzprint.zprint.good_enough_QMARK_ = (function zprint$zprint$good_enough_QMARK_(caller,p__37064,fn_style,p_count,indent_diff,p__37065,p__37066){\nvar map__37067 = p__37064;\nvar map__37067__$1 = (((((!((map__37067 == null))))?(((((map__37067.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37067.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37067):map__37067);\nvar options = map__37067__$1;\nvar map__37068 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37067__$1,new cljs.core.Keyword(null,\"tuning\",\"tuning\",-48660925));\nvar map__37068__$1 = (((((!((map__37068 == null))))?(((((map__37068.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37068.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37068):map__37068);\nvar hang_flow = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37068__$1,new cljs.core.Keyword(null,\"hang-flow\",\"hang-flow\",428126548));\nvar hang_type_flow = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37068__$1,new cljs.core.Keyword(null,\"hang-type-flow\",\"hang-type-flow\",-1585576590));\nvar hang_flow_limit = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37068__$1,new cljs.core.Keyword(null,\"hang-flow-limit\",\"hang-flow-limit\",389146586));\nvar general_hang_adjust = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37068__$1,new cljs.core.Keyword(null,\"general-hang-adjust\",\"general-hang-adjust\",-1631406987));\nvar hang_if_equal_flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37068__$1,new cljs.core.Keyword(null,\"hang-if-equal-flow?\",\"hang-if-equal-flow?\",-1113113992));\nvar map__37069 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37067__$1,caller);\nvar map__37069__$1 = (((((!((map__37069 == null))))?(((((map__37069.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37069.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37069):map__37069);\nvar hang_expand = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37069__$1,new cljs.core.Keyword(null,\"hang-expand\",\"hang-expand\",1086807559));\nvar hang_diff = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37069__$1,new cljs.core.Keyword(null,\"hang-diff\",\"hang-diff\",-1575205424));\nvar hang_size = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37069__$1,new cljs.core.Keyword(null,\"hang-size\",\"hang-size\",-347944063));\nvar hang_adjust = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37069__$1,new cljs.core.Keyword(null,\"hang-adjust\",\"hang-adjust\",-613514382));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37067__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37067__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37067__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar vec__37070 = p__37065;\nvar p_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37070,(0),null);\nvar p_maxwidth = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37070,(1),null);\nvar p_length_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37070,(2),null);\nvar p_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37070,(3),null);\nvar vec__37073 = p__37066;\nvar b_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37073,(0),null);\nvar b_maxwidth = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37073,(1),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37073,(2),null);\nvar b_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37073,(3),null);\nvar p_last_maxwidth = cljs.core.last(p_length_seq);\nvar hang_diff__$1 = (function (){var or__4131__auto__ = hang_diff;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})();\nvar hang_expand__$1 = (function (){var or__4131__auto__ = hang_expand;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn 1000.0;\n}\n})();\nvar hang_adjust__$1 = (function (){var or__4131__auto__ = hang_adjust;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn general_hang_adjust;\n}\n})();\nvar options__$1 = (cljs.core.truth_((function (){var or__4131__auto__ = p_what;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn b_what;\n}\n})())?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771),true):options);\nvar result = ((cljs.core.not(b_lines))?true:(function (){var and__4120__auto__ = p_lines;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p_last_maxwidth <= (width - (zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt))));\nif(and__4120__auto____$1){\nvar and__4120__auto____$2 = (p_maxwidth <= width);\nif(and__4120__auto____$2){\nvar or__4131__auto__ = (p_lines === (0));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar and__4120__auto____$3 = (b_lines > (0));\nif(and__4120__auto____$3){\nvar and__4120__auto____$4 = (p_count > (0));\nif(and__4120__auto____$4){\nif(cljs.core.truth_((function (){var and__4120__auto____$5 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p_lines,b_lines);\nif(and__4120__auto____$5){\nreturn hang_if_equal_flow_QMARK_;\n} else {\nreturn and__4120__auto____$5;\n}\n})())){\nreturn true;\n} else {\nvar and__4120__auto____$5 = (((indent_diff <= hang_diff__$1))?true:(((p_lines - (1)) / p_count) <= hang_expand__$1));\nif(and__4120__auto____$5){\nvar and__4120__auto____$6 = (cljs.core.truth_(hang_size)?(p_lines < hang_size):true);\nif(and__4120__auto____$6){\nvar factor = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?hang_type_flow:hang_flow);\nif((p_lines > hang_flow_limit)){\nreturn ((p_lines - (1)) <= b_lines);\n} else {\nreturn (((p_lines + hang_adjust__$1) / b_lines) < factor);\n}\n} else {\nreturn and__4120__auto____$6;\n}\n} else {\nreturn and__4120__auto____$5;\n}\n}\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),(cljs.core.truth_(result)?\"++++++\":\"XXXXXX\"),\"p-what\",p_what,\"good-enough? caller:\",caller,\"fn-style:\",fn_style,\"width:\",width,\"rightcnt:\",rightcnt,\"hang-expand:\",hang_expand__$1,\"p-count:\",p_count,\"p-lines:\",p_lines,\"p-maxwidth:\",p_maxwidth,\"indent-diff:\",indent_diff,\"hang-diff:\",hang_diff__$1,\"p-last-maxwidth:\",p_last_maxwidth,\"b-lines:\",b_lines,\"b-maxwidth:\",b_maxwidth], 0));\n} else {\n}\n\nreturn result;\n});\n/**\n * Add :in-hang? true to the options map.\n */\nzprint.zprint.in_hang = (function zprint$zprint$in_hang(options){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639).cljs$core$IFn$_invoke$arity$1(options))){\nreturn options;\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"do-in-hang?\",\"do-in-hang?\",-1235364947).cljs$core$IFn$_invoke$arity$1(options))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639),(function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn true;\n}\n})());\n} else {\nreturn options;\n}\n}\n});\n/**\n * Scan a collection, and return the number of nils or empty collections\n *   present (if any), and nil otherwise.\n */\nzprint.zprint.contains_nil_QMARK_ = (function zprint$zprint$contains_nil_QMARK_(coll){\nvar n = cljs.core.count(cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__37104_SHARP_){\nif(cljs.core.coll_QMARK_(p1__37104_SHARP_)){\nreturn cljs.core.empty_QMARK_(p1__37104_SHARP_);\n} else {\nreturn (p1__37104_SHARP_ == null);\n}\n}),coll));\nif((!((n === (0))))){\nreturn n;\n} else {\nreturn null;\n}\n});\n/**\n * Concatentate multiple sequences, but if any of them are nil, return nil.\n *   This version is 15-20% slower than the version below. Keeping it around\n *   just for illustrative purposes.\n */\nzprint.zprint.concat_no_nil_alt = (function zprint$zprint$concat_no_nil_alt(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___37682 = arguments.length;\nvar i__4731__auto___37683 = (0);\nwhile(true){\nif((i__4731__auto___37683 < len__4730__auto___37682)){\nargs__4736__auto__.push((arguments[i__4731__auto___37683]));\n\nvar G__37684 = (i__4731__auto___37683 + (1));\ni__4731__auto___37683 = G__37684;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil_alt.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\nzprint.zprint.concat_no_nil_alt.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar coll = rest;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nvar c = cljs.core.first(coll);\nif(cljs.core.not(c)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nif(((((cljs.core.coll_QMARK_(c)) && ((!(cljs.core.empty_QMARK_(c)))))) || ((!((c == null)))))){\nvar G__37685 = cljs.core.next(coll);\nvar G__37686 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,c);\ncoll = G__37685;\nout = G__37686;\ncontinue;\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\nzprint.zprint.concat_no_nil_alt.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\nzprint.zprint.concat_no_nil_alt.cljs$lang$applyTo = (function (seq37105){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq37105));\n});\n\n/**\n * Concatentate multiple sequences, but if any of them are nil or empty\n *   collections, return nil.\n */\nzprint.zprint.concat_no_nil = (function zprint$zprint$concat_no_nil(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___37687 = arguments.length;\nvar i__4731__auto___37688 = (0);\nwhile(true){\nif((i__4731__auto___37688 < len__4730__auto___37687)){\nargs__4736__auto__.push((arguments[i__4731__auto___37688]));\n\nvar G__37689 = (i__4731__auto___37688 + (1));\ni__4731__auto___37688 = G__37689;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\nzprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar result = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.coll_QMARK_(o)){\nif(cljs.core.empty_QMARK_(o)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj_BANG_,v,o);\n}\n} else {\nif((o == null)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n}\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),rest);\nif(cljs.core.truth_(result)){\nreturn cljs.core.persistent_BANG_(result);\n} else {\nreturn null;\n}\n});\n\nzprint.zprint.concat_no_nil.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\nzprint.zprint.concat_no_nil.cljs$lang$applyTo = (function (seq37106){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq37106));\n});\n\n/**\n * Ensure that whatever we have is a vector.\n */\nzprint.zprint.force_vector = (function zprint$zprint$force_vector(coll){\nif(cljs.core.vector_QMARK_(coll)){\nreturn coll;\n} else {\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,coll);\n}\n});\n/**\n * Takes a string, and returns the fn-style if it is a keyword and\n *   without the : it can be found in the fn-map.\n */\nzprint.zprint.keyword_fn_QMARK_ = (function zprint$zprint$keyword_fn_QMARK_(options,s){\nvar vec__37109 = clojure.string.split.cljs$core$IFn$_invoke$arity$2(s,/^:/);\nvar left = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37109,(0),null);\nvar right = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37109,(1),null);\nif(cljs.core.truth_(right)){\nvar fexpr__37112 = new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146).cljs$core$IFn$_invoke$arity$1(options);\nreturn (fexpr__37112.cljs$core$IFn$_invoke$arity$1 ? fexpr__37112.cljs$core$IFn$_invoke$arity$1(right) : fexpr__37112.call(null,right));\n} else {\nreturn null;\n}\n});\n/**\n * Take the vector carrying the intermediate results, and\n *   do the right thing with a new string. Vector is\n *   [ 0 out - vector accumulating line lengths \n *  1 cur-len - length of current line\n *  just-eol? - did we just do an eol?\n *  ]\n *   s - string to add to current line\n *   tag - element type of string (comment's don't count in length)\n *   eol? - should we terminate line after adding count of s\n */\nzprint.zprint.accumulate_ll = (function zprint$zprint$accumulate_ll(count_comment_QMARK_,p__37113,s,tag,eol_QMARK_){\nvar vec__37114 = p__37113;\nvar out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37114,(0),null);\nvar cur_len = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37114,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37114,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37114,(3),null);\nvar in$ = vec__37114;\nvar comment_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\nvar count_s = ((((comment_QMARK_) && (cljs.core.not(count_comment_QMARK_))))?(0):cljs.core.count(s));\nif(cljs.core.truth_((function (){var or__4131__auto__ = (function (){var and__4120__auto__ = eol_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not((function (){var and__4120__auto____$1 = just_eol_QMARK_;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (count_s === (0));\n} else {\nreturn and__4120__auto____$1;\n}\n})());\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn comment_QMARK_;\n}\n})())){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,(cur_len + count_s)),(0),true,comment_QMARK_], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [out,(cur_len + count_s),null,comment_QMARK_], null);\n\n}\n});\nzprint.zprint.generate_ll = (function zprint$zprint$generate_ll(count_comment_QMARK_,p__37120,p__37121){\nvar vec__37122 = p__37120;\nvar out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37122,(0),null);\nvar cur_len = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37122,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37122,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37122,(3),null);\nvar in$ = vec__37122;\nvar vec__37125 = p__37121;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37125,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37125,(1),null);\nvar tag = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37125,(2),null);\nvar element = vec__37125;\nvar vec__37129 = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323)))))?zprint.zprint.split_lf_2(s):(new cljs.core.List(null,s,null,(1),null)));\nvar l = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37129,(0),null);\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37129,(1),null);\nvar in$__$1 = zprint.zprint.accumulate_ll(count_comment_QMARK_,in$,l,tag,(!((r == null))));\nvar in$__$2 = ((cljs.core.empty_QMARK_(r))?in$__$1:zprint.zprint.accumulate_ll(count_comment_QMARK_,in$__$1,r,tag,null));\nreturn in$__$2;\n});\n/**\n * Take a style-vec, and output a sequence of numbers, one for each\n *   line, which contains the actual length. Must take the current\n *   indent to have a prayer of getting this right, but it is used\n *   only for the first line.  The ind can be an integer or a seq of\n *   integers, in which case only the first integer is used. Newlines\n *   can come anywhere in an element in a style-vec, it will account\n *   for both sides.  Will break lines on comments even if no newlines\n *   in them.  This doesn't count the length of comment lines unless\n *   [:comment :count?] is true, so that we don't format based on\n *   comment size -- that is handled with the wrap-comments elsewhere.\n *   Note that only vectors with :whitespace, :indent, or :newline are scanned\n *   for newlines, and if consecutive newlines appear, only the first\n *   is counted as a newline -- the second is counted as a regular \n *   character. A single comment is counted as two lines. Lots of edge\n *   conditions that are really quite important.\n */\nzprint.zprint.line_lengths_iter = (function zprint$zprint$line_lengths_iter(options,ind,style_vec){\nvar count_comment_QMARK_ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nvar ind__$1 = ((cljs.core.coll_QMARK_(ind))?cljs.core.first(ind):ind);\nvar next_vec = style_vec;\nvar current_string = null;\nvar line_length = ind__$1;\nvar previous_comment_QMARK_ = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(((cljs.core.empty_QMARK_(next_vec)) && (cljs.core.empty_QMARK_(current_string)))){\nif((((line_length === (0))) && (cljs.core.not(previous_comment_QMARK_)))){\nreturn out;\n} else {\nif(cljs.core.truth_(previous_comment_QMARK_)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(out,line_length,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(0)], 0));\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,line_length);\n\n}\n}\n} else {\nvar advance_QMARK_ = cljs.core.empty_QMARK_(current_string);\nvar vec__37143 = ((advance_QMARK_)?cljs.core.first(next_vec):null);\nvar next_string = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37143,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37143,(1),null);\nvar tag = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37143,(2),null);\nvar comment_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\nvar s = ((advance_QMARK_)?next_string:current_string);\nvar vec__37146 = (cljs.core.truth_(s)?((((comment_QMARK_) && (cljs.core.not(count_comment_QMARK_))))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\"], null):(cljs.core.truth_((function (){var or__4131__auto__ = ((advance_QMARK_) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn current_string;\n}\n})())?zprint.zprint.split_lf_2(s):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [s], null)\n)):null);\nvar l = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37146,(0),null);\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37146,(1),null);\nvar force_newline_QMARK_ = (function (){var and__4120__auto__ = previous_comment_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!(cljs.core.empty_QMARK_(l)));\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar r__$1 = (cljs.core.truth_(force_newline_QMARK_)?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(l),cljs.core.str.cljs$core$IFn$_invoke$arity$1(r)].join(''):r);\nvar l__$1 = (cljs.core.truth_(force_newline_QMARK_)?null:l);\nvar new_line_length = (line_length + cljs.core.count(l__$1));\nvar G__37704 = ((advance_QMARK_)?cljs.core.next(next_vec):next_vec);\nvar G__37705 = r__$1;\nvar G__37706 = (cljs.core.truth_(r__$1)?(0):new_line_length);\nvar G__37707 = comment_QMARK_;\nvar G__37708 = (cljs.core.truth_(r__$1)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_line_length):out);\nnext_vec = G__37704;\ncurrent_string = G__37705;\nline_length = G__37706;\nprevious_comment_QMARK_ = G__37707;\nout = G__37708;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a style-vec, and output a sequence of numbers, one for each\n *   line, which contains the actual length. Must take the current\n *   indent to have a prayer of getting this right, but it is used\n *   only for the first line.  The ind can be an integer or a seq of\n *   integers, in which case only the first integer is used. Newlines\n *   can come anywhere in an element in a style-vec, it will account\n *   for both sides.  Will break lines on comments even if no newlines\n *   in them.  This doesn't count the length of comment lines unless\n *   [:comment :count?] is true, so that we don't format based on\n *   comment size -- that is handled with the wrap-comments at the\n *   end. Note that only vectors with :whitespace or :indent are scanned\n *   for newlines, and if consecutive newlines appear, only the first\n *   is counted as a newline -- the second is counted as a regular \n *   character.\n */\nzprint.zprint.line_lengths = (function zprint$zprint$line_lengths(options,ind,style_vec){\nvar length_vec = cljs.core.first((function (){var count_comment_QMARK_ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nvar vec__37149 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.generate_ll,count_comment_QMARK_),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,((cljs.core.coll_QMARK_(ind))?cljs.core.first(ind):ind),null,null], null),style_vec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37149,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37149,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37149,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37149,(3),null);\nvar result = vec__37149;\nif(cljs.core.truth_((function (){var and__4120__auto__ = just_eol_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not(just_comment_QMARK_);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn result;\n} else {\nreturn zprint.zprint.accumulate_ll(count_comment_QMARK_,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result,(2),null),\"\",null,true);\n}\n})());\nreturn length_vec;\n});\n/**\n * This looks at a style vec and doesn't do all that style-lines does.\n *   It just looks for a new-line in the strings, and returns true if it\n *   doesn't find one.\n */\nzprint.zprint.single_line_QMARK_ = (function zprint$zprint$single_line_QMARK_(style_vec){\nreturn cljs.core.not(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__37164_SHARP_,p2__37165_SHARP_){\nvar or__4131__auto__ = p1__37164_SHARP_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn p2__37165_SHARP_;\n}\n}),false,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__37166_SHARP_){\nreturn clojure.string.includes_QMARK_(cljs.core.first(p1__37166_SHARP_),\"\\n\");\n}),style_vec)));\n});\n/**\n * Given a style-vec, come up with a string that gives some hint of \n *   where this style-vec came from.\n */\nzprint.zprint.find_what = (function zprint$zprint$find_what(style_vec){\nvar s_vec = style_vec;\nwhile(true){\nif(cljs.core.truth_(s_vec)){\nvar vec__37167 = cljs.core.first(s_vec);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37167,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37167,(1),null);\nvar this$ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37167,(2),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this$,new cljs.core.Keyword(null,\"element\",\"element\",1974019749))){\nreturn what;\n} else {\nvar G__37710 = cljs.core.next(s_vec);\ns_vec = G__37710;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Take a style output, and tell us how many lines it takes to print it\n *   and the maximum width that it reaches. Returns \n *   [<line-count> <max-width> [line-lengths]].\n *   Doesn't require any max-width inside the style-vec. Also returns the\n *   line lengths in case that is helpful (since we have them anyway).\n *   If (:dbg-ge options) has value, then uses find-what to see if what it\n *   finds matches the value, and if it does, place the value in the\n *   resulting vector.\n */\nzprint.zprint.style_lines = (function zprint$zprint$style_lines(options,ind,style_vec){\nif(cljs.core.truth_((function (){var and__4120__auto__ = style_vec;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (((!(cljs.core.empty_QMARK_(style_vec)))) && (cljs.core.not(zprint.zprint.contains_nil_QMARK_(style_vec))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar lengths = zprint.zprint.line_lengths_iter(options,ind,style_vec);\nvar result = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.count(lengths),cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,lengths),lengths], null);\nvar dbg_ge = new cljs.core.Keyword(null,\"dbg-ge\",\"dbg-ge\",257927017).cljs$core$IFn$_invoke$arity$1(options);\nvar what = (cljs.core.truth_((function (){var and__4120__auto__ = dbg_ge;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zprint.zprint.find_what(style_vec),dbg_ge);\n} else {\nreturn and__4120__auto__;\n}\n})())?dbg_ge:null);\nif(cljs.core.truth_(what)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(result,what);\n} else {\nreturn result;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given output from style-lines and options, see if it fits the width.  \n *   Return the number of lines it takes if it fits, nil otherwise.\n */\nzprint.zprint.fzfit = (function zprint$zprint$fzfit(p__37173,p__37174){\nvar map__37175 = p__37173;\nvar map__37175__$1 = (((((!((map__37175 == null))))?(((((map__37175.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37175.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37175):map__37175);\nvar options = map__37175__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37175__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37175__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37175__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar vec__37176 = p__37174;\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37176,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37176,(1),null);\nvar style_lines_return = vec__37176;\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzfit: fixed-rightcnt:\",(zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt)),\"line-count:\",line_count,\"max-width:\",max_width,\"width:\",width], 0));\n} else {\n}\n\nif(cljs.core.truth_(style_lines_return)){\nif((max_width <= (width - (zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt))))){\nreturn line_count;\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given the return from style-lines  and options, \n *   return true if it fits on a single line.\n */\nzprint.zprint.fzfit_one_line = (function zprint$zprint$fzfit_one_line(options,style_lines_return){\nvar lines = zprint.zprint.fzfit(options,style_lines_return);\nreturn ((typeof lines === 'number') && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(lines,(1))));\n});\n/**\n * Increase the rightmost count, if any, and return one if not.\n */\nzprint.zprint.rightmost = (function zprint$zprint$rightmost(options){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070),(new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$2(options,(0)) + (1)));\n});\n/**\n * Remove the rightmost count.\n */\nzprint.zprint.not_rightmost = (function zprint$zprint$not_rightmost(options){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\n});\n/**\n * Handle the complexity of commas and rightmost-pair with options.\n *   If it isn't a rightmost, it loses rightmost status.\n *   If it is a rightmost, and in the rightmost pair, it gain one rightmost\n *   since it has the right end thing (and we don't care about the comma).\n *   If it is the rightmost of the non-rightmost-pair, then the comma\n *   matters, and we handle that appropriately.  Whew!\n */\nzprint.zprint.c_r_pair = (function zprint$zprint$c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,rightmost_QMARK_,options){\nif(cljs.core.not(rightmost_QMARK_)){\nreturn zprint.zprint.not_rightmost(options);\n} else {\nif(cljs.core.truth_(rightmost_pair_QMARK_)){\nreturn options;\n} else {\nif(cljs.core.truth_(commas_QMARK_)){\nreturn zprint.zprint.rightmost(zprint.zprint.not_rightmost(options));\n} else {\nreturn zprint.zprint.not_rightmost(options);\n}\n}\n}\n});\n/**\n * Handle issue with rightcnt.\n */\nzprint.zprint.fix_rightcnt = (function zprint$zprint$fix_rightcnt(rightcnt){\nif(typeof rightcnt === 'number'){\nreturn rightcnt;\n} else {\nreturn (0);\n}\n});\nzprint.zprint.str__GT_key = cljs.core.PersistentHashMap.fromArrays([\"]\",\"'\",\")\",\"`\",\"~@\",\"~\",\"#{\",\"(\",\"#(\",\"{\",\"}\",\"[\",\"#_\",\"@\"],[new cljs.core.Keyword(null,\"bracket\",\"bracket\",-600276523),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),new cljs.core.Keyword(null,\"hash-brace\",\"hash-brace\",-1522139685),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600),new cljs.core.Keyword(null,\"hash-paren\",\"hash-paren\",-1158425562),new cljs.core.Keyword(null,\"brace\",\"brace\",-1705077624),new cljs.core.Keyword(null,\"brace\",\"brace\",-1705077624),new cljs.core.Keyword(null,\"bracket\",\"bracket\",-600276523),new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707),new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795)]);\n/**\n * Look up the thing in the zprint-color-map.  Accepts keywords or\n *   strings.\n */\nzprint.zprint.zcolor_map = (function zprint$zprint$zcolor_map(p__37180,key_or_str){\nvar map__37181 = p__37180;\nvar map__37181__$1 = (((((!((map__37181 == null))))?(((((map__37181.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37181.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37181):map__37181);\nvar options = map__37181__$1;\nvar color_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37181__$1,new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684));\nvar G__37183 = (((key_or_str instanceof cljs.core.Keyword))?key_or_str:(zprint.zprint.str__GT_key.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.str__GT_key.cljs$core$IFn$_invoke$arity$1(key_or_str) : zprint.zprint.str__GT_key.call(null,key_or_str)));\nreturn (color_map.cljs$core$IFn$_invoke$arity$1 ? color_map.cljs$core$IFn$_invoke$arity$1(G__37183) : color_map.call(null,G__37183));\n});\n/**\n * Take a style-vec, and if hangflow? is true, return a\n *   vector [hang-or-flow style-vec], else return style-vec.\n *   But a nil style-vec returns nil.\n */\nzprint.zprint.hangflow = (function zprint$zprint$hangflow(hangflow_QMARK_,hang_or_flow,style_vec){\nif(cljs.core.truth_(style_vec)){\nif(cljs.core.truth_(hangflow_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_or_flow,style_vec], null);\n} else {\nreturn style_vec;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Try to hang something and if it doesn't hang at all, then flow it,\n *   but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n *   fzprint-? function to use with zloc.  Callers need to know whether this\n *   was hang or flow, so it returns [{:hang | :flow} style-vec] all the time.\n */\nzprint.zprint.fzprint_hang_unless_fail = (function zprint$zprint$fzprint_hang_unless_fail(options,hindent,findent,fzfn,zloc){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail:\",(function (){var G__37184 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37184) : zprint.zfns.zstring.call(null,G__37184));\n})()], 0));\n} else {\n}\n\nvar hanging = (function (){var G__37185 = zprint.zprint.in_hang(options);\nvar G__37186 = hindent;\nvar G__37187 = zloc;\nreturn (fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(G__37185,G__37186,G__37187) : fzfn.call(null,G__37185,G__37186,G__37187));\n})();\nvar value__37009__auto__ = (cljs.core.truth_((function (){var and__4120__auto__ = hanging;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.fzfit(options,zprint.zprint.style_lines(options,hindent,hanging));\n} else {\nreturn and__4120__auto__;\n}\n})())?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),hanging], null):(function (){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail: hang failed, doing flow\"], 0));\n} else {\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : fzfn.call(null,options,findent,zloc))], 0))], null);\n})()\n);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n});\n/**\n * Given a style-vec with exactly one thing in it, replace the color\n *   with whatever local color we have determined is correct.\n */\nzprint.zprint.replace_color = (function zprint$zprint$replace_color(local_color,style_vec){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(style_vec),(1))){\nvar vec__37188 = style_vec;\nvar vec__37191 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37188,(0),null);\nvar string = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37191,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37191,(1),null);\nvar element = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37191,(2),null);\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [string,local_color,element], null)], null);\n} else {\nreturn style_vec;\n}\n});\n/**\n * Print a single pair of things (though it might not be exactly a\n *   pair, given comments and :extend and the like), like bindings in\n *   a let, clauses in a cond, keys and values in a map.  Controlled\n *   by various maps, the key of which is caller.  This will return a\n *   style-vec (or nil), unless hangflow? is true, in which case it\n *   will return [:hang <style-vec>] or [:flow <style-vec>] so that\n *   the upstream folks know whether this was a hang or flow and can\n *   do the right thing based on that.\n */\nzprint.zprint.fzprint_two_up = (function zprint$zprint$fzprint_two_up(caller,p__37194,ind,commas_QMARK_,justify_width,rightmost_pair_QMARK_,p__37195){\nvar map__37196 = p__37194;\nvar map__37196__$1 = (((((!((map__37196 == null))))?(((((map__37196.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37196.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37196):map__37196);\nvar options = map__37196__$1;\nvar map__37197 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,caller);\nvar map__37197__$1 = (((((!((map__37197 == null))))?(((((map__37197.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37197.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37197):map__37197);\nvar hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854));\nvar flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"flow?\",\"flow?\",96929057));\nvar indent_arg = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"indent-arg\",\"indent-arg\",58691874));\nvar key_depth_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"key-depth-color\",\"key-depth-color\",1448522819));\nvar indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar key_value_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"key-value-color\",\"key-value-color\",676042889));\nvar dbg_cnt_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"dbg-cnt?\",\"dbg-cnt?\",-1638028976));\nvar dbg_local_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"dbg-local?\",\"dbg-local?\",-895545325));\nvar key_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37197__$1,new cljs.core.Keyword(null,\"key-color\",\"key-color\",-209002572));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar dbg_indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nvar do_in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"do-in-hang?\",\"do-in-hang?\",-1235364947));\nvar map_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37196__$1,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641));\nvar vec__37198 = p__37195;\nvar lloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37198,(0),null);\nvar rloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37198,(1),null);\nvar xloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37198,(2),null);\nvar pair = vec__37198;\nif(cljs.core.truth_(dbg_cnt_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"two-up: caller:\",caller,\"hang?\",hang_QMARK_,\"dbg?\",dbg_QMARK_], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4131__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn dbg_local_QMARK_;\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var or__4131__auto__ = dbg_indent;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn \"\";\n}\n})(),\"==========================\",[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((function (){var or__4131__auto__ = dbg_indent;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn \"\";\n}\n})())].join(''),\"fzprint-two-up:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zstring.call(null,lloc)),\"caller:\",caller,\"count:\",cljs.core.count(pair),\"ind:\",ind,\"indent:\",indent,\"indent-arg:\",indent_arg,\"justify-width:\",justify_width,\"one-line?:\",one_line_QMARK_,\"hang?:\",hang_QMARK_,\"in-hang?\",in_hang_QMARK_,\"do-in-hang?\",do_in_hang_QMARK_,\"flow?\",flow_QMARK_,\"commas?\",commas_QMARK_,\"rightmost-pair?\",rightmost_pair_QMARK_], 0));\n} else {\n}\n\nvar local_hang_QMARK_ = (function (){var or__4131__auto__ = one_line_QMARK_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn hang_QMARK_;\n}\n})();\nvar indent__$1 = (function (){var or__4131__auto__ = indent;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn indent_arg;\n}\n})();\nvar local_options = ((cljs.core.not(local_hang_QMARK_))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true):options);\nvar loptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,null,options);\nvar roptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,new cljs.core.Keyword(null,\"rightmost\",\"rightmost\",800279518),options);\nvar local_roptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,new cljs.core.Keyword(null,\"rightmost\",\"rightmost\",800279518),local_options);\nvar value_color_map = (function (){var and__4120__auto__ = key_value_color;\nif(cljs.core.truth_(and__4120__auto__)){\nvar G__37209 = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zsexpr.call(null,lloc));\nreturn (key_value_color.cljs$core$IFn$_invoke$arity$1 ? key_value_color.cljs$core$IFn$_invoke$arity$1(G__37209) : key_value_color.call(null,G__37209));\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar local_roptions__$1 = (cljs.core.truth_(value_color_map)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([local_roptions,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),value_color_map], null)], 0)):local_roptions);\nvar roptions__$1 = (cljs.core.truth_(value_color_map)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([roptions,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),value_color_map], null)], 0)):roptions);\nvar modifier_set = new cljs.core.Keyword(null,\"modifiers\",\"modifiers\",50378834).cljs$core$IFn$_invoke$arity$1((options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller)));\nvar modifier_QMARK_ = (function (){var or__4131__auto__ = (function (){var and__4120__auto__ = modifier_set;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (function (){var G__37213 = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zstring.call(null,lloc));\nreturn (modifier_set.cljs$core$IFn$_invoke$arity$1 ? modifier_set.cljs$core$IFn$_invoke$arity$1(G__37213) : modifier_set.call(null,G__37213));\n})();\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (cljs.core.count(pair) > (2));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (zprint.zprint.middle_element_QMARK_.cljs$core$IFn$_invoke$arity$2 ? zprint.zprint.middle_element_QMARK_.cljs$core$IFn$_invoke$arity$2(options,rloc) : zprint.zprint.middle_element_QMARK_.call(null,options,rloc));\n}\n})();\nvar local_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(key_depth_color,(map_depth - (1)));\nvar local_color__$1 = (cljs.core.truth_(key_color)?(function (){var G__37214 = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zsexpr.call(null,lloc));\nreturn (key_color.cljs$core$IFn$_invoke$arity$1 ? key_color.cljs$core$IFn$_invoke$arity$1(G__37214) : key_color.call(null,G__37214));\n})():local_color);\nvar arg_1 = (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(loptions,ind,lloc) : zprint.zprint.fzprint_STAR_.call(null,loptions,ind,lloc));\nvar arg_1__$1 = (cljs.core.truth_(local_color__$1)?zprint.zprint.replace_color(local_color__$1,arg_1):arg_1);\nvar vec__37203 = zprint.zprint.style_lines(options,ind,arg_1__$1);\nvar arg_1_line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37203,(0),null);\nvar arg_1_max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37203,(1),null);\nvar arg_1_lines = vec__37203;\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up before modifier: arg-1-line-count:\",arg_1_line_count,\"arg-1-max-width:\",arg_1_max_width], 0)):null);\nvar modifier_QMARK___$1 = (cljs.core.truth_((function (){var and__4120__auto__ = arg_1_line_count;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (arg_1_line_count > (1));\n} else {\nreturn and__4120__auto__;\n}\n})())?null:modifier_QMARK_);\nvar combined_arg_1 = (cljs.core.truth_(modifier_QMARK___$1)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),(function (){var G__37215 = zprint.zprint.in_hang(loptions);\nvar G__37216 = (ind + arg_1_max_width);\nvar G__37217 = rloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37215,G__37216,G__37217) : zprint.zprint.fzprint_STAR_.call(null,G__37215,G__37216,G__37217));\n})()], 0)):arg_1__$1);\nvar arg_1__$2 = (cljs.core.truth_(combined_arg_1)?combined_arg_1:arg_1__$1);\nvar modifier_QMARK___$2 = (cljs.core.truth_(combined_arg_1)?modifier_QMARK___$1:null);\nvar vec__37206 = (cljs.core.truth_(combined_arg_1)?zprint.zprint.style_lines(options,ind,arg_1__$2):arg_1_lines);\nvar arg_1_line_count__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37206,(0),null);\nvar arg_1_max_width__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37206,(1),null);\nvar arg_1_lines__$1 = vec__37206;\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up after modifier: arg-1-line-count:\",arg_1_line_count__$1,\"arg-1-max-width:\",arg_1_max_width__$1], 0)):null);\nvar lloc__$1 = (cljs.core.truth_(modifier_QMARK___$2)?rloc:lloc);\nvar rloc__$1 = (cljs.core.truth_(modifier_QMARK___$2)?xloc:rloc);\nvar arg_1_fit_oneline_QMARK_ = ((cljs.core.not(flow_QMARK_)) && (zprint.zprint.fzfit_one_line(loptions,arg_1_lines__$1)));\nvar arg_1_fit_QMARK_ = (function (){var or__4131__auto__ = arg_1_fit_oneline_QMARK_;\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif(cljs.core.not(one_line_QMARK_)){\nreturn zprint.zprint.fzfit(loptions,arg_1_lines__$1);\n} else {\nreturn null;\n}\n}\n})();\nvar arg_1_width = ((function (){var or__4131__auto__ = arg_1_max_width__$1;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() - ind);\nif(cljs.core.truth_((function (){var and__4120__auto__ = arg_1__$2;\nif(cljs.core.truth_(and__4120__auto__)){\nvar or__4131__auto__ = arg_1_fit_QMARK_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.not(in_hang_QMARK_);\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(1))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(roptions__$1,ind,lloc__$1) : zprint.zprint.fzprint_STAR_.call(null,roptions__$1,ind,lloc__$1))], null);\n} else {\nif(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(2));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar and__4120__auto__ = modifier_QMARK___$2;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(3));\n} else {\nreturn and__4120__auto__;\n}\n}\n})())){\nvar hanging_width = (cljs.core.truth_(justify_width)?justify_width:arg_1_width);\nvar hanging_spaces = (cljs.core.truth_(justify_width)?((justify_width - arg_1_width) + (1)):(1));\nvar hanging_indent = (((1) + hanging_width) + ind);\nvar flow_indent = (indent__$1 + ind);\nif(cljs.core.truth_((function (){var and__4120__auto__ = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = zprint.zprint.keyword_fn_QMARK_(options,(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(rloc__$1) : zprint.zfns.zvector_QMARK_.call(null,rloc__$1));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar vec__37218 = zprint.zprint.fzprint_hang_unless_fail(loptions,hanging_indent,flow_indent,zprint.zprint.fzprint_binding_vec,rloc__$1);\nvar hang_or_flow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37218,(0),null);\nvar style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37218,(1),null);\nvar arg_1__$3 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hang_or_flow,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null)], 0)):arg_1__$2);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_or_flow,zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$3,style_vec], 0))], null);\n} else {\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before hang.  hanging tried?\",((arg_1_fit_oneline_QMARK_) && (((cljs.core.not(flow_QMARK_)) && ((flow_indent >= hanging_indent)))))], 0)):null);\nvar hanging = ((((arg_1_fit_oneline_QMARK_) || (((cljs.core.not(flow_QMARK_)) && ((flow_indent >= hanging_indent))))))?(function (){var G__37221 = (((flow_indent < hanging_indent))?zprint.zprint.in_hang(local_roptions__$1):local_roptions__$1);\nvar G__37222 = hanging_indent;\nvar G__37223 = rloc__$1;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37221,G__37222,G__37223) : zprint.zprint.fzprint_STAR_.call(null,G__37221,G__37222,G__37223));\n})():null);\nvar hang_count = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(rloc__$1) : zprint.zfns.zcount.call(null,rloc__$1));\nvar ___$3 = zprint.zprint.log_lines(options,\"fzprint-two-up: hanging:\",hanging_indent,hanging);\nvar hanging_lines = zprint.zprint.style_lines(options,hanging_indent,hanging);\nvar fit_QMARK_ = zprint.zprint.fzfit_one_line(local_roptions__$1,hanging_lines);\nvar hanging_lines__$1 = ((fit_QMARK_)?hanging_lines:(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not(one_line_QMARK_);\nif(and__4120__auto__){\nreturn hang_QMARK_;\n} else {\nreturn and__4120__auto__;\n}\n})())?hanging_lines:null));\nvar ___$4 = zprint.zprint.log_lines(options,\"fzprint-two-up: hanging-2:\",hanging_indent,hanging);\nvar flow_it_QMARK_ = ((((((cljs.core.not(hanging_lines__$1)) && (cljs.core.not(one_line_QMARK_)))) || (cljs.core.not((function (){var or__4131__auto__ = fit_QMARK_;\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn one_line_QMARK_;\n}\n})())))) && ((((flow_indent < hanging_indent)) || (cljs.core.not(hanging_lines__$1)))));\nvar ___$5 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before flow. flow-it?\",flow_it_QMARK_], 0)):null);\nvar flow = ((flow_it_QMARK_)?(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(roptions__$1,flow_indent,rloc__$1) : zprint.zprint.fzprint_STAR_.call(null,roptions__$1,flow_indent,rloc__$1)):null);\nvar ___$6 = zprint.zprint.log_lines(options,\"fzprint-two-up: flow:\",(indent__$1 + ind),flow);\nvar flow_lines = zprint.zprint.style_lines(options,(indent__$1 + ind),flow);\nif(cljs.core.truth_(dbg_local_QMARK_)){\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: local-hang:\",local_hang_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: one-line?:\",one_line_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging-indent:\",hanging_indent], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging-lines:\",hanging_lines__$1], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow?:\",flow_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow-it?:\",flow_it_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: fit?:\",fit_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow-indent:\",flow_indent], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)),hanging], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: (+ indent ind):\",(indent__$1 + ind)], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)),flow], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before good-enough\"], 0));\n} else {\n}\n\nif(fit_QMARK_){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),hanging], 0))], null);\n} else {\nif(cljs.core.truth_((function (){var or__4131__auto__ = hanging_lines__$1;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn flow_lines;\n}\n})())){\nif(cljs.core.truth_(zprint.zprint.good_enough_QMARK_(caller,roptions__$1,new cljs.core.Keyword(null,\"none-two-up\",\"none-two-up\",-457831686),hang_count,(hanging_indent - flow_indent),hanging_lines__$1,flow_lines))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),hanging], 0))], null);\n} else {\nif(cljs.core.truth_(justify_width)){\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),flow], 0))], null);\n}\n}\n} else {\nreturn null;\n}\n}\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(function (){var G__37224 = options;\nvar G__37225 = (indent__$1 + ind);\nvar G__37226 = (cljs.core.truth_(modifier_QMARK___$2)?cljs.core.nnext(pair):cljs.core.next(pair));\nvar G__37227 = new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826);\nreturn (zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4 ? zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4(G__37224,G__37225,G__37226,G__37227) : zprint.zprint.fzprint_flow_seq.call(null,G__37224,G__37225,G__37226,G__37227));\n})()], 0))], null);\n\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Figure the width for a justification of a set of pairs in coll.  \n *   Also, decide if it makes any sense to justify the pairs at all.\n *   For instance, they all need to be one-line.\n */\nzprint.zprint.fzprint_justify_width = (function zprint$zprint$fzprint_justify_width(caller,p__37233,ind,coll){\nvar map__37234 = p__37233;\nvar map__37234__$1 = (((((!((map__37234 == null))))?(((((map__37234.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37234.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37234):map__37234);\nvar options = map__37234__$1;\nvar map__37235 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37234__$1,caller);\nvar map__37235__$1 = (((((!((map__37235 == null))))?(((((map__37235.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37235.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37235):map__37235);\nvar justify_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37235__$1,new cljs.core.Keyword(null,\"justify?\",\"justify?\",294994148));\nvar firsts = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_){\nreturn (function (p1__37228_SHARP_){\nif((cljs.core.count(p1__37228_SHARP_) > (1))){\nvar G__37238 = options;\nvar G__37239 = ind;\nvar G__37240 = cljs.core.first(p1__37228_SHARP_);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37238,G__37239,G__37240) : zprint.zprint.fzprint_STAR_.call(null,G__37238,G__37239,G__37240));\n} else {\nreturn null;\n}\n});})(map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_))\n,coll));\nvar style_seq = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.style_lines,options,ind),firsts);\nvar each_one_line_QMARK_ = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (firsts,style_seq,map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_){\nreturn (function (p1__37229_SHARP_,p2__37230_SHARP_){\nif(cljs.core.truth_(p1__37229_SHARP_)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p2__37230_SHARP_),(1));\n} else {\nreturn null;\n}\n});})(firsts,style_seq,map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_))\n,true,style_seq);\nvar justify_width = (cljs.core.truth_(each_one_line_QMARK_)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (firsts,style_seq,each_one_line_QMARK_,map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_){\nreturn (function (p1__37231_SHARP_,p2__37232_SHARP_){\nvar x__4219__auto__ = p1__37231_SHARP_;\nvar y__4220__auto__ = cljs.core.second(p2__37232_SHARP_);\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n});})(firsts,style_seq,each_one_line_QMARK_,map__37234,map__37234__$1,options,map__37235,map__37235__$1,justify_QMARK_))\n,(0),style_seq):null);\nif(cljs.core.truth_(justify_width)){\nreturn (justify_width - ind);\n} else {\nreturn null;\n}\n});\n/**\n * Take a size and a collection of vectors with two or more elements\n *   per vector.  The elements are zlocs, the vectors are not.  Return\n *   the remaining character count or nil if it for sure doesn't fit.\n *   In order to be sure it doesn't fit, this version doesn't assume\n *   *any* separators, so it really underestimates the size.\n */\nzprint.zprint.fit_within_QMARK_ = (function zprint$zprint$fit_within_QMARK_(var_args){\nvar G__37242 = arguments.length;\nswitch (G__37242) {\ncase 3:\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 2:\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3 = (function (size,coll,depth){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (size__$1,element){\nvar or__4131__auto__ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(depth,(0)))?zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3(size__$1,element,(depth + (1))):(function (){var remaining = (size__$1 - cljs.core.count((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(element) : zprint.zfns.zstring.call(null,element))));\nif((remaining > (0))){\nreturn remaining;\n} else {\nreturn null;\n}\n})());\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.reduced(null);\n}\n}),size,coll);\n});\n\nzprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2 = (function (size,coll){\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3(size,coll,(0));\n});\n\nzprint.zprint.fit_within_QMARK_.cljs$lang$maxFixedArity = 3;\n\n/**\n * Convert a hangflow style-vec to a regular style-vec.\n */\nzprint.zprint.remove_hangflow = (function zprint$zprint$remove_hangflow(hf_style_vec){\nif(cljs.core.truth_(hf_style_vec)){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.second,hf_style_vec);\n} else {\nreturn null;\n}\n});\n/**\n * Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n *   If you have :one-line? set, this will return nil if it is way over,\n *   but it can't accurately tell exactly what will fit on one line, since\n *   it doesn't know the separators and such.  So, :one-line? true is a\n *   performance optimization, so it doesn't do a whole huge map just to\n *   find out that it could not possibly have fit on one line.  So, this\n *   returns a sequence of style-vecs, where the indentation for the\n *   stuff inside of the pairs is already there, but the separators of\n *   the style-vecs (including indentation and commas) is done by the\n *   caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n *   [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n *   If you want a style vec instead, call remove-hangflow on the return \n *   from fzprint-map-two-up.  This will use one-line?, but not check to see\n *   that it actually fits.  If you care about that, then you should check the\n *   return yourself.  It will, however, make an estimate of whether or not\n *   it will fit and if it clearly doesn't, it will return a nil.\n */\nzprint.zprint.fzprint_map_two_up = (function zprint$zprint$fzprint_map_two_up(caller,p__37243,ind,commas_QMARK_,coll){\nvar map__37244 = p__37243;\nvar map__37244__$1 = (((((!((map__37244 == null))))?(((((map__37244.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37244.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37244):map__37244);\nvar options = map__37244__$1;\nvar map__37245 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37244__$1,caller);\nvar map__37245__$1 = (((((!((map__37245 == null))))?(((((map__37245.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37245.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37245):map__37245);\nvar justify_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37245__$1,new cljs.core.Keyword(null,\"justify?\",\"justify?\",294994148));\nvar force_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37245__$1,new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37244__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37244__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37244__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar parallel_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37244__$1,new cljs.core.Keyword(null,\"parallel?\",\"parallel?\",-25273892));\nvar caller_map = (caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options));\nvar len = cljs.core.count(coll);\nvar justify_width = (cljs.core.truth_((function (){var and__4120__auto__ = justify_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not(one_line_QMARK_);\n} else {\nreturn and__4120__auto__;\n}\n})())?zprint.zprint.fzprint_justify_width(caller,options,ind,coll):null);\nvar caller_options = (cljs.core.truth_(justify_width)?(options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller)):null);\nif(cljs.core.truth_((function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872).cljs$core$IFn$_invoke$arity$1(options);\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: one-line?\",new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111).cljs$core$IFn$_invoke$arity$1(options),\"justify?:\",justify_QMARK_], 0));\n} else {\n}\n\nif(cljs.core.not((function (){var and__4120__auto__ = one_line_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = force_nl_QMARK_;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (len > (1));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar justify_width__$1 = justify_width;\nvar justify_options = (cljs.core.truth_(justify_width__$1)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options,cljs.core.PersistentArrayMap.createAsIfByAssoc([caller,(function (){var G__37250 = new cljs.core.Keyword(null,\"justify-hang\",\"justify-hang\",1083292243);\nreturn (caller_options.cljs$core$IFn$_invoke$arity$1 ? caller_options.cljs$core$IFn$_invoke$arity$1(G__37250) : caller_options.call(null,G__37250));\n})()])], 0)),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tuning\",\"tuning\",-48660925),(function (){var G__37251 = new cljs.core.Keyword(null,\"justify-tuning\",\"justify-tuning\",-958931675);\nreturn (caller_options.cljs$core$IFn$_invoke$arity$1 ? caller_options.cljs$core$IFn$_invoke$arity$1(G__37251) : caller_options.call(null,G__37251));\n})()], null)], 0)):options);\nwhile(true){\nvar beginning_coll = cljs.core.butlast(coll);\nvar beginning_remaining = (cljs.core.truth_(one_line_QMARK_)?zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((width - ind),beginning_coll):true);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: remaining:\",(width - ind),\"beginning-remaining:\",beginning_remaining], 0)):null);\nvar beginning = (cljs.core.truth_(beginning_remaining)?zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3(options,cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic(zprint.zprint.fzprint_two_up,caller,justify_options,ind,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([commas_QMARK_,justify_width__$1,null], 0)),beginning_coll):null);\nvar beginning__$1 = (cljs.core.truth_(zprint.zprint.contains_nil_QMARK_(beginning))?null:beginning);\nvar end_coll = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.last(coll)], null);\nvar end_remaining = (cljs.core.truth_(one_line_QMARK_)?(function (){var and__4120__auto__ = beginning__$1;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((beginning_remaining - rightcnt),end_coll);\n} else {\nreturn and__4120__auto__;\n}\n})():true);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: beginning-remaining:\",beginning_remaining,\"rightcnt:\",rightcnt,\"end-remaining:\",end_remaining], 0)):null);\nvar end = (cljs.core.truth_(end_remaining)?(function (){var temp__5720__auto__ = zprint.zprint.fzprint_two_up(caller,justify_options,ind,commas_QMARK_,justify_width__$1,new cljs.core.Keyword(null,\"rightmost-pair\",\"rightmost-pair\",-39229380),cljs.core.first(end_coll));\nif(cljs.core.truth_(temp__5720__auto__)){\nvar end_result = temp__5720__auto__;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [end_result], null);\n} else {\nreturn null;\n}\n})():null);\nvar result = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(1)))?end:zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([beginning__$1,end], 0))\n);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: len:\",len,\"(nil? end):\",(end == null),\"end:\",end,\"(nil? beginning):\",(beginning__$1 == null),\"beginning:\",beginning__$1,\"(count end):\",cljs.core.count(end),\"(count beginnging):\",cljs.core.count(beginning__$1),\"justify-width:\",justify_width__$1,\"result:\",result], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4131__auto__ = result;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.not(justify_width__$1);\n}\n})())){\nreturn result;\n} else {\nvar G__37748 = null;\nvar G__37749 = options;\njustify_width__$1 = G__37748;\njustify_options = G__37749;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Do a key comparison that works well for numbers as well as\n *   strings.\n */\nzprint.zprint.compare_keys = (function zprint$zprint$compare_keys(x,y){\nif(((typeof x === 'number') && (typeof y === 'number'))){\nreturn cljs.core.compare(x,y);\n} else {\nreturn cljs.core.compare(cljs.core.str.cljs$core$IFn$_invoke$arity$1(x),cljs.core.str.cljs$core$IFn$_invoke$arity$1(y));\n\n}\n});\n/**\n * Do a key comparison that places ordered keys first.\n */\nzprint.zprint.compare_ordered_keys = (function zprint$zprint$compare_ordered_keys(key_value,zdotdotdot,x,y){\nif(cljs.core.truth_((function (){var and__4120__auto__ = (key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.compare((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x)),(key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y)));\n} else {\nif(cljs.core.truth_((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x)))){\nreturn (-1);\n} else {\nif(cljs.core.truth_((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y)))){\nreturn (1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zdotdotdot,x)){\nreturn (1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zdotdotdot,y)){\nreturn (-1);\n} else {\nreturn zprint.zprint.compare_keys(x,y);\n\n}\n}\n}\n}\n}\n});\n/**\n * A variety of sorting and ordering options for the output of\n *   partition-all-2-nc.  It can sort, which is the default, but if\n *   the caller has a key-order vector, it will extract any keys in\n *   that vector and place them first (in order) before sorting the\n *   other keys.  If sorting is not called for, does nothing.\n */\nzprint.zprint.order_out = (function zprint$zprint$order_out(caller,p__37254,access,out){\nvar map__37255 = p__37254;\nvar map__37255__$1 = (((((!((map__37255 == null))))?(((((map__37255.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37255.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37255):map__37255);\nvar options = map__37255__$1;\nvar map__37256 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37255__$1,caller);\nvar map__37256__$1 = (((((!((map__37256 == null))))?(((((map__37256.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37256.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37256):map__37256);\nvar sort_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37256__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37256__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar key_order = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37256__$1,new cljs.core.Keyword(null,\"key-order\",\"key-order\",-356936372));\nvar key_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37256__$1,new cljs.core.Keyword(null,\"key-value\",\"key-value\",-34906839));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37255__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core.truth_((function (){var and__4120__auto__ = sort_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nif(cljs.core.truth_(in_code_QMARK_)){\nreturn sort_in_code_QMARK_;\n} else {\nreturn true;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2(((function (map__37255,map__37255__$1,options,map__37256,map__37256__$1,sort_QMARK_,sort_in_code_QMARK_,key_order,key_value,in_code_QMARK_){\nreturn (function (p1__37252_SHARP_,p2__37253_SHARP_){\nvar G__37260 = (function (){var G__37262 = (access.cljs$core$IFn$_invoke$arity$1 ? access.cljs$core$IFn$_invoke$arity$1(p1__37252_SHARP_) : access.call(null,p1__37252_SHARP_));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__37262) : zprint.zfns.zsexpr.call(null,G__37262));\n})();\nvar G__37261 = (function (){var G__37263 = (access.cljs$core$IFn$_invoke$arity$1 ? access.cljs$core$IFn$_invoke$arity$1(p2__37253_SHARP_) : access.call(null,p2__37253_SHARP_));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__37263) : zprint.zfns.zsexpr.call(null,G__37263));\n})();\nvar fexpr__37259 = cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.compare_ordered_keys,(function (){var or__4131__auto__ = key_value;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)));\nreturn (fexpr__37259.cljs$core$IFn$_invoke$arity$2 ? fexpr__37259.cljs$core$IFn$_invoke$arity$2(G__37260,G__37261) : fexpr__37259.call(null,G__37260,G__37261));\n});})(map__37255,map__37255__$1,options,map__37256,map__37256__$1,sort_QMARK_,sort_in_code_QMARK_,key_order,key_value,in_code_QMARK_))\n,out);\n} else {\nreturn out;\n}\n});\n/**\n * This checks to see if an element should be considered part of a\n *   pair if it comes between other elements, and a single element on\n *   its own if it would otherwise be the first part of a pair.  Mostly\n *   this will trigger on comments, but a #_(...) element will also\n *   trigger this.\n */\nzprint.zprint.pair_element_QMARK_ = (function zprint$zprint$pair_element_QMARK_(zloc){\nvar or__4131__auto__ = (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (zprint.zfns.zuneval_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zuneval_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zuneval_QMARK_.call(null,zloc));\n}\n});\n/**\n * This checks to see if an element should be considered the middle element\n *   of a pair.  At some point, we can expand this, but for now there is only\n *   one middle element.\n */\nzprint.zprint.middle_element_QMARK_ = (function zprint$zprint$middle_element_QMARK_(p__37264,zloc){\nvar map__37265 = p__37264;\nvar map__37265__$1 = (((((!((map__37265 == null))))?(((((map__37265.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37265.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37265):map__37265);\nvar options = map__37265__$1;\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37265__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(in_code_QMARK_,\"condp\")){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\":>>\");\n} else {\nreturn null;\n}\n});\n/**\n * If given a non-collection, simply does a dissoc of the key, but\n *   if given a sequence of keys, will remove the final one.\n */\nzprint.zprint.remove_key_seq = (function zprint$zprint$remove_key_seq(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nvar this_key = cljs.core.first(ks);\nvar next_key = cljs.core.next(ks);\nif(next_key){\nvar removed_map = (function (){var G__37267 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,this_key);\nvar G__37268 = cljs.core.next(ks);\nreturn (zprint.zprint.remove_key_seq.cljs$core$IFn$_invoke$arity$2 ? zprint.zprint.remove_key_seq.cljs$core$IFn$_invoke$arity$2(G__37267,G__37268) : zprint.zprint.remove_key_seq.call(null,G__37267,G__37268));\n})();\nif(cljs.core.empty_QMARK_(removed_map)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,this_key);\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,this_key,removed_map);\n}\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,this_key);\n}\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,ks);\n}\n});\n/**\n * Given a map and a key sequence, remove that key sequence if\n *   it appears in the map, and terminate the reduce if it changes\n *   the map.\n */\nzprint.zprint.ignore_key_seq_silent = (function zprint$zprint$ignore_key_seq_silent(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn zprint.zprint.remove_key_seq(m,ks);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,ks);\n}\n}\n});\n/**\n * Given a map and a key sequence, remove that key sequence if\n *   it appears in the map leaving behind a key :zprint-ignored, \n *   and terminate the reduce if it changes the map.\n */\nzprint.zprint.ignore_key_seq = (function zprint$zprint$ignore_key_seq(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.assoc_in(m,ks,new cljs.core.Keyword(null,\"zprint-ignored\",\"zprint-ignored\",434436784));\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-ignored\",\"zprint-ignored\",434436784));\n}\n}\n});\n/**\n * Take a map and remove any of the key sequences specified from it.\n *   Note that this only works for sexpressions, not for actual zippers.\n */\nzprint.zprint.map_ignore = (function zprint$zprint$map_ignore(caller,p__37269,zloc){\nvar map__37270 = p__37269;\nvar map__37270__$1 = (((((!((map__37270 == null))))?(((((map__37270.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37270.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37270):map__37270);\nvar options = map__37270__$1;\nvar map__37271 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37270__$1,caller);\nvar map__37271__$1 = (((((!((map__37271 == null))))?(((((map__37271.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37271.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37271):map__37271);\nvar key_ignore = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37271__$1,new cljs.core.Keyword(null,\"key-ignore\",\"key-ignore\",75506668));\nvar key_ignore_silent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37271__$1,new cljs.core.Keyword(null,\"key-ignore-silent\",\"key-ignore-silent\",-1720115060));\nvar ignored_silent = (cljs.core.truth_(key_ignore_silent)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.ignore_key_seq_silent,zloc,key_ignore_silent):zloc);\nvar ignored = (cljs.core.truth_(key_ignore)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.ignore_key_seq,ignored_silent,key_ignore):ignored_silent);\nreturn ignored;\n});\n/**\n * Input is (zseqnws zloc) where one assumes that these are pairs.\n *   Thus, a seq of zlocs.  Output is a sequence of seqs, where the\n *   seqs are usually pairs, but might be single things.  Doesn't pair\n *   up comments or #_(...) unevaled sexpressions.  The ones before\n *   the first part of a pair come as a single element in what would\n *   usually be a pair, and the ones between the first and second parts\n *   of a pair come inside the pair.  There may be an arbitrary number\n *   of elements between the first and second elements of the pair\n *   (one per line).  If there are any comments or unevaled sexpressions,\n *   don't sort the keys, as we might lose track of where the comments\n *   or unevaled s-expressions go.\n */\nzprint.zprint.partition_all_2_nc = (function zprint$zprint$partition_all_2_nc(p__37275,coll){\nvar map__37276 = p__37275;\nvar map__37276__$1 = (((((!((map__37276 == null))))?(((((map__37276.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37276.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37276):map__37276);\nvar options = map__37276__$1;\nvar max_length = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37276__$1,new cljs.core.Keyword(null,\"max-length\",\"max-length\",-254826109));\nif(cljs.core.empty_QMARK_(coll)){\nreturn null;\n} else {\nvar remaining = coll;\nvar no_sort_QMARK_ = null;\nvar index = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.not(remaining)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [no_sort_QMARK_,cljs.core.persistent_BANG_(out)], null);\n} else {\nvar vec__37284 = (cljs.core.truth_(zprint.zprint.pair_element_QMARK_(cljs.core.first(remaining)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),true], null):(cljs.core.truth_((function (){var or__4131__auto__ = zprint.zprint.pair_element_QMARK_(cljs.core.second(remaining));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn zprint.zprint.middle_element_QMARK_(options,cljs.core.second(remaining));\n}\n})())?(function (){var vec__37287 = cljs.core.split_with(((function (remaining,no_sort_QMARK_,index,out,map__37276,map__37276__$1,options,max_length){\nreturn (function (p1__37274_SHARP_){\nvar or__4131__auto__ = zprint.zprint.pair_element_QMARK_(p1__37274_SHARP_);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn zprint.zprint.middle_element_QMARK_(options,p1__37274_SHARP_);\n}\n});})(remaining,no_sort_QMARK_,index,out,map__37276,map__37276__$1,options,max_length))\n,cljs.core.next(remaining));\nvar comment_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37287,(0),null);\nvar rest_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37287,(1),null);\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(rest_seq),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),comment_seq,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(rest_seq)], null)], 0))),true], null);\n})():((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(remaining),(1)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),null], null):new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(cljs.core.next(remaining)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining),cljs.core.second(remaining)], null),null], null)\n)));\nvar new_remaining = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37284,(0),null);\nvar pair_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37284,(1),null);\nvar new_no_sort_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37284,(2),null);\nvar G__37753 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(index,max_length))?new_remaining:(new cljs.core.List(null,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)),null,(1),null)));\nvar G__37754 = (function (){var or__4131__auto__ = no_sort_QMARK_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn new_no_sort_QMARK_;\n}\n})();\nvar G__37755 = (index + (1));\nvar G__37756 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,pair_vec);\nremaining = G__37753;\nno_sort_QMARK_ = G__37754;\nindex = G__37755;\nout = G__37756;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a seq, and if it is contains a single symbol, simply return\n *   it in another seq.  If it contains something else, remove any non\n *   collections off of the end and return them in their own double seqs,\n *   as well as return the remainder (the beginning) as a double seq.\n */\nzprint.zprint.cleave_end = (function zprint$zprint$cleave_end(coll){\nif(cljs.core.truth_((function (){var or__4131__auto__ = (function (){var G__37292 = cljs.core.first(coll);\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37292) : zprint.zfns.zsymbol_QMARK_.call(null,G__37292));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar G__37293 = cljs.core.first(coll);\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37293) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,G__37293));\n}\n})())){\nreturn (new cljs.core.List(null,coll,null,(1),null));\n} else {\nvar rev_seq = cljs.core.reverse(coll);\nvar vec__37294 = cljs.core.split_with(((function (rev_seq){\nreturn (function (p1__37290_SHARP_){\nreturn cljs.core.not((function (){var or__4131__auto__ = (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37290_SHARP_) : zprint.zfns.zcoll_QMARK_.call(null,p1__37290_SHARP_));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (zprint.zfns.zreader_cond_w_coll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_coll_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37290_SHARP_) : zprint.zfns.zreader_cond_w_coll_QMARK_.call(null,p1__37290_SHARP_));\n}\n})());\n});})(rev_seq))\n,rev_seq);\nvar split_non_coll = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37294,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37294,(1),null);\nvar split_non_coll__$1 = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.list,cljs.core.reverse(split_non_coll));\nvar remainder = cljs.core.take.cljs$core$IFn$_invoke$arity$2((cljs.core.count(coll) - cljs.core.count(split_non_coll__$1)),coll);\nif(cljs.core.empty_QMARK_(remainder)){\nreturn split_non_coll__$1;\n} else {\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((new cljs.core.List(null,remainder,null,(1),null)),split_non_coll__$1);\n}\n}\n});\n/**\n * Similar to partition-all-2-nc, but instead of trying to pair things\n *   up (modulo comments and unevaled expressions), this begins things\n *   with a symbol, and then accumulates collections until the next symbol.\n *   Returns a seq of seqs, where the first thing in each internal seq is\n *   a protocol and the remaining thing in that seq are the expressions that\n *   follow.  If there is a single thing, it is returned in its own internal\n *   seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n *   Made harder by the fact that the symbol might be inside of a #?() reader\n *   conditional.  It handles comments before symbols on the symbol indent, \n *   and the comments before the collections on the collection indent.  \n *   Since it doesn't know how many collections there are, this is not trivial.  \n *   Must be called with a sequence of z-things\n */\nzprint.zprint.partition_all_sym = (function zprint$zprint$partition_all_sym(options,modifier_set,coll){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"partition-all-sym: coll:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,coll)], 0));\n} else {\n}\n\nvar part_sym = cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2((function (p1__37297_SHARP_){\nvar or__4131__auto__ = (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37297_SHARP_) : zprint.zfns.zsymbol_QMARK_.call(null,p1__37297_SHARP_));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37297_SHARP_) : zprint.zfns.znil_QMARK_.call(null,p1__37297_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37297_SHARP_) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,p1__37297_SHARP_));\n}\n}\n}),coll);\nvar split_non_coll = cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(zprint.zprint.cleave_end,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([part_sym], 0));\nvar remaining = split_non_coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(remaining)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar vec__37313 = (cljs.core.truth_((function (){var and__4120__auto__ = (function (){var or__4131__auto__ = (function (){var G__37322 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37322) : zprint.zfns.zsymbol_QMARK_.call(null,G__37322));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (function (){var G__37324 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37324) : zprint.zfns.znil_QMARK_.call(null,G__37324));\n})();\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar G__37325 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37325) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,G__37325));\n}\n}\n})();\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!(cljs.core.empty_QMARK_(cljs.core.second(remaining))));\n} else {\nreturn and__4120__auto__;\n}\n})())?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(cljs.core.first(remaining)),(1)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.nthnext(remaining,(2)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.first(remaining),cljs.core.second(remaining)))], null):(cljs.core.truth_((function (){var and__4120__auto__ = modifier_set;\nif(cljs.core.truth_(and__4120__auto__)){\nvar G__37326 = (function (){var G__37327 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37327) : zprint.zfns.zstring.call(null,G__37327));\n})();\nreturn (modifier_set.cljs$core$IFn$_invoke$arity$1 ? modifier_set.cljs$core$IFn$_invoke$arity$1(G__37326) : modifier_set.call(null,G__37326));\n} else {\nreturn and__4120__auto__;\n}\n})())?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(cljs.core.first(remaining)),(2)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.nthnext(remaining,(2)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.first(remaining),cljs.core.second(remaining)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [((cljs.core.next(cljs.core.next(cljs.core.first(remaining))))?cljs.core.cons(cljs.core.next(cljs.core.next(cljs.core.first(remaining))),cljs.core.next(remaining)):cljs.core.next(remaining)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(new cljs.core.List(null,cljs.core.ffirst(remaining),(new cljs.core.List(null,cljs.core.second(cljs.core.first(remaining)),null,(1),null)),(2),null)))], null)):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cons(cljs.core.next(cljs.core.first(remaining)),cljs.core.next(remaining)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(new cljs.core.List(null,cljs.core.ffirst(remaining),null,(1),null)))], null))):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(remaining))], null)\n);\nvar next_remaining = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37313,(0),null);\nvar new_out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37313,(1),null);\nvar G__37758 = next_remaining;\nvar G__37759 = new_out;\nremaining = G__37758;\nout = G__37759;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Create an r-str-vec with, possibly, a newline at the beginning if\n *   the last thing before it is a comment.\n */\nzprint.zprint.rstr_vec = (function zprint$zprint$rstr_vec(var_args){\nvar G__37329 = arguments.length;\nswitch (G__37329) {\ncase 5:\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 4:\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5 = (function (options,ind,zloc,r_str,r_type){\nvar nl = (cljs.core.truth_((function (){var G__37330 = (zprint.zfns.zlast.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlast.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zlast.call(null,zloc));\nreturn (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37330) : zprint.zfns.zcomment_QMARK_.call(null,G__37330));\n})())?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null):null);\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(nl,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [r_str,zprint.zprint.zcolor_map(options,(function (){var or__4131__auto__ = r_type;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn r_str;\n}\n})()),(function (){var or__4131__auto__ = r_type;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"right\",\"right\",-452581833);\n}\n})()], null)], null));\n});\n\nzprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc,r_str){\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5(options,ind,zloc,r_str,null);\n});\n\nzprint.zprint.rstr_vec.cljs$lang$maxFixedArity = 5;\n\nzprint.zprint.fzprint_binding_vec = (function zprint$zprint$fzprint_binding_vec(p__37331,ind,zloc){\nvar map__37332 = p__37331;\nvar map__37332__$1 = (((((!((map__37332 == null))))?(((((map__37332.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37332.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37332):map__37332);\nvar options = map__37332__$1;\nvar map__37333 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37332__$1,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593));\nvar map__37333__$1 = (((((!((map__37333 == null))))?(((((map__37333.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37333.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37333):map__37333);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37333__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-binding-vec:\",(function (){var G__37336 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37336) : zprint.zfns.zstring.call(null,G__37336));\n})()], 0));\n} else {\n}\n\nvar options__$1 = zprint.zprint.rightmost(options);\nvar l_str = \"[\";\nvar r_str = \"]\";\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options__$1,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$1,(ind + (1)),zloc,r_str);\nvar value__37009__auto__ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)),(0)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0)):zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37337 = new cljs.core.Keyword(null,\"binding\",\"binding\",539932593).cljs$core$IFn$_invoke$arity$1(options__$1);\nvar G__37338 = (ind + (1));\nvar G__37339 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),options__$1,(ind + (1)),false,cljs.core.second(zprint.zprint.partition_all_2_nc(options__$1,(zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zseqnws.call(null,zloc)))));\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37337,G__37338,G__37339) : zprint.zprint.interpose_nl_hf.call(null,G__37337,G__37338,G__37339));\n})(),r_str_vec], 0)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-binding-vec exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n});\n/**\n * Try to hang something and try to flow it, and then see which is\n *   better.  Has hang and flow indents. fzfn is the function to use \n *   to do zloc.  Note what fzfn does with the input.  For instance,\n *   fzprint-pairs does a (zmap-right identity zloc).  Presumably the\n *   caller knows what the fzfn does, so it has to count the items\n *   itself and pass it in here as zloc-count if it isn't just (zcount zloc).\n */\nzprint.zprint.fzprint_hang = (function zprint$zprint$fzprint_hang(p__37340,caller,hindent,findent,fzfn,zloc_count,zloc){\nvar map__37341 = p__37340;\nvar map__37341__$1 = (((((!((map__37341 == null))))?(((((map__37341.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37341.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37341):map__37341);\nvar options = map__37341__$1;\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37341__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang:\",(function (){var G__37343 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37343) : zprint.zfns.zstring.call(null,G__37343));\n})(),\"caller:\",caller], 0));\n} else {\n}\n\nvar hanging = (cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent);\nif(and__4120__auto__){\nvar G__37347 = new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854);\nvar fexpr__37346 = (options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller));\nreturn (fexpr__37346.cljs$core$IFn$_invoke$arity$1 ? fexpr__37346.cljs$core$IFn$_invoke$arity$1(G__37347) : fexpr__37346.call(null,G__37347));\n} else {\nreturn and__4120__auto__;\n}\n})())?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),(function (){var G__37348 = zprint.zprint.in_hang(options);\nvar G__37349 = hindent;\nvar G__37350 = zloc;\nreturn (fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(G__37348,G__37349,G__37350) : fzfn.call(null,G__37348,G__37349,G__37350));\n})()], 0)):null);\nvar hang_count = (function (){var or__4131__auto__ = zloc_count;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\n}\n})();\nvar hr_lines = zprint.zprint.style_lines(options,(hindent - (1)),hanging);\nif(cljs.core.truth_((function (){var or__4131__auto__ = zprint.zprint.fzfit_one_line(options,hr_lines);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn one_line_QMARK_;\n}\n})())){\nreturn hanging;\n} else {\nvar flow = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : fzfn.call(null,options,findent,zloc))], 0));\nvar _ = zprint.zprint.log_lines(options,\"fzprint-hang: flow:\",findent,flow);\nvar fd_lines = zprint.zprint.style_lines(options,findent,flow);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang: ending: hang-count:\",hang_count,\"hanging:\",hanging,\"flow:\",flow], 0)):null);\nvar hr_good_QMARK_ = (cljs.core.truth_(new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options))))?zprint.zprint.good_enough_QMARK_(caller,options,new cljs.core.Keyword(null,\"none-hang\",\"none-hang\",-1101780299),hang_count,(hindent - findent),hr_lines,fd_lines):null);\nif(cljs.core.truth_(hr_good_QMARK_)){\nreturn hanging;\n} else {\nreturn flow;\n}\n}\n});\n/**\n * Always prints pairs on a different line from other pairs.\n */\nzprint.zprint.fzprint_pairs = (function zprint$zprint$fzprint_pairs(p__37351,ind,zloc){\nvar map__37352 = p__37351;\nvar map__37352__$1 = (((((!((map__37352 == null))))?(((((map__37352.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37352.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37352):map__37352);\nvar options = map__37352__$1;\nvar map__37353 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37352__$1,new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312));\nvar map__37353__$1 = (((((!((map__37353 == null))))?(((((map__37353.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37353.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37353):map__37353);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37353__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-pairs:\",(function (){var G__37356 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37356) : zprint.zfns.zstring.call(null,G__37356));\n})()], 0));\n} else {\n}\n\nvar value__37009__auto__ = (function (){var G__37357 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37358 = ind;\nvar G__37359 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),options,ind,false,(function (){var vec__37360 = zprint.zprint.partition_all_2_nc(options,(zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_right.call(null,cljs.core.identity,zloc)));\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37360,(0),null);\nvar part = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37360,(1),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-pairs: partition:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,cljs.core.first),part)], 0));\n} else {\n}\n\nreturn part;\n})());\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37357,G__37358,G__37359) : zprint.zprint.interpose_nl_hf.call(null,G__37357,G__37358,G__37359));\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-pairs: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n});\n/**\n * Print things with a symbol and collections following.  Kind of like with\n *   pairs, but not quite. This skips over zloc and does everything to the\n *   right of it!\n */\nzprint.zprint.fzprint_extend = (function zprint$zprint$fzprint_extend(p__37364,ind,zloc){\nvar map__37365 = p__37364;\nvar map__37365__$1 = (((((!((map__37365 == null))))?(((((map__37365.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37365.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37365):map__37365);\nvar options = map__37365__$1;\nvar map__37366 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37365__$1,new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006));\nvar map__37366__$1 = (((((!((map__37366 == null))))?(((((map__37366.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37366.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37366):map__37366);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37366__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend:\",(function (){var G__37369 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37369) : zprint.zfns.zstring.call(null,G__37369));\n})()], 0));\n} else {\n}\n\nvar value__37009__auto__ = (function (){var G__37370 = new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37371 = ind;\nvar G__37372 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),ind,false,(function (){var part = zprint.zprint.partition_all_sym(options,new cljs.core.Keyword(null,\"modifiers\",\"modifiers\",50378834).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006).cljs$core$IFn$_invoke$arity$1(options)),(zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_right.call(null,cljs.core.identity,zloc)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend: partition:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (part,G__37370,G__37371,map__37365,map__37365__$1,options,map__37366,map__37366__$1,nl_separator_QMARK_){\nreturn (function (p1__37363_SHARP_){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,p1__37363_SHARP_);\n});})(part,G__37370,G__37371,map__37365,map__37365__$1,options,map__37366,map__37366__$1,nl_separator_QMARK_))\n,part)], 0));\n} else {\n}\n\nreturn part;\n})());\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37370,G__37371,G__37372) : zprint.zprint.interpose_nl_hf.call(null,G__37370,G__37371,G__37372));\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n});\n/**\n * Given a transient vector v, concatenate all of the other\n *   elements in all of the remaining collections onto v.\n */\nzprint.zprint.concatv_BANG_ = (function zprint$zprint$concatv_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___37792 = arguments.length;\nvar i__4731__auto___37793 = (0);\nwhile(true){\nif((i__4731__auto___37793 < len__4730__auto___37792)){\nargs__4736__auto__.push((arguments[i__4731__auto___37793]));\n\nvar G__37795 = (i__4731__auto___37793 + (1));\ni__4731__auto___37793 = G__37795;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\nzprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (v,rest){\nvar cols = rest;\nvar out = v;\nwhile(true){\nif(cljs.core.truth_(cols)){\nvar G__37796 = cljs.core.next(cols);\nvar G__37797 = (function (){var col = cljs.core.first(cols);\nvar out__$1 = out;\nwhile(true){\nif(cljs.core.truth_(col)){\nvar G__37798 = cljs.core.next(col);\nvar G__37799 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out__$1,cljs.core.first(col));\ncol = G__37798;\nout__$1 = G__37799;\ncontinue;\n} else {\nreturn out__$1;\n}\nbreak;\n}\n})();\ncols = G__37796;\nout = G__37797;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\nzprint.zprint.concatv_BANG_.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\nzprint.zprint.concatv_BANG_.cljs$lang$applyTo = (function (seq37373){\nvar G__37374 = cljs.core.first(seq37373);\nvar seq37373__$1 = cljs.core.next(seq37373);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__37374,seq37373__$1);\n});\n\n/**\n * Do a fzprint-seq like thing, but do it incrementally and\n *   if it gets too big, return nil.\n */\nzprint.zprint.fzprint_one_line = (function zprint$zprint$fzprint_one_line(options,ind,zloc){\nif(cljs.core.truth_((function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872).cljs$core$IFn$_invoke$arity$1(options);\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-one-line:\"], 0));\n} else {\n}\n\nvar seq_right = (zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc));\nvar len = cljs.core.count(seq_right);\nvar last_index = (len - (1));\nvar gt_1_QMARK_ = (cljs.core.count(seq_right) > (1));\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true);\nvar zloc_seq = seq_right;\nvar new_ind = cljs.core.long$(ind);\nvar index = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(zloc_seq)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-one-line: exiting count:\",cljs.core.count(out)], 0));\n} else {\n}\n\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar next_zloc = cljs.core.first(zloc_seq);\nvar vec__37381 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,last_index))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(((!((index === (0)))))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null):null),options__$1], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,(0)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,zprint.zprint.not_rightmost(options__$1)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),zprint.zprint.not_rightmost(options__$1)], null)\n));\nvar sep = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37381,(0),null);\nvar next_options = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37381,(1),null);\nvar next_out = (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(next_options,new_ind,next_zloc) : zprint.zprint.fzprint_STAR_.call(null,next_options,new_ind,next_zloc));\nvar _ = zprint.zprint.log_lines(options__$1,\"fzprint-one-line:\",new_ind,next_out);\nvar vec__37384 = zprint.zprint.style_lines(options__$1,new_ind,next_out);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37384,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37384,(1),null);\nvar next_lines = vec__37384;\nif((!(zprint.zprint.fzfit_one_line(next_options,next_lines)))){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-one-line: failed, too wide or too many lines!\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nvar G__37805 = cljs.core.next(zloc_seq);\nvar G__37806 = (cljs.core.long$(max_width) + (1));\nvar G__37807 = (index + (1));\nvar G__37808 = zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic(out,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([sep,next_out], 0));\nzloc_seq = G__37805;\nnew_ind = G__37806;\nindex = G__37807;\nout = G__37808;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Take a seq of a zloc, created by (zmap identity zloc) when zloc\n *   is a collection, or (zmap-right identity zloc) when zloc is already\n *   inside of a collection, and return a seq of the fzprint* of each \n *   element.  No spacing between any of these elements. Note that this\n *   is not a style-vec, but a seq of style-vecs of each of the elements.\n *   These would need to be concatenated together to become a style-vec.\n *   ind is either a constant or a seq of indents, one for each element in\n *   zloc-seq.\n */\nzprint.zprint.fzprint_seq = (function zprint$zprint$fzprint_seq(p__37389,ind,zloc_seq){\nvar map__37390 = p__37389;\nvar map__37390__$1 = (((((!((map__37390 == null))))?(((((map__37390.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37390.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37390):map__37390);\nvar options = map__37390__$1;\nvar max_length = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37390__$1,new cljs.core.Keyword(null,\"max-length\",\"max-length\",-254826109));\nvar len = cljs.core.count(zloc_seq);\nvar zloc_seq__$1 = (((len > max_length))?cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(max_length,zloc_seq),(new cljs.core.List(null,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)),null,(1),null))):zloc_seq);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-seq: (count zloc-seq):\",len], 0));\n} else {\n}\n\nif(cljs.core.empty_QMARK_(zloc_seq__$1)){\nreturn null;\n} else {\nvar left = zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4(options,((function (len,zloc_seq__$1,map__37390,map__37390__$1,options,max_length){\nreturn (function (p1__37387_SHARP_,p2__37388_SHARP_){\nvar G__37392 = zprint.zprint.not_rightmost(options);\nvar G__37393 = p1__37387_SHARP_;\nvar G__37394 = p2__37388_SHARP_;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37392,G__37393,G__37394) : zprint.zprint.fzprint_STAR_.call(null,G__37392,G__37393,G__37394));\n});})(len,zloc_seq__$1,map__37390,map__37390__$1,options,max_length))\n,((cljs.core.coll_QMARK_(ind))?ind:cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(ind)),cljs.core.butlast(zloc_seq__$1));\nvar right = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__37395 = options;\nvar G__37396 = ((cljs.core.coll_QMARK_(ind))?cljs.core.last(ind):ind);\nvar G__37397 = cljs.core.last(zloc_seq__$1);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37395,G__37396,G__37397) : zprint.zprint.fzprint_STAR_.call(null,G__37395,G__37396,G__37397));\n})()], null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(1))){\nreturn right;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([left,right], 0));\n\n}\n}\n});\n/**\n * Take a seq of a zloc, created by (zmap identity zloc) or\n *   and return a style-vec of the result.  Either it fits on one line, \n *   or it is rendered on multiple lines.  You can force multiple lines \n *   with force-nl?. If you want it to do less than everything in the \n *   original zloc, modify the result of (zmap identity zloc) to just \n *   contain what you want to print. ind is either a single indent,\n *   or a seq of indents, one for each element in zloc-seq.\n */\nzprint.zprint.fzprint_flow_seq = (function zprint$zprint$fzprint_flow_seq(var_args){\nvar G__37400 = arguments.length;\nswitch (G__37400) {\ncase 4:\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 3:\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc_seq,force_nl_QMARK_){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-flow-seq: count zloc-seq:\",cljs.core.count(zloc_seq)], 0));\n} else {\n}\n\nvar coll_print = zprint.zprint.fzprint_seq(options,ind,zloc_seq);\nvar one_line = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),coll_print));\nvar _ = zprint.zprint.log_lines(options,\"fzprint-flow-seq:\",ind,one_line);\nvar one_line_lines = zprint.zprint.style_lines(options,ind,one_line);\nvar value__37009__auto__ = ((((cljs.core.not(force_nl_QMARK_)) && (zprint.zprint.fzfit_one_line(options,one_line_lines))))?one_line:cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,((cljs.core.coll_QMARK_(ind))?cljs.core.drop.cljs$core$IFn$_invoke$arity$2((1),cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (coll_print,one_line,_,one_line_lines){\nreturn (function (p1__37398_SHARP_){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(p1__37398_SHARP_))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)],null));\n});})(coll_print,one_line,_,one_line_lines))\n,ind),coll_print)):cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),coll_print))));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-flow-seq: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n});\n\nzprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3 = (function (options,ind,zloc_seq){\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4(options,ind,zloc_seq,null);\n});\n\nzprint.zprint.fzprint_flow_seq.cljs$lang$maxFixedArity = 4;\n\n/**\n * Try out the given zloc, and if it fits on the current line, just\n *   do that. It might fit on the same line, as this may not be the rest\n *   of the list that we are printing. If not, check it out with good-enough?\n *   and do the best you can.  Three choices, really: fits on same line, \n *   does ok as hanging, or better with flow. hindent is hang-indent, and \n *   findent is flow-indent, and each contains the initial separator.  \n *   Might be nice if the fn-style actually got sent to this fn.\n */\nzprint.zprint.fzprint_hang_one = (function zprint$zprint$fzprint_hang_one(caller,p__37401,hindent,findent,zloc){\nvar map__37402 = p__37401;\nvar map__37402__$1 = (((((!((map__37402 == null))))?(((((map__37402.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37402.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37402):map__37402);\nvar options = map__37402__$1;\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37402__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: hindent:\",hindent,\"findent:\",findent], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options)),\"h1 caller:\",caller,(function (){var G__37404 = (cljs.core.truth_((zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcoll_QMARK_.call(null,zloc)))?(zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc)):zloc);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37404) : zprint.zfns.zstring.call(null,G__37404));\n})()], 0));\n} else {\n}\n\nvar local_options = ((((cljs.core.not(one_line_QMARK_)) && (cljs.core.not(new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)))))))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true):options);\nvar hanging = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent))?(function (){var G__37405 = zprint.zprint.in_hang(local_options);\nvar G__37406 = hindent;\nvar G__37407 = zloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37405,G__37406,G__37407) : zprint.zprint.fzprint_STAR_.call(null,G__37405,G__37406,G__37407));\n})():null);\nvar hang_count = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\nvar hanging__$1 = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),hanging], 0));\nvar _ = zprint.zprint.log_lines(options,\"fzprint-hang-one: hanging:\",(hindent - (1)),hanging__$1);\nvar hr_lines = zprint.zprint.style_lines(options,(hindent - (1)),hanging__$1);\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: hr-lines:\",hr_lines,\"hang-count:\",hang_count], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4131__auto__ = zprint.zprint.fzfit_one_line(options,hr_lines);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn one_line_QMARK_;\n}\n})())){\nreturn hanging__$1;\n} else {\nvar flow = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : zprint.zprint.fzprint_STAR_.call(null,options,findent,zloc))], 0));\nvar ___$1 = zprint.zprint.log_lines(options,\"fzprint-hang-one: flow:\",findent,flow);\nvar fd_lines = zprint.zprint.style_lines(options,findent,flow);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: fd-lines:\",fd_lines], 0)):null);\nvar ___$3 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: ending: hang-count:\",hang_count,\"hanging:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([hanging__$1], 0)),\"flow:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([flow], 0))], 0)):null);\nvar hr_good_QMARK_ = (function (){var and__4120__auto__ = new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.good_enough_QMARK_(caller,options,new cljs.core.Keyword(null,\"none-hang-one\",\"none-hang-one\",-1392848107),hang_count,(hindent - findent),hr_lines,fd_lines);\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(hr_good_QMARK_)){\nreturn hanging__$1;\n} else {\nreturn flow;\n}\n}\n});\n/**\n * Given a seq of zlocs, work backwards from the end, and see how\n *   many elements are pairs of constants (using zconstant?).  So that\n *   (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n *   zconstant? true. This is made more difficult by having to skip\n *   comments along the way as part of the pair check, but keep track\n *   of the ones we skip so the count is right in the end.  We don't\n *   expect any whitespace in this, because this seq should have been\n *   produced by zmap-right or its equivalent, which already skips the\n *   whitespace.\n */\nzprint.zprint.count_constant_pairs = (function zprint$zprint$count_constant_pairs(seq_right){\nvar seq_right_rev = cljs.core.reverse(seq_right);\nvar element_count = (0);\nvar constant_required_QMARK_ = null;\nvar pair_size = (0);\nwhile(true){\nvar element = cljs.core.first(seq_right_rev);\nif(cljs.core.empty_QMARK_(seq_right_rev)){\nreturn (element_count - pair_size);\n} else {\nvar comment_QMARK_ = (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(element) : zprint.zfns.zcomment_QMARK_.call(null,element));\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not(comment_QMARK_);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = constant_required_QMARK_;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn cljs.core.not((zprint.zfns.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1(element) : zprint.zfns.zconstant_QMARK_.call(null,element)));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (element_count - pair_size);\n} else {\nvar G__37827 = cljs.core.next(seq_right_rev);\nvar G__37828 = (element_count + (1));\nvar G__37829 = (cljs.core.truth_(comment_QMARK_)?constant_required_QMARK_:cljs.core.not(constant_required_QMARK_));\nvar G__37830 = (cljs.core.truth_((function (){var and__4120__auto__ = constant_required_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not(comment_QMARK_);\n} else {\nreturn and__4120__auto__;\n}\n})())?(0):(pair_size + (1)));\nseq_right_rev = G__37827;\nelement_count = G__37828;\nconstant_required_QMARK_ = G__37829;\npair_size = G__37830;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Argument is result of (zmap-right identity zloc), that is to say\n *   a seq of zlocs.  Output is a [pair-seq non-paired-item-count],\n *   if any.  If there are no pair-seqs, pair-seq must be nil, not\n *   an empty seq.\n */\nzprint.zprint.constant_pair = (function zprint$zprint$constant_pair(caller,p__37408,seq_right){\nvar map__37409 = p__37408;\nvar map__37409__$1 = (((((!((map__37409 == null))))?(((((map__37409.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37409.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37409):map__37409);\nvar options = map__37409__$1;\nvar map__37410 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37409__$1,caller);\nvar map__37410__$1 = (((((!((map__37410 == null))))?(((((map__37410.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37410.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37410):map__37410);\nvar constant_pair_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37410__$1,new cljs.core.Keyword(null,\"constant-pair?\",\"constant-pair?\",-1009181437));\nvar constant_pair_min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37410__$1,new cljs.core.Keyword(null,\"constant-pair-min\",\"constant-pair-min\",1245759721));\nif(cljs.core.truth_(constant_pair_QMARK_)){\nvar paired_item_count = zprint.zprint.count_constant_pairs(seq_right);\nvar non_paired_item_count = (cljs.core.count(seq_right) - paired_item_count);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"constant-pair: non-paired-items:\",non_paired_item_count], 0)):null);\nvar pair_seq = (((paired_item_count >= constant_pair_min))?cljs.core.second(zprint.zprint.partition_all_2_nc(options,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,seq_right))):null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [pair_seq,non_paired_item_count], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,cljs.core.count(seq_right)], null);\n}\n});\n/**\n * zloc is already down inside a collection, it is not the collection\n *   itself. Operate on what is to the right of zloc.  We already know\n *   that the given zloc won't fit on the current line. [Besides, we\n *   ensure that if there are two things remaining anyway. ???] So\n *   now, try hanging and see if that is better than flow.  Unless\n *   :hang? is nil, in which case we will just flow.  hindent is\n *   hang-indent, and findent is flow-indent. This should never be\n *   called with :one-line because this is only called from fzprint-list*\n *   after the one-line processing is done. If the hindent equals the\n *   flow indent, then just do flow.  Do only zloc-count non-whitespace\n *   elements of zloc.\n */\nzprint.zprint.fzprint_hang_remaining = (function zprint$zprint$fzprint_hang_remaining(var_args){\nvar G__37414 = arguments.length;\nswitch (G__37414) {\ncase 7:\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ncase 6:\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7 = (function (caller,p__37415,hindent,findent,zloc,fn_style,zloc_count){\nvar map__37416 = p__37415;\nvar map__37416__$1 = (((((!((map__37416 == null))))?(((((map__37416.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37416.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37416):map__37416);\nvar options = map__37416__$1;\nvar map__37417 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37416__$1,caller);\nvar map__37417__$1 = (((((!((map__37417 == null))))?(((((map__37417.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37417.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37417):map__37417);\nvar hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854));\nvar constant_pair_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"constant-pair?\",\"constant-pair?\",-1009181437));\nvar constant_pair_min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"constant-pair-min\",\"constant-pair-min\",1245759721));\nvar hang_avoid = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"hang-avoid\",\"hang-avoid\",-138703568));\nvar hang_expand = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"hang-expand\",\"hang-expand\",1086807559));\nvar hang_diff = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"hang-diff\",\"hang-diff\",-1575205424));\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37417__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37416__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37416__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options)),\"hr\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"hindent:\",hindent,\"findent:\",findent,\"caller:\",caller,\"nl-separator?:\",nl_separator_QMARK_], 0));\n} else {\n}\n\nvar seq_right = (zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_right.call(null,cljs.core.identity,zloc));\nvar seq_right__$1 = (cljs.core.truth_(zloc_count)?cljs.core.take.cljs$core$IFn$_invoke$arity$2(zloc_count,seq_right):seq_right);\nvar vec__37420 = zprint.zprint.constant_pair(caller,options,seq_right__$1);\nvar pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37420,(0),null);\nvar non_paired_item_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37420,(1),null);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining count pair-seq:\",cljs.core.count(pair_seq)], 0)):null);\nvar flow = (function (){var flow_result = ((cljs.core.not(pair_seq))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_seq(options,findent,seq_right__$1))):(((!((non_paired_item_count === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3(options,cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.fzprint_STAR_,zprint.zprint.not_rightmost(options),findent),cljs.core.take.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,seq_right__$1)))),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(function (){var G__37429 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37430 = findent;\nvar G__37431 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),options,findent,null,pair_seq);\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37429,G__37430,G__37431) : zprint.zprint.interpose_nl_hf.call(null,G__37429,G__37430,G__37431));\n})()], 0)):(function (){var G__37432 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37433 = findent;\nvar G__37434 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),options,findent,null,pair_seq);\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37432,G__37433,G__37434) : zprint.zprint.interpose_nl_hf.call(null,G__37432,G__37433,G__37434));\n})()));\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [flow_result,zprint.zprint.style_lines(options,findent,flow_result)], null);\n})();\nvar hang_QMARK___$1 = (function (){var and__4120__auto__ = hang_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent)) && (((cljs.core.not(hang_avoid)) || ((cljs.core.count(seq_right__$1) < ((width - hindent) * hang_avoid))))));\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar hanging = (function (){var hang_result = (cljs.core.truth_(hang_QMARK___$1)?((cljs.core.not(pair_seq))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(hindent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_seq(zprint.zprint.in_hang(options),hindent,seq_right__$1))):(((!((non_paired_item_count === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var value__37009__auto__ = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(hindent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3(options,cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.fzprint_STAR_,zprint.zprint.not_rightmost(zprint.zprint.in_hang(options)),hindent),cljs.core.take.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,seq_right__$1))));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: mapv:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n})(),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(hindent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(function (){var value__37009__auto__ = (function (){var G__37435 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37436 = hindent;\nvar G__37437 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),zprint.zprint.in_hang(options),hindent,null,pair_seq);\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37435,G__37436,G__37437) : zprint.zprint.interpose_nl_hf.call(null,G__37435,G__37436,G__37437));\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: fzprint-hang:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__37009__auto__], 0))], 0));\n} else {\n}\n\nreturn value__37009__auto__;\n})()], 0)):(function (){var G__37438 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__37439 = hindent;\nvar G__37440 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),zprint.zprint.in_hang(options),hindent,null,pair_seq);\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__37438,G__37439,G__37440) : zprint.zprint.interpose_nl_hf.call(null,G__37438,G__37439,G__37440));\n})())):null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_result,zprint.zprint.style_lines(options,hindent,hang_result)], null);\n})();\nvar vec__37423 = zprint.zprint.zat(options,flow);\nvar flow__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37423,(0),null);\nvar flow_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37423,(1),null);\nvar vec__37426 = zprint.zprint.zat(options,hanging);\nvar hanging__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37426,(0),null);\nvar hanging_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37426,(1),null);\nvar hang_count = cljs.core.count(seq_right__$1);\nvar ___$1 = zprint.zprint.log_lines(options,\"fzprint-hang-remaining: hanging:\",hindent,hanging__$1);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: hanging-lines:\",hanging_lines,\"hang-count:\",hang_count], 0)):null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: flow-lines:\",flow_lines], 0));\n} else {\n}\n\nif(cljs.core.truth_(dbg_QMARK_)){\nif((hang_count === (0))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"hang-count = 0:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc) : zprint.zfns.zmap_right.call(null,zprint.zfns.zstring,zloc)))], 0));\n} else {\n}\n} else {\n}\n\nzprint.zprint.log_lines(options,\"fzprint-hang-remaining: flow\",findent,flow__$1);\n\nif(cljs.core.truth_(flow_lines)){\nif(cljs.core.truth_(zprint.zprint.good_enough_QMARK_(caller,options,fn_style,hang_count,(hindent - findent),hanging_lines,flow_lines))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),hanging__$1], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),flow__$1], 0));\n}\n} else {\nreturn null;\n}\n});\n\nzprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6 = (function (caller,options,hindent,findent,zloc,fn_style){\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7(caller,options,hindent,findent,zloc,fn_style,null);\n});\n\nzprint.zprint.fzprint_hang_remaining.cljs$lang$maxFixedArity = 7;\n\nzprint.zprint.body_set = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 12, [new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),null,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204),null,new cljs.core.Keyword(null,\"arg1-body\",\"arg1-body\",-1677449564),null,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917),null,new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),null,new cljs.core.Keyword(null,\"noarg1-body\",\"noarg1-body\",774553320),null,new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),null,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072),null,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),null,new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),null,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329),null,new cljs.core.Keyword(null,\"none-body\",\"none-body\",-171554854),null], null), null);\nzprint.zprint.body_map = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arg1-body\",\"arg1-body\",-1677449564),new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"none-body\",\"none-body\",-171554854),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),new cljs.core.Keyword(null,\"noarg1-body\",\"noarg1-body\",774553320),new cljs.core.Keyword(null,\"noarg1\",\"noarg1\",2031519464),new cljs.core.Keyword(null,\"force-nl-body\",\"force-nl-body\",1789087439),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826)], null);\nzprint.zprint.noarg1_set = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"noarg1\",\"noarg1\",2031519464),null,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329),null], null), null);\nzprint.zprint.noarg1_map = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917),new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953)], null);\n/**\n * Set noarg1 in the options if it is the right fn-type.\n */\nzprint.zprint.noarg1 = (function zprint$zprint$noarg1(options,fn_type){\nif(cljs.core.truth_((zprint.zprint.noarg1_set.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.noarg1_set.cljs$core$IFn$_invoke$arity$1(fn_type) : zprint.zprint.noarg1_set.call(null,fn_type)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430),true);\n} else {\nreturn options;\n}\n});\nzprint.zprint.fn_style__GT_caller = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312)], null);\n/**\n * Should we allow this function to print on a single line?\n */\nzprint.zprint.allow_one_line_QMARK_ = (function zprint$zprint$allow_one_line_QMARK_(p__37441,len,fn_style){\nvar map__37442 = p__37441;\nvar map__37442__$1 = (((((!((map__37442 == null))))?(((((map__37442.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37442.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37442):map__37442);\nvar options = map__37442__$1;\nvar fn_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37442__$1,new cljs.core.Keyword(null,\"fn-force-nl\",\"fn-force-nl\",1501458692));\nvar fn_gt2_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37442__$1,new cljs.core.Keyword(null,\"fn-gt2-force-nl\",\"fn-gt2-force-nl\",1348579537));\nvar fn_gt3_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37442__$1,new cljs.core.Keyword(null,\"fn-gt3-force-nl\",\"fn-gt3-force-nl\",-58306985));\nreturn cljs.core.not((function (){var or__4131__auto__ = (fn_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_force_nl.call(null,fn_style));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (function (){var and__4120__auto__ = (len > (3));\nif(and__4120__auto__){\nreturn (fn_gt2_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_gt2_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_gt2_force_nl.call(null,fn_style));\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (function (){var and__4120__auto__ = (len > (4));\nif(and__4120__auto__){\nreturn (fn_gt3_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_gt3_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_gt3_force_nl.call(null,fn_style));\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar temp__5718__auto__ = (zprint.zprint.fn_style__GT_caller.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fn_style__GT_caller.cljs$core$IFn$_invoke$arity$1(fn_style) : zprint.zprint.fn_style__GT_caller.call(null,fn_style));\nif(cljs.core.truth_(temp__5718__auto__)){\nvar future_caller = temp__5718__auto__;\nvar caller_map = (future_caller.cljs$core$IFn$_invoke$arity$1 ? future_caller.cljs$core$IFn$_invoke$arity$1(options) : future_caller.call(null,options));\nvar or__4131__auto____$3 = new cljs.core.Keyword(null,\"flow?\",\"flow?\",96929057).cljs$core$IFn$_invoke$arity$1(caller_map);\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nreturn new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462).cljs$core$IFn$_invoke$arity$1(caller_map);\n}\n} else {\nreturn null;\n}\n}\n}\n}\n})());\n});\n/**\n * Print a list, which might be a list or an anon fn.  \n *   Lots of work to make a list look good, as that is typically code. \n *   Presently all of the callers of this are :list.\n */\nzprint.zprint.fzprint_list_STAR_ = (function zprint$zprint$fzprint_list_STAR_(caller,l_str,r_str,p__37445,ind,zloc){\nvar map__37446 = p__37445;\nvar map__37446__$1 = (((((!((map__37446 == null))))?(((((map__37446.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37446.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37446):map__37446);\nvar options = map__37446__$1;\nvar map__37447 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,caller);\nvar map__37447__$1 = (((((!((map__37447 == null))))?(((((map__37447.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37447.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37447):map__37447);\nvar indent_arg = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37447__$1,new cljs.core.Keyword(null,\"indent-arg\",\"indent-arg\",58691874));\nvar indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37447__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146));\nvar user_fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"user-fn-map\",\"user-fn-map\",-908243227));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar fn_style = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917));\nvar no_arg1_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430));\nvar fn_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37446__$1,new cljs.core.Keyword(null,\"fn-force-nl\",\"fn-force-nl\",1501458692));\nvar len = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\nvar l_str_len = cljs.core.count(l_str);\nvar arg_1_coll_QMARK_ = cljs.core.not((function (){var or__4131__auto__ = (function (){var G__37451 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37451) : zprint.zfns.zkeyword_QMARK_.call(null,G__37451));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar G__37452 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37452) : zprint.zfns.zsymbol_QMARK_.call(null,G__37452));\n}\n})());\nvar fn_str = (((!(arg_1_coll_QMARK_)))?(function (){var G__37453 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37453) : zprint.zfns.zstring.call(null,G__37453));\n})():null);\nvar fn_style__$1 = (function (){var or__4131__auto__ = fn_style;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(fn_str) : fn_map.call(null,fn_str));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (user_fn_map.cljs$core$IFn$_invoke$arity$1 ? user_fn_map.cljs$core$IFn$_invoke$arity$1(fn_str) : user_fn_map.call(null,fn_str));\n}\n}\n})();\nvar fn_style__$2 = (cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not(fn_style__$1);\nif(and__4120__auto__){\nreturn fn_str;\n} else {\nreturn and__4120__auto__;\n}\n})())?(function (){var G__37454 = cljs.core.last(clojure.string.split.cljs$core$IFn$_invoke$arity$2(fn_str,/\\//));\nreturn (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(G__37454) : fn_map.call(null,G__37454));\n})():fn_style__$1);\nvar indent__$1 = (cljs.core.truth_((zprint.zprint.body_set.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.body_set.cljs$core$IFn$_invoke$arity$1(fn_style__$2) : zprint.zprint.body_set.call(null,fn_style__$2)))?indent:(function (){var or__4131__auto__ = indent_arg;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn indent;\n}\n})());\nvar one_line_ok_QMARK_ = zprint.zprint.allow_one_line_QMARK_(options,len,fn_style__$2);\nvar fn_style__$3 = (function (){var or__4131__auto__ = (zprint.zprint.body_map.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.body_map.cljs$core$IFn$_invoke$arity$1(fn_style__$2) : zprint.zprint.body_map.call(null,fn_style__$2));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn fn_style__$2;\n}\n})();\nvar fn_style__$4 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$3,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?fn_style__$3:(((len < (3)))?null:fn_style__$3));\nvar fn_style__$5 = (cljs.core.truth_(no_arg1_QMARK_)?(function (){var or__4131__auto__ = (zprint.zprint.noarg1_map.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.noarg1_map.cljs$core$IFn$_invoke$arity$1(fn_style__$4) : zprint.zprint.noarg1_map.call(null,fn_style__$4));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn fn_style__$4;\n}\n})():fn_style__$4);\nvar options__$1 = (cljs.core.truth_(no_arg1_QMARK_)?cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430)):options);\nvar indent_adj = (l_str_len - (1));\nvar default_indent = (cljs.core.truth_((function (){var G__37455 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37455) : zprint.zfns.zlist_QMARK_.call(null,G__37455));\n})())?indent__$1:l_str_len);\nvar arg_1_indent = ((cljs.core.not((function (){var or__4131__auto__ = arg_1_coll_QMARK_;\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar G__37457 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37457) : zprint.zfns.zcomment_QMARK_.call(null,G__37457));\n}\n})()))?((ind + (l_str_len + (1))) + cljs.core.count(fn_str)):null);\nvar options__$2 = (((!(arg_1_coll_QMARK_)))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464),fn_str):options__$1);\nvar options__$3 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$2,new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342),(cljs.core.long$((function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options__$2);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})()) + (1)));\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options__$3))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options__$3)),\"fzs\",fn_str], 0)):null);\nvar new_ind = (indent__$1 + ind);\nvar one_line_ind = (l_str_len + ind);\nvar options__$4 = (cljs.core.truth_(fn_style__$5)?cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options__$3,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917)):options__$3);\nvar loptions = zprint.zprint.not_rightmost(options__$4);\nvar roptions = options__$4;\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options__$4,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$4,(indent__$1 + ind),zloc,r_str);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint-list*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"fn-str\",fn_str,\"fn-style:\",fn_style__$5,\"ind:\",ind,\"indent:\",indent__$1,\"default-indent:\",default_indent,\"one-line-ok?\",one_line_ok_QMARK_,\"arg-1-coll?\",arg_1_coll_QMARK_,\"arg-1-indent:\",arg_1_indent,\"l-str:\",[\"'\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(l_str),\"'\"].join(''),\"indent-adj:\",indent_adj,\"len:\",len,\"one-line?:\",one_line_QMARK_,\"rightcnt:\",new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$1(options__$4)], 0)):null);\nvar one_line = (((len === (0)))?new cljs.core.Keyword(null,\"empty\",\"empty\",767870958):((one_line_ok_QMARK_)?zprint.zprint.fzprint_one_line(options__$4,one_line_ind,zloc):null));\nif(cljs.core.truth_(one_line)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(one_line,new cljs.core.Keyword(null,\"empty\",\"empty\",767870958))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line,r_str_vec], 0));\n}\n} else {\nif(cljs.core.truth_(one_line_QMARK_)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))){\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint-list*:\",fn_str,\" one-line did not work!!!\"], 0));\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.truth_((cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint-list*: fn-style:\",fn_style__$5], 0)):null))){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(0))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(1))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37458 = roptions;\nvar G__37459 = one_line_ind;\nvar G__37460 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37458,G__37459,G__37460) : zprint.zprint.fzprint_STAR_.call(null,G__37458,G__37459,G__37460));\n})(),r_str_vec], 0));\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593));\nif(and__4120__auto__){\nvar G__37462 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37462) : zprint.zfns.zvector_QMARK_.call(null,G__37462));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar vec__37463 = zprint.zprint.fzprint_hang_unless_fail(loptions,arg_1_indent,(indent__$1 + ind),zprint.zprint.fzprint_binding_vec,(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc)));\nvar hang_or_flow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37463,(0),null);\nvar binding_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37463,(1),null);\nvar binding_style_vec__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hang_or_flow,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),binding_style_vec], 0)):binding_style_vec);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37466 = loptions;\nvar G__37467 = (ind + (1));\nvar G__37468 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37466,G__37467,G__37468) : zprint.zprint.fzprint_STAR_.call(null,G__37466,G__37467,G__37468));\n})(),binding_style_vec__$1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4(options__$4,(indent__$1 + ind),cljs.core.nthnext((zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc)),(2)),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826)),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37469 = loptions;\nvar G__37470 = (ind + (1));\nvar G__37471 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37469,G__37470,G__37471) : zprint.zprint.fzprint_STAR_.call(null,G__37469,G__37470,G__37471));\n})(),zprint.zprint.fzprint_hang(options__$4,new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),arg_1_indent,(indent__$1 + ind),zprint.zprint.fzprint_pairs,cljs.core.count((function (){var G__37472 = cljs.core.identity;\nvar G__37473 = (zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(0)) : zprint.zfns.znthnext.call(null,zloc,(0)));\nreturn (zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_right.cljs$core$IFn$_invoke$arity$2(G__37472,G__37473) : zprint.zfns.zmap_right.call(null,G__37472,G__37473));\n})()),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(0)) : zprint.zfns.znthnext.call(null,zloc,(0)))),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37474 = loptions;\nvar G__37475 = (ind + (1));\nvar G__37476 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37474,G__37475,G__37476) : zprint.zprint.fzprint_STAR_.call(null,G__37474,G__37475,G__37476));\n})(),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_extend(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(0)) : zprint.zfns.znthnext.call(null,zloc,(0)))),r_str_vec], 0));\n} else {\nif(((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204))) && (cljs.core.not((function (){var G__37480 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37480) : zprint.zfns.zlist_QMARK_.call(null,G__37480));\n})())))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186))))){\nvar second_element = zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(2)))?options__$4:loptions),arg_1_indent,(indent__$1 + ind),(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc)));\nvar vec__37481 = zprint.zprint.style_lines(loptions,arg_1_indent,second_element);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37481,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37481,(1),null);\nvar third = (zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zthird.call(null,zloc));\nvar first_three = (cljs.core.truth_(second_element)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var G__37484 = loptions;\nvar G__37485 = (indent__$1 + ind);\nvar G__37486 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37484,G__37485,G__37486) : zprint.zprint.fzprint_STAR_.call(null,G__37484,G__37485,G__37486));\n})(),second_element,(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072));\nif(or__4131__auto____$2){\nreturn or__4131__auto____$2;\n} else {\nvar and__4120__auto__ = (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(third) : zprint.zfns.zvector_QMARK_.call(null,third));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(line_count,(1));\n} else {\nreturn and__4120__auto__;\n}\n}\n}\n}\n})())?zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(3)))?options__$4:loptions),max_width,(indent__$1 + ind),third):zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(function (){var G__37487 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(3)))?options__$4:loptions);\nvar G__37488 = (indent__$1 + ind);\nvar G__37489 = third;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37487,G__37488,G__37489) : zprint.zprint.fzprint_STAR_.call(null,G__37487,G__37488,G__37489));\n})()], 0)))], 0)):null);\nif(cljs.core.truth_(first_three)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(3))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,first_three,r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,first_three,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_pairs(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(2)) : zprint.zfns.znthnext.call(null,zloc,(2))))], 0)):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_extend(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(2)) : zprint.zfns.znthnext.call(null,zloc,(2))))], 0)):zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072)))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$4,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)):options__$4),(indent__$1 + ind),(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(2)) : zprint.zfns.znthnext.call(null,zloc,(2))),fn_style__$5)\n)),r_str_vec], 0));\n}\n} else {\nreturn null;\n}\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1-mixin\",\"arg1-mixin\",1553512120))) && ((len > (3))))){\nvar arg_vec_index = (function (){var or__4131__auto__ = (function (){var G__37493 = ((function (len,l_str_len,arg_1_coll_QMARK_,fn_str,fn_style__$1,fn_style__$2,indent__$1,one_line_ok_QMARK_,fn_style__$3,fn_style__$4,fn_style__$5,options__$1,indent_adj,default_indent,arg_1_indent,options__$2,options__$3,_,new_ind,one_line_ind,options__$4,loptions,roptions,l_str_vec,r_str_vec,___$1,one_line,map__37446,map__37446__$1,options,map__37447,map__37447__$1,indent_arg,indent,fn_map,user_fn_map,one_line_QMARK_,fn_style,no_arg1_QMARK_,fn_force_nl){\nreturn (function (p1__37444_SHARP_){\nvar or__4131__auto__ = (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37444_SHARP_) : zprint.zfns.zvector_QMARK_.call(null,p1__37444_SHARP_));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nif(cljs.core.truth_((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__37444_SHARP_) : zprint.zfns.zlist_QMARK_.call(null,p1__37444_SHARP_)))){\nvar G__37495 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(p1__37444_SHARP_) : zprint.zfns.zfirst.call(null,p1__37444_SHARP_));\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37495) : zprint.zfns.zvector_QMARK_.call(null,G__37495));\n} else {\nreturn null;\n}\n}\n});})(len,l_str_len,arg_1_coll_QMARK_,fn_str,fn_style__$1,fn_style__$2,indent__$1,one_line_ok_QMARK_,fn_style__$3,fn_style__$4,fn_style__$5,options__$1,indent_adj,default_indent,arg_1_indent,options__$2,options__$3,_,new_ind,one_line_ind,options__$4,loptions,roptions,l_str_vec,r_str_vec,___$1,one_line,map__37446,map__37446__$1,options,map__37447,map__37447__$1,indent_arg,indent,fn_map,user_fn_map,one_line_QMARK_,fn_style,no_arg1_QMARK_,fn_force_nl))\n;\nvar G__37494 = zloc;\nreturn (zprint.zfns.zfind.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zfind.cljs$core$IFn$_invoke$arity$2(G__37493,G__37494) : zprint.zfns.zfind.call(null,G__37493,G__37494));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})();\nvar doc_string_QMARK_ = typeof (function (){var G__37496 = (zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zthird.call(null,zloc));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__37496) : zprint.zfns.zsexpr.call(null,G__37496));\n})() === 'string';\nvar mixin_start = ((doc_string_QMARK_)?(4):(3));\nvar mixin_length = (arg_vec_index - mixin_start);\nvar mixins_QMARK_ = (mixin_length > (0));\nvar doc_string = ((doc_string_QMARK_)?zprint.zprint.fzprint_hang_one(caller,loptions,(indent__$1 + ind),(indent__$1 + ind),(zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zthird.call(null,zloc))):null);\nvar mixins = ((mixins_QMARK_)?(function (){var mixin_sentinal = zprint.zprint.fzprint_hang_one(caller,loptions,(indent__$1 + ind),(indent__$1 + ind),((doc_string_QMARK_)?(zprint.zfns.zfourth.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfourth.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfourth.call(null,zloc)):(zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zthird.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zthird.call(null,zloc))));\nvar vec__37497 = zprint.zprint.style_lines(loptions,(indent__$1 + ind),mixin_sentinal);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37497,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37497,(1),null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([mixin_sentinal,zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7(caller,loptions,(max_width + (1)),(((indent__$1 + indent__$1) + ind) - (1)),(function (){var G__37500 = zloc;\nvar G__37501 = ((doc_string_QMARK_)?(3):(2));\nreturn (zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(G__37500,G__37501) : zprint.zfns.znthnext.call(null,G__37500,G__37501));\n})(),fn_style__$5,mixin_length)], 0));\n})():null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37502 = loptions;\nvar G__37503 = (ind + (1));\nvar G__37504 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37502,G__37503,G__37504) : zprint.zprint.fzprint_STAR_.call(null,G__37502,G__37503,G__37504));\n})(),zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(2)))?options__$4:loptions),arg_1_indent,(indent__$1 + ind),(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc))),((((doc_string_QMARK_) && (mixins_QMARK_)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([doc_string,mixins], 0)):((doc_string_QMARK_)?doc_string:((mixins_QMARK_)?mixins:new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null)\n))),zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$4,fn_style__$5),(indent__$1 + ind),(indent__$1 + ind),(function (){var G__37505 = zloc;\nvar G__37506 = ((mixins_QMARK_)?(arg_vec_index - (1)):((doc_string_QMARK_)?(2):(1)));\nreturn (zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(G__37505,G__37506) : zprint.zfns.znthnext.call(null,G__37505,G__37506));\n})(),fn_style__$5),r_str_vec], 0));\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1-force-nl\",\"arg1-force-nl\",-945624718))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329))))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37507 = loptions;\nvar G__37508 = (ind + (1));\nvar G__37509 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37507,G__37508,G__37509) : zprint.zprint.fzprint_STAR_.call(null,G__37507,G__37508,G__37509));\n})(),zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(2)))?options__$4:loptions),arg_1_indent,(indent__$1 + ind),(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc))),(((len > (2)))?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_pairs(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(1)) : zprint.zfns.znthnext.call(null,zloc,(1))))], 0)):zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$4,fn_style__$5),(indent__$1 + ind),(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(1)) : zprint.zfns.znthnext.call(null,zloc,(1))),fn_style__$5)):null),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050))){\nif(cljs.core.truth_((function (){var G__37510 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37510) : zprint.zfns.zvector_QMARK_.call(null,G__37510));\n})())){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37511 = loptions;\nvar G__37512 = (ind + (1));\nvar G__37513 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37511,G__37512,G__37513) : zprint.zprint.fzprint_STAR_.call(null,G__37511,G__37512,G__37513));\n})(),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),(function (){var G__37514 = loptions;\nvar G__37515 = (ind + (1));\nvar G__37516 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37514,G__37515,G__37516) : zprint.zprint.fzprint_STAR_.call(null,G__37514,G__37515,G__37516));\n})(),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_extend(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(1)) : zprint.zfns.znthnext.call(null,zloc,(1)))),r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37517 = loptions;\nvar G__37518 = (ind + (1));\nvar G__37519 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37517,G__37518,G__37519) : zprint.zprint.fzprint_STAR_.call(null,G__37517,G__37518,G__37519));\n})(),zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(2)))?options__$4:loptions),arg_1_indent,(indent__$1 + ind),(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc))),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((indent__$1 + ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_extend(options__$4,(indent__$1 + ind),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(1)) : zprint.zfns.znthnext.call(null,zloc,(1)))),r_str_vec], 0));\n\n}\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37520 = loptions;\nvar G__37521 = (l_str_len + ind);\nvar G__37522 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37520,G__37521,G__37522) : zprint.zprint.fzprint_STAR_.call(null,G__37520,G__37521,G__37522));\n})(),(cljs.core.truth_((function (){var and__4120__auto__ = arg_1_indent;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032));\n} else {\nreturn and__4120__auto__;\n}\n})())?zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$4,fn_style__$5),arg_1_indent,((indent__$1 + ind) + indent_adj),(zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.znthnext.cljs$core$IFn$_invoke$arity$2(zloc,(0)) : zprint.zfns.znthnext.call(null,zloc,(0))),fn_style__$5):(function (){var local_indent = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032)))?(indent__$1 + ind):((default_indent + ind) + indent_adj));\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(local_indent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4(zprint.zprint.noarg1(options__$4,fn_style__$5),local_indent,cljs.core.nthnext((zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc)),(1)),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826))], 0));\n})()),r_str_vec], 0));\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n/**\n * Pretty print and focus style a :list element.\n */\nzprint.zprint.fzprint_list = (function zprint$zprint$fzprint_list(options,ind,zloc){\nreturn zprint.zprint.fzprint_list_STAR_(new cljs.core.Keyword(null,\"list\",\"list\",765357683),\"(\",\")\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Pretty print and focus style a fn element.\n */\nzprint.zprint.fzprint_anon_fn = (function zprint$zprint$fzprint_anon_fn(options,ind,zloc){\nreturn zprint.zprint.fzprint_list_STAR_(new cljs.core.Keyword(null,\"list\",\"list\",765357683),\"#(\",\")\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Return true if there are any collections in the collection.\n */\nzprint.zprint.any_zcoll_QMARK_ = (function zprint$zprint$any_zcoll_QMARK_(options,ind,zloc){\nvar coll_QMARK__seq = (zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zcoll_QMARK_,zloc) : zprint.zfns.zmap.call(null,zprint.zfns.zcoll_QMARK_,zloc));\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (coll_QMARK__seq){\nreturn (function (p1__37523_SHARP_,p2__37524_SHARP_){\nvar or__4131__auto__ = p1__37523_SHARP_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn p2__37524_SHARP_;\n}\n});})(coll_QMARK__seq))\n,null,coll_QMARK__seq);\n});\n/**\n * Given the output from fzprint-seq, which is a style-vec in\n *   the making without spacing, but with extra [] around the elements,\n *   wrap the elements to the right margin.\n */\nzprint.zprint.wrap_zmap = (function zprint$zprint$wrap_zmap(caller,p__37525,ind,coll_print){\nvar map__37526 = p__37525;\nvar map__37526__$1 = (((((!((map__37526 == null))))?(((((map__37526.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37526.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37526):map__37526);\nvar options = map__37526__$1;\nvar map__37527 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37526__$1,caller);\nvar map__37527__$1 = (((((!((map__37527 == null))))?(((((map__37527.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37527.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37527):map__37527);\nvar wrap_after_multi_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37527__$1,new cljs.core.Keyword(null,\"wrap-after-multi?\",\"wrap-after-multi?\",1010808052));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37526__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37526__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar max_length = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37526__$1,new cljs.core.Keyword(null,\"max-length\",\"max-length\",-254826109));\nvar last_index = (cljs.core.count(coll_print) - (1));\nvar rightcnt__$1 = zprint.zprint.fix_rightcnt(rightcnt);\nvar cur_seq = coll_print;\nvar cur_ind = ind;\nvar index = (0);\nvar previous_newline_QMARK_ = false;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cur_seq)){\nreturn out;\n} else {\nvar next_seq = cljs.core.first(cur_seq);\nif(cljs.core.truth_(next_seq)){\nvar multi_QMARK_ = (cljs.core.count(cljs.core.first(cur_seq)) > (1));\nvar this_seq = cljs.core.first(cur_seq);\nvar _ = zprint.zprint.log_lines(options,\"wrap-zmap:\",ind,this_seq);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"wrap-zmap: ind:\",ind,\"this-seq:\",this_seq], 0)):null);\nvar vec__37533 = zprint.zprint.style_lines(options,ind,this_seq);\nvar linecnt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37533,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37533,(1),null);\nvar lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37533,(2),null);\nvar last_width = cljs.core.last(lines);\nvar len = (last_width - ind);\nvar len__$1 = (function (){var x__4219__auto__ = (0);\nvar y__4220__auto__ = len;\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})();\nvar newline_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar width__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,last_index))?(width - rightcnt__$1):width);\nvar fit_QMARK_ = (function (){var and__4120__auto__ = (!(newline_QMARK_));\nif(and__4120__auto__){\nvar or__4131__auto__ = (index === (0));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar and__4120__auto____$1 = ((multi_QMARK_)?cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(linecnt,(1)):true);\nif(and__4120__auto____$1){\nreturn ((cur_ind + len__$1) <= width__$1);\n} else {\nreturn and__4120__auto____$1;\n}\n}\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar new_ind = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))?(width__$1 + (1)):((((multi_QMARK_) && ((linecnt > (1))) && (cljs.core.not(wrap_after_multi_QMARK_))))?width__$1:((fit_QMARK_)?((cur_ind + len__$1) + (1)):((newline_QMARK_)?ind:((ind + len__$1) + (1))\n))));\nvar G__37958 = cljs.core.next(cur_seq);\nvar G__37959 = new_ind;\nvar G__37960 = (index + (1));\nvar G__37961 = newline_QMARK_;\nvar G__37962 = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(out,((fit_QMARK_)?(((!((index === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),this_seq], 0)):this_seq):((newline_QMARK_)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((new_ind - (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null):((previous_newline_QMARK_)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),this_seq], 0)):zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),this_seq], 0))))));\ncur_seq = G__37958;\ncur_ind = G__37959;\nindex = G__37960;\nprevious_newline_QMARK_ = G__37961;\nout = G__37962;\ncontinue;\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n/**\n * Remove any [_ _ :newline] from the seq.\n */\nzprint.zprint.remove_nl = (function zprint$zprint$remove_nl(coll){\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$2((function (p1__37536_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__37536_SHARP_),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\n}),coll);\n});\n/**\n * Validate an options map that was returned from some internal configuration\n *   expression or configuration.  Either returns the options map or throws\n *   an error.\n */\nzprint.zprint.internal_validate = (function zprint$zprint$internal_validate(options,error_str){\nvar errors = zprint.config.validate_options.cljs$core$IFn$_invoke$arity$1(options);\nvar errors__$1 = (cljs.core.truth_(errors)?[\"Options resulting from \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_str),\" had these errors: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(errors)].join(''):null);\nif((!(cljs.core.empty_QMARK_(errors__$1)))){\nthrow (new Error(errors__$1));\n} else {\nreturn options;\n}\n});\n/**\n * Print basic stuff like a vector or a set.  Several options for how to\n *   print them.\n */\nzprint.zprint.fzprint_vec_STAR_ = (function zprint$zprint$fzprint_vec_STAR_(caller,l_str,r_str,p__37537,ind,zloc){\nvar map__37538 = p__37537;\nvar map__37538__$1 = (((((!((map__37538 == null))))?(((((map__37538.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37538.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37538):map__37538);\nvar options = map__37538__$1;\nvar map__37539 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37538__$1,caller);\nvar map__37539__$1 = (((((!((map__37539 == null))))?(((((map__37539.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37539.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37539):map__37539);\nvar wrap_coll_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"wrap-coll?\",\"wrap-coll?\",908181571));\nvar wrap_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"wrap?\",\"wrap?\",-1677427054));\nvar binding_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"binding?\",\"binding?\",-1071925644));\nvar option_fn_first = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"option-fn-first\",\"option-fn-first\",-1679196201));\nvar respect_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nvar sort_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37539__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37538__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37538__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core.truth_((function (){var and__4120__auto__ = binding_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options),(1));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_binding_vec(options,ind,zloc);\n} else {\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar new_options = (cljs.core.truth_(option_fn_first)?(function (){var first_sexpr = (function (){var G__37544 = (zprint.zfns.zfirst_no_comment.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst_no_comment.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst_no_comment.call(null,zloc));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__37544) : zprint.zfns.zsexpr.call(null,G__37544));\n})();\nreturn zprint.zprint.internal_validate((option_fn_first.cljs$core$IFn$_invoke$arity$2 ? option_fn_first.cljs$core$IFn$_invoke$arity$2(options,first_sexpr) : option_fn_first.call(null,options,first_sexpr)),[\":vector :option-fn-first called with \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(first_sexpr)].join(''));\n})():null);\nvar map__37542 = zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options,new_options], 0));\nvar map__37542__$1 = (((((!((map__37542 == null))))?(((((map__37542.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37542.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37542):map__37542);\nvar options__$1 = map__37542__$1;\nvar map__37543 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37542__$1,caller);\nvar map__37543__$1 = (((((!((map__37543 == null))))?(((((map__37543.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37543.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37543):map__37543);\nvar wrap_coll_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"wrap-coll?\",\"wrap-coll?\",908181571));\nvar wrap_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"wrap?\",\"wrap?\",-1677427054));\nvar binding_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"binding?\",\"binding?\",-1071925644));\nvar option_fn_first__$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"option-fn-first\",\"option-fn-first\",-1679196201));\nvar respect_nl_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nvar sort_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37543__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar respect_nl_QMARK___$2 = (function (){var and__4120__auto__ = respect_nl_QMARK___$1;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.not(sort_QMARK___$1);\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar new_ind = (cljs.core.count(l_str) + ind);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"new-ind:\",new_ind], 0))], 0)):null);\nvar zloc_seq = (cljs.core.truth_(respect_nl_QMARK___$2)?(zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl.call(null,cljs.core.identity,zloc)):(zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc)));\nvar zloc_seq__$1 = (cljs.core.truth_((function (){var and__4120__auto__ = sort_QMARK___$1;\nif(cljs.core.truth_(and__4120__auto__)){\nif(cljs.core.truth_(in_code_QMARK_)){\nreturn sort_in_code_QMARK___$1;\n} else {\nreturn true;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())?zprint.zprint.order_out(caller,options__$1,cljs.core.identity,zloc_seq):zloc_seq);\nvar coll_print = ((((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) === (0)))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null)], null):zprint.zprint.fzprint_seq(options__$1,new_ind,zloc_seq__$1));\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*: coll-print:\",coll_print], 0))], 0)):null);\nvar coll_print__$1 = ((cljs.core.not(zprint.zprint.contains_nil_QMARK_(coll_print)))?coll_print:null);\nvar one_line = (cljs.core.truth_(coll_print__$1)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),(cljs.core.truth_(respect_nl_QMARK___$2)?coll_print__$1:zprint.zprint.remove_nl(coll_print__$1)))):null);\nvar ___$2 = zprint.zprint.log_lines(options__$1,\"fzprint-vec*:\",new_ind,one_line);\nvar one_line_lines = zprint.zprint.style_lines(options__$1,new_ind,one_line);\nif(cljs.core.truth_(one_line_lines)){\nif(zprint.zprint.fzfit_one_line(options__$1,one_line_lines)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line,r_str_vec], 0));\n} else {\nif(cljs.core.truth_((function (){var or__4131__auto__ = (function (){var and__4120__auto__ = cljs.core.not(wrap_coll_QMARK___$1);\nif(and__4120__auto__){\nreturn zprint.zprint.any_zcoll_QMARK_(options__$1,new_ind,zloc);\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.not(wrap_QMARK___$1);\n}\n})())){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(new_ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),zprint.zprint.remove_nl(coll_print__$1))),r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-vec*: wrap coll-print:\",coll_print__$1], 0));\n} else {\n}\n\nreturn zprint.zprint.wrap_zmap(caller,options__$1,new_ind,coll_print__$1);\n})()\n,r_str_vec], 0));\n}\n}\n} else {\nreturn null;\n}\n}\n});\nzprint.zprint.fzprint_vec = (function zprint$zprint$fzprint_vec(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158),\"[\",\"]\",zprint.zprint.rightmost(options),ind,zloc);\n});\nzprint.zprint.fzprint_array = (function zprint$zprint$fzprint_array(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"array\",\"array\",-2080713842),\"[\",\"]\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Pretty print and focus style a :set element.\n */\nzprint.zprint.fzprint_set = (function zprint$zprint$fzprint_set(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"set\",\"set\",304602554),\"#{\",\"}\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Do the same as interpose, but different seps depending on pred?.\n */\nzprint.zprint.interpose_either = (function zprint$zprint$interpose_either(sep_true,sep_nil,pred_QMARK_,coll){\nvar coll__$1 = coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar interpose_QMARK_ = null;\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar G__37971 = cljs.core.next(coll__$1);\nvar G__37972 = (cljs.core.truth_(interpose_QMARK_)?zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,sep_true,cljs.core.first(coll__$1)], 0)):(((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(coll__$1)):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,sep_nil,cljs.core.first(coll__$1)], 0))));\nvar G__37973 = (function (){var G__37548 = cljs.core.first(coll__$1);\nreturn (pred_QMARK_.cljs$core$IFn$_invoke$arity$1 ? pred_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37548) : pred_QMARK_.call(null,G__37548));\n})();\ncoll__$1 = G__37971;\nout = G__37972;\ninterpose_QMARK_ = G__37973;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Do the same as interpose, but different seps depending on pred-fn\n *   return and nl-separator?.\n */\nzprint.zprint.interpose_either_nl_hf = (function zprint$zprint$interpose_either_nl_hf(sep_true,sep_true_nl,sep_nil,sep_nil_nl,p__37549,pred_fn,coll){\nvar map__37550 = p__37549;\nvar map__37550__$1 = (((((!((map__37550 == null))))?(((((map__37550.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37550.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37550):map__37550);\nvar suboptions = map__37550__$1;\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37550__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar nl_separator_flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37550__$1,new cljs.core.Keyword(null,\"nl-separator-flow?\",\"nl-separator-flow?\",495760215));\nvar coll__$1 = coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar interpose_QMARK_ = null;\nvar add_nl_QMARK_ = null;\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.persistent_BANG_(out));\n} else {\nvar vec__37555 = cljs.core.first(coll__$1);\nvar hangflow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37555,(0),null);\nvar style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37555,(1),null);\nvar G__37974 = cljs.core.next(coll__$1);\nvar G__37975 = (cljs.core.truth_(interpose_QMARK_)?zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,(cljs.core.truth_(add_nl_QMARK_)?sep_true_nl:sep_true),style_vec], 0)):(((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,style_vec):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,(cljs.core.truth_(add_nl_QMARK_)?sep_nil_nl:sep_nil),style_vec], 0))));\nvar G__37976 = (cljs.core.truth_(pred_fn)?(pred_fn.cljs$core$IFn$_invoke$arity$1 ? pred_fn.cljs$core$IFn$_invoke$arity$1(style_vec) : pred_fn.call(null,style_vec)):null);\nvar G__37977 = (function (){var and__4120__auto__ = nl_separator_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hangflow,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032));\n} else {\nreturn and__4120__auto__;\n}\n})();\ncoll__$1 = G__37974;\nout = G__37975;\ninterpose_QMARK_ = G__37976;\nadd_nl_QMARK_ = G__37977;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Put a single or double line between pairs returned from fzprint-map-two-up.\n *   The first argument is the map resulting from (:map options) or (:pair options)\n *   or whatever.  It should have :nl-separator? and :nl-separator-flow? in it.\n */\nzprint.zprint.interpose_nl_hf = (function zprint$zprint$interpose_nl_hf(suboptions,ind,coll){\nreturn zprint.zprint.interpose_either_nl_hf(null,null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),suboptions,null,coll);\n});\nzprint.zprint.fzprint_map_STAR_ = (function zprint$zprint$fzprint_map_STAR_(caller,l_str,r_str,p__37559,ind,zloc){\nvar map__37560 = p__37559;\nvar map__37560__$1 = (((((!((map__37560 == null))))?(((((map__37560.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37560.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37560):map__37560);\nvar options = map__37560__$1;\nvar map__37561 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37560__$1,caller);\nvar map__37561__$1 = (((((!((map__37561 == null))))?(((((map__37561.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37561.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37561):map__37561);\nvar comma_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"comma?\",\"comma?\",1532168963));\nvar key_ignore = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"key-ignore\",\"key-ignore\",75506668));\nvar key_ignore_silent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"key-ignore-silent\",\"key-ignore-silent\",-1720115060));\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar force_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462));\nvar lift_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"lift-ns?\",\"lift-ns?\",2021372853));\nvar lift_ns_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37561__$1,new cljs.core.Keyword(null,\"lift-ns-in-code?\",\"lift-ns-in-code?\",1444279377));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37560__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar ztype = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37560__$1,new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020));\nvar map_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37560__$1,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37560__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641),(map_depth + (1)));\nvar zloc__$1 = (cljs.core.truth_((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ztype,new cljs.core.Keyword(null,\"sexpr\",\"sexpr\",-783344087));\nif(and__4120__auto__){\nvar or__4131__auto__ = key_ignore;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn key_ignore_silent;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())?zprint.zprint.map_ignore(caller,options__$1,zloc):zloc);\nvar vec__37564 = zprint.zprint.partition_all_2_nc(options__$1,(zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zseqnws.call(null,zloc__$1)));\nvar no_sort_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37564,(0),null);\nvar pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37564,(1),null);\nvar vec__37567 = (cljs.core.truth_((function (){var and__4120__auto__ = lift_ns_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nif(cljs.core.truth_(in_code_QMARK_)){\nreturn lift_ns_in_code_QMARK_;\n} else {\nreturn true;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())?(zprint.zfns.zlift_ns.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlift_ns.cljs$core$IFn$_invoke$arity$1(pair_seq) : zprint.zfns.zlift_ns.call(null,pair_seq)):null);\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37567,(0),null);\nvar lift_pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37567,(1),null);\nvar l_str__$1 = (cljs.core.truth_(ns)?[\"#:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns),cljs.core.str.cljs$core$IFn$_invoke$arity$1(l_str)].join(''):l_str);\nvar pair_seq__$1 = (function (){var or__4131__auto__ = lift_pair_seq;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn pair_seq;\n}\n})();\nvar pair_seq__$2 = (cljs.core.truth_(no_sort_QMARK_)?pair_seq__$1:zprint.zprint.order_out(caller,options__$1,cljs.core.first,pair_seq__$1));\nvar indent = cljs.core.count(l_str__$1);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str__$1,zprint.zprint.zcolor_map(options__$1,l_str__$1),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$1,(indent + ind),zloc__$1,r_str);\nif(cljs.core.empty_QMARK_(pair_seq__$2)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-map*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zstring.call(null,zloc__$1)),\"ind:\",ind,\"comma?\",comma_QMARK_,\"rightcnt:\",new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$1(options__$1)], 0)):null);\nvar pair_print_one_line = zprint.zprint.fzprint_map_two_up(caller,(cljs.core.truth_(one_line_QMARK_)?options__$1:cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true)),(indent + ind),comma_QMARK_,pair_seq__$2);\nvar pair_print_one_line__$1 = zprint.zprint.remove_hangflow(pair_print_one_line);\nvar pair_print_one_line__$2 = ((zprint.zprint.fzfit_one_line(options__$1,zprint.zprint.style_lines(options__$1,(indent + ind),pair_print_one_line__$1)))?pair_print_one_line__$1:null);\nvar one_line = (cljs.core.truth_(pair_print_one_line__$2)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,zprint.zprint.interpose_either(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\", \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null),cljs.core.constantly(comma_QMARK_),pair_print_one_line__$2)):null);\nvar one_line_lines = zprint.zprint.style_lines(options__$1,(indent + ind),one_line);\nvar one_line__$1 = ((zprint.zprint.fzfit_one_line(options__$1,one_line_lines))?one_line:null);\nif(cljs.core.truth_(one_line__$1)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line__$1,r_str_vec], 0));\n} else {\nif(cljs.core.not(one_line_QMARK_)){\nvar pair_print = zprint.zprint.fzprint_map_two_up(caller,options__$1,(indent + ind),comma_QMARK_,pair_seq__$2);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.interpose_either_nl_hf(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null),new cljs.core.Keyword(null,\"map\",\"map\",1371690461).cljs$core$IFn$_invoke$arity$1(options__$1),((function (pair_print,_,pair_print_one_line,pair_print_one_line__$1,pair_print_one_line__$2,one_line,one_line_lines,one_line__$1,options__$1,zloc__$1,vec__37564,no_sort_QMARK_,pair_seq,vec__37567,ns,lift_pair_seq,l_str__$1,pair_seq__$1,pair_seq__$2,indent,l_str_vec,r_str_vec,map__37560,map__37560__$1,options,map__37561,map__37561__$1,comma_QMARK_,key_ignore,key_ignore_silent,nl_separator_QMARK_,force_nl_QMARK_,lift_ns_QMARK_,lift_ns_in_code_QMARK_,one_line_QMARK_,ztype,map_depth,in_code_QMARK_){\nreturn (function (p1__37558_SHARP_){\nvar and__4120__auto__ = comma_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__37558_SHARP_),(2)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) && (cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__37558_SHARP_),(2)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\n} else {\nreturn and__4120__auto__;\n}\n});})(pair_print,_,pair_print_one_line,pair_print_one_line__$1,pair_print_one_line__$2,one_line,one_line_lines,one_line__$1,options__$1,zloc__$1,vec__37564,no_sort_QMARK_,pair_seq,vec__37567,ns,lift_pair_seq,l_str__$1,pair_seq__$1,pair_seq__$2,indent,l_str_vec,r_str_vec,map__37560,map__37560__$1,options,map__37561,map__37561__$1,comma_QMARK_,key_ignore,key_ignore_silent,nl_separator_QMARK_,force_nl_QMARK_,lift_ns_QMARK_,lift_ns_in_code_QMARK_,one_line_QMARK_,ztype,map_depth,in_code_QMARK_))\n,pair_print),r_str_vec], 0));\n} else {\nreturn null;\n}\n}\n}\n});\n/**\n * Format a real map. ONLY WORKES ON STRUCTURES AT PRESENT\n */\nzprint.zprint.fzprint_map = (function zprint$zprint$fzprint_map(options,ind,zloc){\nvar vec__37570 = null;\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37570,(0),null);\nvar lifted_map = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37570,(1),null);\nif(cljs.core.truth_(ns)){\nreturn zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),[\"#:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns),\"{\"].join(''),\"}\",zprint.zprint.rightmost(options),ind,lifted_map);\n} else {\nreturn zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),\"{\",\"}\",zprint.zprint.rightmost(options),ind,zloc);\n}\n});\n/**\n * Return true if the string starts with #object[\n */\nzprint.zprint.object_str_QMARK_ = (function zprint$zprint$object_str_QMARK_(s){\nreturn cljs.core.re_find(/^#object\\[/,s);\n});\n/**\n * Print something that looks like #object[...] in a way\n *   that will acknowledge the structure inside of the [...]\n */\nzprint.zprint.fzprint_object = (function zprint$zprint$fzprint_object(var_args){\nvar G__37574 = arguments.length;\nswitch (G__37574) {\ncase 4:\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 3:\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc,zloc_value){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"object\",\"object\",1474613949),\"#object[\",\"]\",options,ind,(zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$2(zloc,zloc_value) : zprint.zfns.zobj_to_vec.call(null,zloc,zloc_value)));\n});\n\nzprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3 = (function (options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"object\",\"object\",1474613949),\"#object[\",\"]\",options,ind,(zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zobj_to_vec.call(null,zloc)));\n});\n\nzprint.zprint.fzprint_object.cljs$lang$maxFixedArity = 4;\n\n/**\n * Find the hash-code identity for an object.\n */\nzprint.zprint.hash_identity_str = (function zprint$zprint$hash_identity_str(obj){\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.hash(obj));\n});\nzprint.zprint.fzprint_atom = (function zprint$zprint$fzprint_atom(p__37575,ind,zloc){\nvar map__37576 = p__37575;\nvar map__37576__$1 = (((((!((map__37576 == null))))?(((((map__37576.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37576.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37576):map__37576);\nvar options = map__37576__$1;\nvar map__37577 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37576__$1,new cljs.core.Keyword(null,\"atom\",\"atom\",-397043653));\nvar map__37577__$1 = (((((!((map__37577 == null))))?(((((map__37577.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37577.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37577):map__37577);\nvar object_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37577__$1,new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217));\nif(cljs.core.truth_((function (){var and__4120__auto__ = object_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)));\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar arg_1 = [\"Atom@\",zprint.zprint.hash_identity_str(zloc)].join('');\nvar arg_1_indent = (((ind + indent) + (1)) + cljs.core.count(arg_1));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-atom: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options),arg_1_indent,(indent + ind),(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc))),r_str_vec], 0));\n}\n});\n/**\n * Print out a future or a promise or a delay.  These can only be \n *   sexpressions, since they don't exist in a textual representation \n *   of code (or data for that matter).  That means that we can use \n *   regular sexpression operations on zloc.\n */\nzprint.zprint.fzprint_future_promise_delay_agent = (function zprint$zprint$fzprint_future_promise_delay_agent(options,ind,zloc){\nvar zloc_type = (cljs.core.truth_((zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfuture_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"future\",\"future\",1877842724):(cljs.core.truth_((zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zpromise_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"promise\",\"promise\",1767129287):(cljs.core.truth_((zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zdelay_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"delay\",\"delay\",-574225219):(cljs.core.truth_((zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zagent_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027):(function(){throw (new Error(\"Not a future, promise, or delay:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))))})()\n))));\nif(cljs.core.truth_((function (){var and__4120__auto__ = new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217).cljs$core$IFn$_invoke$arity$1((options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(zloc_type) : options.call(null,zloc_type)));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_type,new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027))) || (cljs.core.realized_QMARK_(zloc)))){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)));\n} else {\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options,ind,zloc);\n}\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar type_str = (function (){var G__37580 = zloc_type;\nvar G__37580__$1 = (((G__37580 instanceof cljs.core.Keyword))?G__37580.fqn:null);\nswitch (G__37580__$1) {\ncase \"future\":\nreturn \"Future@\";\n\nbreak;\ncase \"promise\":\nreturn \"Promise@\";\n\nbreak;\ncase \"delay\":\nreturn \"Delay@\";\n\nbreak;\ncase \"agent\":\nreturn \"Agent@\";\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__37580__$1)].join('')));\n\n}\n})();\nvar arg_1 = [cljs.core.str.cljs$core$IFn$_invoke$arity$1(type_str),zprint.zprint.hash_identity_str(zloc)].join('');\nvar arg_1_indent = (((ind + indent) + (1)) + cljs.core.count(arg_1));\nvar zloc_realized_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_type,new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027)))?true:cljs.core.realized_QMARK_(zloc));\nvar value = ((zloc_realized_QMARK_)?(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)):(function (){var G__37581 = zloc_type;\nvar G__37581__$1 = (((G__37581 instanceof cljs.core.Keyword))?G__37581.fqn:null);\nswitch (G__37581__$1) {\ncase \"future\":\nreturn \"pending\";\n\nbreak;\ncase \"promise\":\nreturn \"not-delivered\";\n\nbreak;\ncase \"delay\":\nreturn \"pending\";\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__37581__$1)].join('')));\n\n}\n})());\nvar options__$1 = ((zloc_realized_QMARK_)?options:cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352),true));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-fpda: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options__$1,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options__$1),arg_1_indent,(indent + ind),value),r_str_vec], 0));\n}\n});\n/**\n * Print a function object, what you get when you put a function in\n *   a collection, for instance.  This doesn't do macros, you will notice.\n *   It also can't be invoked when zloc is a zipper.\n */\nzprint.zprint.fzprint_fn_obj = (function zprint$zprint$fzprint_fn_obj(p__37582,ind,zloc){\nvar map__37583 = p__37582;\nvar map__37583__$1 = (((((!((map__37583 == null))))?(((((map__37583.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37583.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37583):map__37583);\nvar options = map__37583__$1;\nvar map__37584 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37583__$1,new cljs.core.Keyword(null,\"fn-obj\",\"fn-obj\",465065936));\nvar map__37584__$1 = (((((!((map__37584 == null))))?(((((map__37584.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37584.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37584):map__37584);\nvar object_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37584__$1,new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217));\nif(cljs.core.truth_((function (){var and__4120__auto__ = object_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options,ind,zloc);\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5(options,(indent + ind),zloc,r_str,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204));\nvar arg_1_left = \"Fn@\";\nvar arg_1_right = zprint.zprint.hash_identity_str(zloc);\nvar arg_1_indent = ((((ind + indent) + (1)) + cljs.core.count(arg_1_left)) + cljs.core.count(arg_1_right));\nvar class_str = cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.type(zloc)], 0));\nvar name_js = cljs.core.str.cljs$core$IFn$_invoke$arity$1(zloc.name);\nvar color = (cljs.core.truth_((function (){var or__4131__auto__ = cljs.core.re_find(/^clojure/,name_js);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.re_find(/^cljs/,name_js);\n}\n})())?zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)):new cljs.core.Keyword(null,\"none\",\"none\",1333468478));\nvar name_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2(name_js,/\\$/);\nvar arg_2 = [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(\".\",cljs.core.butlast(name_split)))),\"/\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.last(name_split))].join('');\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-fn-obj: arg-1:\",arg_1_left,arg_1_right,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1_left,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1_right,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(options,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352),true,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"string-color\",\"string-color\",-1853875244),color], 0))),arg_1_indent,(indent + ind),arg_2),r_str_vec], 0));\n}\n});\nzprint.zprint.fzprint_ns = (function zprint$zprint$fzprint_ns(options,ind,zloc){\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar arg_1 = \"Namespace\";\nvar arg_1_indent = (((ind + indent) + (1)) + cljs.core.count(arg_1));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-atom: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options),arg_1_indent,(indent + ind),cljs.core.ns_name(zloc)),r_str_vec], 0));\n});\nzprint.zprint.fzprint_record = (function zprint$zprint$fzprint_record(p__37587,ind,zloc){\nvar map__37588 = p__37587;\nvar map__37588__$1 = (((((!((map__37588 == null))))?(((((map__37588.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37588.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37588):map__37588);\nvar options = map__37588__$1;\nvar map__37589 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37588__$1,new cljs.core.Keyword(null,\"record\",\"record\",-779106859));\nvar map__37589__$1 = (((((!((map__37589 == null))))?(((((map__37589.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37589.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37589):map__37589);\nvar record_type_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37589__$1,new cljs.core.Keyword(null,\"record-type?\",\"record-type?\",-1195765660));\nvar to_string_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37589__$1,new cljs.core.Keyword(null,\"to-string?\",\"to-string?\",1452120886));\nif(cljs.core.truth_(to_string_QMARK_)){\nvar G__37592 = options;\nvar G__37593 = ind;\nvar G__37594 = zloc.toString();\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37592,G__37593,G__37594) : zprint.zprint.fzprint_STAR_.call(null,G__37592,G__37593,G__37594));\n} else {\nif(cljs.core.not(record_type_QMARK_)){\nvar G__37595 = options;\nvar G__37596 = ind;\nvar G__37597 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,zloc);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37595,G__37596,G__37597) : zprint.zprint.fzprint_STAR_.call(null,G__37595,G__37596,G__37597));\n} else {\nvar l_str = \"#\";\nvar r_str = \"\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar arg_1 = cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.type(zloc)], 0));\nvar arg_1__$1 = (function (){var tokens = clojure.string.split.cljs$core$IFn$_invoke$arity$2(arg_1,/\\./);\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(\".\",cljs.core.butlast(tokens))),\"/\",cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.last(tokens)], 0)));\n})();\nvar arg_1_indent = (((ind + indent) + (1)) + cljs.core.count(arg_1__$1));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-record: arg-1:\",arg_1__$1,\"zstring zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1__$1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"record\",\"record\",-779106859),options,arg_1_indent,(indent + ind),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,zloc)),r_str_vec], 0));\n}\n}\n});\n/**\n * Trim the #_ off the front of the uneval, and try to print it.\n */\nzprint.zprint.fzprint_uneval = (function zprint$zprint$fzprint_uneval(options,ind,zloc){\nvar l_str = \"#_\";\nvar r_str = \"\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar uloc = (zprint.zfns.zparseuneval.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zparseuneval.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zparseuneval.call(null,zloc));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-uneval: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"uloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(uloc) : zprint.zfns.zstring.call(null,uloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37598 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707).cljs$core$IFn$_invoke$arity$1(options)));\nvar G__37599 = (indent + ind);\nvar G__37600 = uloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37598,G__37599,G__37600) : zprint.zprint.fzprint_STAR_.call(null,G__37598,G__37599,G__37600));\n})(),r_str_vec], 0));\n});\n/**\n * Print the two items in a meta node.  Different because it doesn't print\n *   a single collection, so it doesn't do any indent or rightmost.  It also\n *   uses a different approach to calling fzprint-flow-seq with the\n *   results zmap, so that it prints all of the seq, not just the rightmost.\n */\nzprint.zprint.fzprint_meta = (function zprint$zprint$fzprint_meta(options,ind,zloc){\nvar l_str = \"^\";\nvar r_str = \"\";\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-meta: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(options,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.vector,(cljs.core.count(l_str) + ind),cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) - (1)),ind)),(zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc))),r_str_vec], 0));\n});\n/**\n * Print a reader-macro, often a reader-conditional. Adapted for differences\n *   in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n *   the rewrite-clj not parsing namespaced maps in the version presently\n *   used.\n */\nzprint.zprint.fzprint_reader_macro = (function zprint$zprint$fzprint_reader_macro(options,ind,zloc){\nvar zstr = (function (){var G__37601 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37601) : zprint.zfns.zstring.call(null,G__37601));\n})();\nvar alt_at_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(zstr),(2))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(1),(2)),\"@\")));\nvar reader_cond_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(0),(1)),\"?\");\nvar namespaced_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(0),(1)),\":\");\nvar at_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((function (){var G__37603 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(G__37603) : zprint.zfns.ztag.call(null,G__37603));\n})(),new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795))) || (alt_at_QMARK_));\nvar l_str = ((((reader_cond_QMARK_) && (at_QMARK_)))?\"#?@\":(cljs.core.truth_((function (){var and__4120__auto__ = reader_cond_QMARK_;\nif(and__4120__auto__){\nvar G__37605 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(G__37605) : zprint.zfns.zcoll_QMARK_.call(null,G__37605));\n} else {\nreturn and__4120__auto__;\n}\n})())?\"#?\":((reader_cond_QMARK_)?(function(){throw (new Error([\"Unknown reader macro: '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))),\"' zfirst zloc: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((function (){var G__37607 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__37607) : zprint.zfns.zstring.call(null,G__37607));\n})())].join('')))})():((namespaced_QMARK_)?[\"#\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zstr)].join(''):\"#\"\n))));\nvar r_str = \"\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(indent + ind),zloc,r_str);\nvar floc = ((((at_QMARK_) && ((!(alt_at_QMARK_)))))?(function (){var G__37608 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(G__37608) : zprint.zfns.zfirst.call(null,G__37608));\n})():(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-reader-macro: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"floc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(floc) : zprint.zfns.zstring.call(null,floc)),\"l-str:\",l_str], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),((reader_cond_QMARK_)?zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"reader-cond\",\"reader-cond\",-2133265058),\"(\",\")\",zprint.zprint.rightmost(options),(indent + ind),floc):zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(options,(indent + ind),(function (){var zloc_seq = (zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc));\nif(namespaced_QMARK_){\nreturn cljs.core.next(zloc_seq);\n} else {\nreturn zloc_seq;\n}\n})())),r_str_vec], 0));\n});\n/**\n * Print the single item after a variety of prefix characters.\n */\nzprint.zprint.fzprint_prefix_STAR_ = (function zprint$zprint$fzprint_prefix_STAR_(options,ind,zloc,l_str){\nvar r_str = \"\";\nvar indent = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5(options,(indent + ind),zloc,r_str,new cljs.core.Keyword(null,\"right\",\"right\",-452581833));\nvar floc = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-prefix*: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"floc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(floc) : zprint.zfns.zstring.call(null,floc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__37609 = options;\nvar G__37610 = (indent + ind);\nvar G__37611 = floc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__37609,G__37610,G__37611) : zprint.zprint.fzprint_STAR_.call(null,G__37609,G__37610,G__37611));\n})(),r_str_vec], 0));\n});\nzprint.zprint.prefix_tags = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),\"'\",new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847),\"`\",new cljs.core.Keyword(null,\"unquote\",\"unquote\",1649741032),\"~\",new cljs.core.Keyword(null,\"unquote-splicing\",\"unquote-splicing\",1295267556),\"~@\",new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795),\"@\",new cljs.core.Keyword(null,\"var\",\"var\",-769682797),\"#'\",new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707),\"#_\"], null);\n/**\n * Change options as necessary based on prefix tag.\n */\nzprint.zprint.prefix_options = (function zprint$zprint$prefix_options(options,prefix_tag){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prefix_tag,new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707).cljs$core$IFn$_invoke$arity$1(options)));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prefix_tag,new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847))){\nreturn cljs.core.assoc_in(options,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600)], null),new cljs.core.Keyword(null,\"syntax-quote-paren\",\"syntax-quote-paren\",646342677).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(options)));\n} else {\nreturn options;\n\n}\n}\n});\n/**\n * The pretty print part of fzprint.\n */\nzprint.zprint.fzprint_STAR_ = (function zprint$zprint$fzprint_STAR_(p__37612,indent,zloc){\nvar map__37613 = p__37612;\nvar map__37613__$1 = (((((!((map__37613 == null))))?(((((map__37613.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37613.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37613):map__37613);\nvar options = map__37613__$1;\nvar max_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"max-depth\",\"max-depth\",127060793));\nvar fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146));\nvar shift_seq = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"shift-seq\",\"shift-seq\",267527195));\nvar max_hang_count = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"max-hang-count\",\"max-hang-count\",637294812));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nvar max_hang_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"max-hang-depth\",\"max-hang-depth\",-915232220));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar hex_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"hex?\",\"hex?\",890937870));\nvar dbg_print_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar string_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"string-color\",\"string-color\",-1853875244));\nvar trim_comments_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"trim-comments?\",\"trim-comments?\",-1532658667));\nvar max_hang_span = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"max-hang-span\",\"max-hang-span\",256100693));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640));\nvar string_str_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37613__$1,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352));\nvar avail = (width - indent);\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),(depth + (1)));\nvar options__$2 = (cljs.core.truth_((function (){var or__4131__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn dbg_print_QMARK_;\n}\n})())?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778),[cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.get.cljs$core$IFn$_invoke$arity$3(options__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778),\"\")),(cljs.core.truth_(one_line_QMARK_)?\"o\":(cljs.core.truth_(in_hang_QMARK_)?\"h\":\".\"\n))].join('')):options__$1);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$2))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$2),\"fzprint* **** rightcnt:\",rightcnt,cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0)):null);\nvar dbg_data = cljs.core.deref(zprint.zprint.fzprint_dbg);\nvar dbg_focus_QMARK_ = (function (){var and__4120__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(dbg_data,cljs.core.second((zprint.zfns.zfind_path.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfind_path.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfind_path.call(null,zloc))));\n} else {\nreturn and__4120__auto__;\n}\n})();\nvar options__$3 = (cljs.core.truth_(dbg_focus_QMARK_)?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$2,new cljs.core.Keyword(null,\"dbg\",\"dbg\",202767554),new cljs.core.Keyword(null,\"on\",\"on\",173873944)):options__$2);\nvar ___$1 = (cljs.core.truth_(dbg_focus_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint dbg-data:\",dbg_data], 0)):null);\nif(cljs.core.truth_((function (){var and__4120__auto__ = (depth > max_depth);\nif(and__4120__auto__){\nreturn (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcoll_QMARK_.call(null,zloc));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"...\",zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"##\",zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"keyword\",\"keyword\",811389747)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n}\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = in_hang_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ((cljs.core.not(in_code_QMARK_)) && (((((depth - in_hang_QMARK_) > max_hang_span)) || (((cljs.core.not(one_line_QMARK_)) && (((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) > max_hang_count)) && ((depth > max_hang_depth)))))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn null;\n} else {\nif(cljs.core.truth_((zprint.zfns.zrecord_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zrecord_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zrecord_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_record(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zlist_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_list(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zvector_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_vec(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zmap_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zmap_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zmap_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_map(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zset_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zset_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zset_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_set(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zanonfn_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zanonfn_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zanonfn_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_anon_fn(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zfn_obj_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfn_obj_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfn_obj_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_fn_obj(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zarray_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zarray_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zarray_QMARK_.call(null,zloc)))){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"array\",\"array\",-2080713842).cljs$core$IFn$_invoke$arity$1(options__$3)))){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options__$3,indent,zloc);\n} else {\nreturn zprint.zprint.fzprint_array(options__$3,indent,(zprint.zfns.zexpandarray.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zexpandarray.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zexpandarray.call(null,zloc)));\n}\n} else {\nif(cljs.core.truth_((zprint.zfns.zatom_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zatom_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zatom_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_atom(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zmeta_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zmeta_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zmeta_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_meta(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((function (){var G__37615 = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn (zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1(G__37615) : zprint.zprint.prefix_tags.call(null,G__37615));\n})())){\nreturn zprint.zprint.fzprint_prefix_STAR_(zprint.zprint.prefix_options(options__$3,(zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc))),indent,zloc,(function (){var G__37616 = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn (zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1(G__37616) : zprint.zprint.prefix_tags.call(null,G__37616));\n})());\n} else {\nif(cljs.core.truth_((zprint.zfns.zns_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zns_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zns_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_ns(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((function (){var or__4131__auto__ = (zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zpromise_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfuture_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zdelay_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn (zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zagent_QMARK_.call(null,zloc));\n}\n}\n}\n})())){\nreturn zprint.zprint.fzprint_future_promise_delay_agent(options__$3,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zreader_macro_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_macro_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zreader_macro_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_reader_macro(options__$3,indent,zloc);\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) && ((depth > (0))))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323)], null)], null);\n} else {\nvar zstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc));\nvar overflow_in_hang_QMARK_ = (function (){var and__4120__auto__ = in_hang_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (((cljs.core.count(zstr) + indent) + (function (){var or__4131__auto__ = rightcnt;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})()) > width);\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_((zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc)))){\nvar zcomment = (((((depth === (0))) && (cljs.core.not(trim_comments_QMARK_))))?zstr:clojure.string.replace(zstr,\"\\n\",\"\"));\nvar inline_spaces = (cljs.core.truth_(new cljs.core.Keyword(null,\"inline?\",\"inline?\",-1674483791).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options__$3)))?(zprint.zfns.zinlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zinlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zinlinecomment_QMARK_.call(null,zloc)):null);\nif(cljs.core.truth_((function (){var and__4120__auto__ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options__$3));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn overflow_in_hang_QMARK_;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$3))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$3),\"fzprint*: overflow comment ========\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nif(cljs.core.truth_(inline_spaces)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zcomment,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405),inline_spaces], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zcomment,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)], null)], null);\n}\n}\n} else {\nif(cljs.core.truth_((zprint.zfns.zwhitespaceorcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zwhitespaceorcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zwhitespaceorcomment_QMARK_.call(null,zloc)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null)], null);\n} else {\nif(cljs.core.truth_(overflow_in_hang_QMARK_)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$3))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$3),\"fzprint*: overflow <<<<<<<<<<\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nif(cljs.core.truth_((zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zkeyword_QMARK_.call(null,zloc)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"keyword\",\"keyword\",811389747)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(typeof (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) === 'string'){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [(cljs.core.truth_(string_str_QMARK_)?cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))):(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))),(cljs.core.truth_(string_color)?string_color:zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"string\",\"string\",-1989541586))),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.truth_(zprint.zprint.showfn_QMARK_(fn_map,(zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.truth_(zprint.zprint.show_user_fn_QMARK_(options__$3,(zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"user-fn\",\"user-fn\",223976490)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(typeof (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) === 'number'){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [(cljs.core.truth_(hex_QMARK_)?(zprint.zfns.znumstr.cljs$core$IFn$_invoke$arity$3 ? zprint.zfns.znumstr.cljs$core$IFn$_invoke$arity$3(zloc,hex_QMARK_,shift_seq) : zprint.zfns.znumstr.call(null,zloc,hex_QMARK_,shift_seq)):zstr),zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"number\",\"number\",1570378438)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) == null)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"nil\",\"nil\",99600501)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$3,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n/**\n * Take a string and an index, and look for the last space prior to the\n *   index. If we wanted to tie ourselves to 1.8, we could use \n *   clojure.string/last-index-of, but we don't.  However, we use similar\n *   conventions, i.e., if no space is found, return nil, and if the index\n *   is a space return that value, and accept any from-index, including one\n *   larger than the length of the string.\n */\nzprint.zprint.last_space = (function zprint$zprint$last_space(s,from_index){\nvar from_index__$1 = (function (){var x__4222__auto__ = (cljs.core.count(s) - (1));\nvar y__4223__auto__ = from_index;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})();\nvar rev_seq = cljs.core.reverse(cljs.core.take.cljs$core$IFn$_invoke$arity$2((from_index__$1 + (1)),s));\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(((function (from_index__$1,rev_seq){\nreturn (function (p1__37617_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__37617_SHARP_,\" \");\n});})(from_index__$1,rev_seq))\n,rev_seq);\nvar space_index = (from_index__$1 - cljs.core.count(seq_after_space));\nif((space_index < (0))){\nreturn null;\n} else {\nreturn space_index;\n}\n});\n/**\n * Take a string and an index, and look for the next space *after* the\n *   index. If no space is found, return nil. Accept any from-index, \n *   including one larger than the length of the string.\n */\nzprint.zprint.next_space = (function zprint$zprint$next_space(s,from_index){\nvar from_index__$1 = (from_index + (1));\nif((from_index__$1 < cljs.core.count(s))){\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(((function (from_index__$1){\nreturn (function (p1__37618_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__37618_SHARP_,\" \");\n});})(from_index__$1))\n,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(from_index__$1,cljs.core.seq(s)));\nvar space_index = (from_index__$1 + cljs.core.count(seq_after_space));\nif((space_index >= cljs.core.count(s))){\nreturn null;\n} else {\nreturn space_index;\n}\n} else {\nreturn null;\n}\n});\n/**\n * If this is a comment, and it is too long, word wrap it to the right width.\n *   Note that top level comments may well end with a newline, so remove it\n *   and reapply it at the end if that is the case.\n */\nzprint.zprint.wrap_comment = (function zprint$zprint$wrap_comment(width,p__37619,start){\nvar vec__37620 = p__37619;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37620,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37620,(1),null);\nvar stype = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37620,(2),null);\nvar element = vec__37620;\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))))){\nreturn element;\n} else {\nvar comment_width = (width - start);\nvar semi_str = cljs.core.re_find(/;*/,s);\nvar rest_str = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(semi_str));\nvar space_str = cljs.core.re_find(/ */,rest_str);\nvar rest_str__$1 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(rest_str,cljs.core.count(space_str));\nvar newline_QMARK_ = cljs.core.re_find(/\\n$/,s);\nvar comment_width__$1 = ((comment_width - cljs.core.count(semi_str)) - cljs.core.count(space_str));\nvar comment_str = rest_str__$1;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(comment_str)){\nif((cljs.core.count(out) === (0))){\nif(cljs.core.truth_(newline_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null)], null);\n}\n} else {\nreturn cljs.core.persistent_BANG_((cljs.core.truth_(newline_QMARK_)?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)):out));\n}\n} else {\nvar last_space_index = (((cljs.core.count(comment_str) <= comment_width__$1))?(cljs.core.count(comment_str) - (1)):(((comment_width__$1 <= (0)))?(function (){var or__4131__auto__ = zprint.zprint.next_space(comment_str,(0));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (cljs.core.count(comment_str) - (1));\n}\n})():(function (){var or__4131__auto__ = zprint.zprint.last_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = zprint.zprint.next_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (cljs.core.count(comment_str) - (1));\n}\n}\n})()));\nvar next_comment = clojure.string.trimr(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(comment_str,(0),(last_space_index + (1))));\nvar G__37998 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(comment_str,(last_space_index + (1)));\nvar G__37999 = (((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(next_comment)].join(''),color,stype], null)):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(start))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)], null)),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(next_comment)].join(''),color,new cljs.core.Keyword(null,\"comment-wrap\",\"comment-wrap\",720664128)], null)));\ncomment_str = G__37998;\nout = G__37999;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Takes the start of this vector and the vector itself.\n */\nzprint.zprint.loc_vec = (function zprint$zprint$loc_vec(start,p__37623){\nvar vec__37624 = p__37623;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37624,(0),null);\nvar split = zprint.zprint.split_lf(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(split),(1))){\nreturn (start + cljs.core.count(s));\n} else {\nreturn cljs.core.count(cljs.core.last(split));\n}\n});\n/**\n * Take a style-vec and produce a style-loc-vec with the starting column\n *   of each element in the style-vec.\n */\nzprint.zprint.style_loc_vec = (function zprint$zprint$style_loc_vec(style_vec){\nreturn cljs.core.butlast(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(zprint.zprint.loc_vec,(0),style_vec));\n});\n/**\n * Take a transient output vector and a vector and lift any style-vec elements\n *   out of the input vector.\n */\nzprint.zprint.lift_vec = (function zprint$zprint$lift_vec(out_vec,element){\nif(typeof cljs.core.first(element) === 'string'){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out_vec,element);\n} else {\nvar element_vec = element;\nvar out = out_vec;\nwhile(true){\nif(cljs.core.not(element_vec)){\nreturn out;\n} else {\nvar G__38003 = cljs.core.next(element_vec);\nvar G__38004 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(element_vec));\nelement_vec = G__38003;\nout = G__38004;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a style-vec [[s color type] [s color type] [[s color type]\n *   [s color type]] [s color type] ...] and lift out the inner vectors.\n */\nzprint.zprint.lift_style_vec = (function zprint$zprint$lift_style_vec(style_vec){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.lift_vec,cljs.core.PersistentVector.EMPTY,style_vec);\n});\n/**\n * Take the final output style-vec, and wrap any comments which run over\n *   the width. Looking for \n */\nzprint.zprint.fzprint_wrap_comments = (function zprint$zprint$fzprint_wrap_comments(p__37627,style_vec){\nvar map__37628 = p__37627;\nvar map__37628__$1 = (((((!((map__37628 == null))))?(((((map__37628.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37628.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37628):map__37628);\nvar options = map__37628__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37628__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar start_col = zprint.zprint.style_loc_vec(style_vec);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: style-vec:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: start-col:\",start_col], 0)):null);\nvar wrap_style_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.wrap_comment,width),style_vec,start_col);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: wrap:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar out_style_vec = zprint.zprint.lift_style_vec(wrap_style_vec);\nreturn out_style_vec;\n});\n/**\n * Try to bring inline comments back onto the line on which they belong.\n */\nzprint.zprint.fzprint_inline_comments = (function zprint$zprint$fzprint_inline_comments(p__37630,style_vec){\nvar map__37631 = p__37630;\nvar map__37631__$1 = (((((!((map__37631 == null))))?(((((map__37631.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__37631.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__37631):map__37631);\nvar options = map__37631__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__37631__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar cvec = style_vec;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__37639 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37639,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37639,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37639,(2),null);\nvar element = vec__37639;\nvar vec__37642 = cljs.core.second(cvec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37642,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37642,(1),null);\nvar ne = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37642,(2),null);\nvar nn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37642,(3),null);\nvar next_element = vec__37642;\nvar new_element = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ne,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(nn),c,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,c,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)], null):element\n));\nvar G__38026 = cljs.core.next(cvec);\nvar G__38027 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_element);\ncvec = G__38026;\nout = G__38027;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * The pretty print part of fzprint.\n */\nzprint.zprint.fzprint = (function zprint$zprint$fzprint(options,indent,zloc){\nvar zloc__$1 = ((cljs.core.not((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438));\nif(and__4120__auto__){\nreturn new cljs.core.Keyword(null,\"value\",\"value\",305978217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"spec\",\"spec\",347520401).cljs$core$IFn$_invoke$arity$1(options));\n} else {\nreturn and__4120__auto__;\n}\n})()))?zloc:zprint.zutil.add_spec_to_docstring(zloc,new cljs.core.Keyword(null,\"value\",\"value\",305978217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"spec\",\"spec\",347520401).cljs$core$IFn$_invoke$arity$1(options))));\nvar style_vec = zprint.zprint.fzprint_STAR_(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(options,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),(0),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641),(0)], 0)),indent,zloc__$1);\nreturn style_vec;\n});\n/**\n * Count lines in a string.\n */\nzprint.zprint.line_count = (function zprint$zprint$line_count(s){\nreturn (cljs.core.count(cljs.core.re_seq(/\\n/,s)) + (1));\n});\n/**\n * Return a vector the lengths of lines.\n */\nzprint.zprint.line_widths = (function zprint$zprint$line_widths(s){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.count,clojure.string.split.cljs$core$IFn$_invoke$arity$2(s,/\\n/));\n});\n/**\n * Split a string into lines, and figure the max width.\n */\nzprint.zprint.max_width = (function zprint$zprint$max_width(s){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.max,zprint.zprint.line_widths(s));\n});\n/**\n * Takes a string, and expands tabs inside of the string based\n *   on a tab-size argument.\n */\nzprint.zprint.expand_tabs = (function zprint$zprint$expand_tabs(var_args){\nvar G__37646 = arguments.length;\nswitch (G__37646) {\ncase 2:\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2 = (function (tab_size,s){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,(function (){var char_seq = cljs.core.seq(s);\nvar cur_len = cljs.core.long$((0));\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(char_seq)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar this_char = cljs.core.first(char_seq);\nvar tab_expansion = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_char,\"\\t\"))?(tab_size - cljs.core.mod(cur_len,tab_size)):null);\nvar G__38034 = cljs.core.rest(char_seq);\nvar G__38035 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_char,\"\\n\"))?(0):(cur_len + cljs.core.long$((function (){var or__4131__auto__ = tab_expansion;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (1);\n}\n})())));\nvar G__38036 = (cljs.core.truth_(tab_expansion)?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(zprint.zprint.conj_it_BANG_,out,cljs.core.seq(zprint.zprint.blanks(tab_expansion))):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,this_char));\nchar_seq = G__38034;\ncur_len = G__38035;\nout = G__38036;\ncontinue;\n}\nbreak;\n}\n})());\n});\n\nzprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2((8),s);\n});\n\nzprint.zprint.expand_tabs.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IRecord}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\nzprint.zprint.r = (function (left,right,__meta,__extmap,__hash){\nthis.left = left;\nthis.right = right;\nthis.__meta = __meta;\nthis.__extmap = __extmap;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2230716170;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\nzprint.zprint.r.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this__4385__auto__,k__4386__auto__){\nvar self__ = this;\nvar this__4385__auto____$1 = this;\nreturn this__4385__auto____$1.cljs$core$ILookup$_lookup$arity$3(null,k__4386__auto__,null);\n});\n\nzprint.zprint.r.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this__4387__auto__,k37648,else__4388__auto__){\nvar self__ = this;\nvar this__4387__auto____$1 = this;\nvar G__37652 = k37648;\nvar G__37652__$1 = (((G__37652 instanceof cljs.core.Keyword))?G__37652.fqn:null);\nswitch (G__37652__$1) {\ncase \"left\":\nreturn self__.left;\n\nbreak;\ncase \"right\":\nreturn self__.right;\n\nbreak;\ndefault:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k37648,else__4388__auto__);\n\n}\n});\n\nzprint.zprint.r.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this__4404__auto__,f__4405__auto__,init__4406__auto__){\nvar self__ = this;\nvar this__4404__auto____$1 = this;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (this__4404__auto____$1){\nreturn (function (ret__4407__auto__,p__37653){\nvar vec__37654 = p__37653;\nvar k__4408__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37654,(0),null);\nvar v__4409__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__37654,(1),null);\nreturn (f__4405__auto__.cljs$core$IFn$_invoke$arity$3 ? f__4405__auto__.cljs$core$IFn$_invoke$arity$3(ret__4407__auto__,k__4408__auto__,v__4409__auto__) : f__4405__auto__.call(null,ret__4407__auto__,k__4408__auto__,v__4409__auto__));\n});})(this__4404__auto____$1))\n,init__4406__auto__,this__4404__auto____$1);\n});\n\nzprint.zprint.r.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this__4399__auto__,writer__4400__auto__,opts__4401__auto__){\nvar self__ = this;\nvar this__4399__auto____$1 = this;\nvar pr_pair__4402__auto__ = ((function (this__4399__auto____$1){\nreturn (function (keyval__4403__auto__){\nreturn cljs.core.pr_sequential_writer(writer__4400__auto__,cljs.core.pr_writer,\"\",\" \",\"\",opts__4401__auto__,keyval__4403__auto__);\n});})(this__4399__auto____$1))\n;\nreturn cljs.core.pr_sequential_writer(writer__4400__auto__,pr_pair__4402__auto__,\"#zprint.zprint.r{\",\", \",\"}\",opts__4401__auto__,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"left\",\"left\",-399115937),self__.left],null)),(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"right\",\"right\",-452581833),self__.right],null))], null),self__.__extmap));\n});\n\nzprint.zprint.r.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (G__37647){\nvar self__ = this;\nvar G__37647__$1 = this;\nreturn (new cljs.core.RecordIter((0),G__37647__$1,2,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"left\",\"left\",-399115937),new cljs.core.Keyword(null,\"right\",\"right\",-452581833)], null),(cljs.core.truth_(self__.__extmap)?cljs.core._iterator(self__.__extmap):cljs.core.nil_iter())));\n});\n\nzprint.zprint.r.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this__4383__auto__){\nvar self__ = this;\nvar this__4383__auto____$1 = this;\nreturn self__.__meta;\n});\n\nzprint.zprint.r.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (this__4380__auto__){\nvar self__ = this;\nvar this__4380__auto____$1 = this;\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,self__.__extmap,self__.__hash));\n});\n\nzprint.zprint.r.prototype.cljs$core$ICounted$_count$arity$1 = (function (this__4389__auto__){\nvar self__ = this;\nvar this__4389__auto____$1 = this;\nreturn (2 + cljs.core.count(self__.__extmap));\n});\n\nzprint.zprint.r.prototype.cljs$core$IHash$_hash$arity$1 = (function (this__4381__auto__){\nvar self__ = this;\nvar this__4381__auto____$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = (function (){var fexpr__37657 = ((function (h__4243__auto__,this__4381__auto____$1){\nreturn (function (coll__4382__auto__){\nreturn (-1384233907 ^ cljs.core.hash_unordered_coll(coll__4382__auto__));\n});})(h__4243__auto__,this__4381__auto____$1))\n;\nreturn fexpr__37657(this__4381__auto____$1);\n})();\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\nzprint.zprint.r.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this37649,other37650){\nvar self__ = this;\nvar this37649__$1 = this;\nreturn (((!((other37650 == null)))) && ((this37649__$1.constructor === other37650.constructor)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this37649__$1.left,other37650.left)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this37649__$1.right,other37650.right)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this37649__$1.__extmap,other37650.__extmap)));\n});\n\nzprint.zprint.r.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (this__4394__auto__,k__4395__auto__){\nvar self__ = this;\nvar this__4394__auto____$1 = this;\nif(cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"right\",\"right\",-452581833),null,new cljs.core.Keyword(null,\"left\",\"left\",-399115937),null], null), null),k__4395__auto__)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core._with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,this__4394__auto____$1),self__.__meta),k__4395__auto__);\n} else {\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,cljs.core.not_empty(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.__extmap,k__4395__auto__)),null));\n}\n});\n\nzprint.zprint.r.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this__4392__auto__,k__4393__auto__,G__37647){\nvar self__ = this;\nvar this__4392__auto____$1 = this;\nvar pred__37658 = cljs.core.keyword_identical_QMARK_;\nvar expr__37659 = k__4393__auto__;\nif(cljs.core.truth_((function (){var G__37661 = new cljs.core.Keyword(null,\"left\",\"left\",-399115937);\nvar G__37662 = expr__37659;\nreturn (pred__37658.cljs$core$IFn$_invoke$arity$2 ? pred__37658.cljs$core$IFn$_invoke$arity$2(G__37661,G__37662) : pred__37658.call(null,G__37661,G__37662));\n})())){\nreturn (new zprint.zprint.r(G__37647,self__.right,self__.__meta,self__.__extmap,null));\n} else {\nif(cljs.core.truth_((function (){var G__37663 = new cljs.core.Keyword(null,\"right\",\"right\",-452581833);\nvar G__37664 = expr__37659;\nreturn (pred__37658.cljs$core$IFn$_invoke$arity$2 ? pred__37658.cljs$core$IFn$_invoke$arity$2(G__37663,G__37664) : pred__37658.call(null,G__37663,G__37664));\n})())){\nreturn (new zprint.zprint.r(self__.left,G__37647,self__.__meta,self__.__extmap,null));\n} else {\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k__4393__auto__,G__37647),null));\n}\n}\n});\n\nzprint.zprint.r.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this__4397__auto__){\nvar self__ = this;\nvar this__4397__auto____$1 = this;\nreturn cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"left\",\"left\",-399115937),self__.left,null)),(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"right\",\"right\",-452581833),self__.right,null))], null),self__.__extmap));\n});\n\nzprint.zprint.r.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this__4384__auto__,G__37647){\nvar self__ = this;\nvar this__4384__auto____$1 = this;\nreturn (new zprint.zprint.r(self__.left,self__.right,G__37647,self__.__extmap,self__.__hash));\n});\n\nzprint.zprint.r.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this__4390__auto__,entry__4391__auto__){\nvar self__ = this;\nvar this__4390__auto____$1 = this;\nif(cljs.core.vector_QMARK_(entry__4391__auto__)){\nreturn this__4390__auto____$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry__4391__auto__,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry__4391__auto__,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,this__4390__auto____$1,entry__4391__auto__);\n}\n});\n\nzprint.zprint.r.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"left\",\"left\",1241415590,null),new cljs.core.Symbol(null,\"right\",\"right\",1187949694,null)], null);\n});\n\nzprint.zprint.r.cljs$lang$type = true;\n\nzprint.zprint.r.cljs$lang$ctorPrSeq = (function (this__4428__auto__){\nreturn (new cljs.core.List(null,\"zprint.zprint/r\",null,(1),null));\n});\n\nzprint.zprint.r.cljs$lang$ctorPrWriter = (function (this__4428__auto__,writer__4429__auto__){\nreturn cljs.core._write(writer__4429__auto__,\"zprint.zprint/r\");\n});\n\n/**\n * Positional factory function for zprint.zprint/r.\n */\nzprint.zprint.__GT_r = (function zprint$zprint$__GT_r(left,right){\nreturn (new zprint.zprint.r(left,right,null,null,null));\n});\n\n/**\n * Factory function for zprint.zprint/r, taking a map of keywords to field values.\n */\nzprint.zprint.map__GT_r = (function zprint$zprint$map__GT_r(G__37651){\nvar extmap__4424__auto__ = (function (){var G__37665 = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(G__37651,new cljs.core.Keyword(null,\"left\",\"left\",-399115937),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"right\",\"right\",-452581833)], 0));\nif(cljs.core.record_QMARK_(G__37651)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,G__37665);\n} else {\nreturn G__37665;\n}\n})();\nreturn (new zprint.zprint.r(new cljs.core.Keyword(null,\"left\",\"left\",-399115937).cljs$core$IFn$_invoke$arity$1(G__37651),new cljs.core.Keyword(null,\"right\",\"right\",-452581833).cljs$core$IFn$_invoke$arity$1(G__37651),null,cljs.core.not_empty(extmap__4424__auto__),null));\n});\n\nzprint.zprint.make_record = (function zprint$zprint$make_record(l,r){\nreturn (new r(l,r));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/zprint.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",18],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$dbg","~$zprint.macros","~$dbg-pr","^F","~$dbg-form","^F","~$dbg-print","^F","~$zfuture","^F"],"~:excludes",["~#set",[]],"~:name","~$zprint.zprint","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$rewrite-clj.parser","^S","~$p","^S","~$zprint.config","^T","~$rewrite-clj.zip","^U","~$cljs.core","^V","~$goog","^W","~$zprint.zfns","^X","~$zprint.ansi","^Y","~$s","~$clojure.string","~$z","^U","^Z","^Z","~$zprint.zutil","^["],"~:seen",["^L",["~:require","~:require-macros"]],"~:uses",["^ ","~$zreader-cond-w-symbol?","^X","~$zarray-to-shift-seq","^X","~$zlist?","^X","~$zvector?","^X","~$zarray?","^X","~$zcomment?","^X","~$zanonfn?","^X","~$zfirst-no-comment","^X","~$zkeyword?","^X","~$zdelay?","^X","~$zns?","^X","~$zconstant?","^X","~$zfourth","^X","~$znewline?","^X","~$merge-deep","^T","~$zmap?","^X","~$zatom?","^X","~$zstring","^X","~$validate-options","^T","~$zlast","^X","~$zdotdotdot","^X","~$znthnext","^X","~$znil?","^X","~$zset?","^X","~$color-str","^Y","~$zsymbol?","^X","~$zfn-obj?","^X","~$zreader-cond-w-coll?","^X","~$zmeta?","^X","~$add-spec-to-docstring","^[","~$zfocus","^X","~$zfirst","^X","~$zagent?","^X","~$zbyte-array?","^X","~$zcount","^X","~$zexpandarray","^X","~$zwhitespace?","^X","~$zreader-macro?","^X","~$zthird","^X","~$zcoll?","^X","~$zmap-right","^X","~$zfuture?","^X","~$zpromise?","^X","~$zderef","^X","~$zlift-ns","^X","~$zsecond","^X","~$zsexpr","^X","~$zinlinecomment?","^X","~$zrecord?","^X","~$zobj-to-vec","^X","~$zparseuneval","^X","~$zfocus-style","^X","~$zwhitespaceorcomment?","^X","~$zmap-all","^X","~$zmap","^X","~$ztag","^X","~$zseqnws","^X","~$zmap-w-nl","^X","~$zfind-path","^X","~$zuneval?","^X","~$zfind","^X","~$znumstr","^X"],"^12",["^ ","^F","^F","^V","^V"],"~:form",["~#list",["~$ns","^N",["^12",["^F","~:refer",["^E","^G","^H","^I","^J"]]],["^2G",["^11",["^Z","~:as","~$s"],["^X","^2I",["^1E","^2E","^1U","^19","^26","^2@","^20","^2;","^1S","^1;","^25","^1Z","^1@","^1I","^1V","^2>","^1:","^1N","^1R","^2B","^1X","^16","^17","^1C","^1K","^1[","^2C","^1P","^2?","^2:","^1G","^18","^1D","^23","^28","^1>","^29","^1W","^1A","^2<","^2=","^22","^21","^1=","^1<","^1?","^1T","^1Y","^15","^1H","^1M","^1J","^14","^1O","^24","^27","^2D","^2A"]],["^Y","^2I",["^1L"]],["^T","^2I",["^1F","^1B"]],["^[","^2I",["^1Q"]],["^S","^2J","~$p"],["^U","^2J","~$z"]]]]],"~:flags",["^ ","^12",["^L",[]],"^11",["^L",[]]],"~:js-deps",["^ "],"~:deps",["^W","^V","^Z","^X","^Y","^T","^[","^S","^U"]],"^P","^N","~:resource-id",["~:shadow.build.classpath/resource","zprint/zprint.cljc"],"~:compiled-at",1554046545931,"~:resource-name","zprint/zprint.cljc","~:warnings",[],"~:source","(ns zprint.zprint\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer [dbg dbg-pr dbg-form dbg-print zfuture]]]])\n  (:require\n    #?@(:clj [[zprint.macros :refer [dbg-pr dbg dbg-form dbg-print zfuture]]])\n    [clojure.string :as s]\n    [zprint.zfns :refer\n     [zstring znumstr zbyte-array? zcomment? zsexpr zseqnws zmap-right\n      zfocus-style zfirst zfirst-no-comment zsecond zthird zfourth znthnext\n      zcount zmap zanonfn? zfn-obj? zfocus zfind-path zwhitespace? zlist?\n      zvector? zmap? zset? zcoll? zuneval? zmeta? ztag zparseuneval zlast\n      zarray? zatom? zderef zrecord? zns? zobj-to-vec zexpandarray znewline?\n      zwhitespaceorcomment? zmap-all zpromise? zfuture? zdelay? zkeyword?\n      zconstant? zagent? zreader-macro? zarray-to-shift-seq zdotdotdot zsymbol?\n      znil? zreader-cond-w-symbol? zreader-cond-w-coll? zlift-ns zinlinecomment?\n      zfind zmap-w-nl]]\n    [zprint.ansi :refer [color-str]]\n    [zprint.config :refer [validate-options merge-deep]]\n    [zprint.zutil :refer [add-spec-to-docstring]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.zip :as z]\n    #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n(declare interpose-nl-hf)\n\n;;\n;; # Utility Functions\n;;\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn dots\n  \"Produce a dot string of desired size.\"\n  [n]\n  (apply str (repeat n \".\")))\n\n(defn indent \"error\" [])\n\n(defn conj-it!\n  \"Make a version of conj! that take multiple arguments.\"\n  [& rest]\n  (loop [out (first rest)\n         more (next rest)]\n    (if more (recur (conj! out (first more)) (next more)) out)))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn split-lf-2\n  \"Do split for newlines, instead of using regular expressions.\n  Maximum split is 2.\"\n  [s]\n  (if-let [next-lf (clojure.string/index-of s \"\\n\")]\n    [(subs s 0 next-lf) (subs s (inc next-lf))]\n    [s]))\n\n;;\n;; # Use pmap when we have it\n;;\n\n#?(:clj (defn zpmap\n          ([options f coll]\n           (if (:parallel? options) (pmap f coll) (map f coll)))\n          ([options f coll1 coll2]\n           (if (:parallel? options) (pmap f coll1 coll2) (map f coll1 coll2))))\n   :cljs (defn zpmap\n           ([options f coll] (map f coll))\n           ([options f coll1 coll2] (map f coll1 coll2))))\n\n;;\n;; # More parallelism issues -- zderef to go with zfuture macro\n;;\n\n(defn zat\n  \"Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through.\"\n  [options value]\n  #?(:clj (if (:parallel? options) (deref value) value)\n     :cljs value))\n\n;;\n;; # Debugging Assistance\n;;\n\n(def fzprint-dbg (atom nil))\n\n(defn log-lines\n  \"Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging.\"\n  [{:keys [dbg-print? dbg-indent in-hang?], :as options} dbg-output ind\n   style-vec]\n  (when dbg-print?\n    (if style-vec\n      (do (println dbg-indent dbg-output \"--------------\" \"in-hang?\" in-hang?)\n          (println (apply str (blanks ind) (map first style-vec))))\n      (println dbg-indent dbg-output \"--------------- no style-vec\"))))\n\n;;\n;; # What is a function?\n;;\n\n(defn showfn?\n  \"Show this thing as a function?\"\n  [fn-map f]\n  (when (not (string? f))\n    (let [f-str (str f)]\n      (or (fn-map f-str)\n          (re-find #\"clojure\" f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (re-find #\"clojure\"\n                              (str (:ns (meta #?(:clj (resolve f)\n                                                 :cljs f)))))\n                     (fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default) e\n                   nil)))))))\n\n(defn show-user-fn?\n  \"Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!\"\n  [options f]\n  (when (not (string? f))\n    (let [f-str (str f)\n          user-fn-map (:user-fn-map options)]\n      (or (get user-fn-map f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (not (empty? (str (:ns (meta #?(:clj (resolve f)\n                                                     :cljs f))))))\n                     (get user-fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default) e\n                   nil)))))))\n\n(def right-separator-map {\")\" 1, \"]\" 1, \"}\" 1})\n\n;;\n;; # Functions to compare alternative printing approaches\n;;\n\n(declare fix-rightcnt)\n(declare contains-nil?)\n\n(defn good-enough?\n  \"Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang.\"\n  [caller\n   {:keys [width rightcnt dbg?],\n    {:keys [hang-flow hang-type-flow hang-flow-limit general-hang-adjust\n            hang-if-equal-flow?]}\n      :tuning,\n    {:keys [hang-expand hang-diff hang-size hang-adjust]} caller,\n    :as options} fn-style p-count indent-diff\n   [p-lines p-maxwidth p-length-seq p-what] [b-lines b-maxwidth _ b-what]]\n  (let [p-last-maxwidth (last p-length-seq)\n        hang-diff (or hang-diff 0)\n        hang-expand (or hang-expand 1000.)\n        hang-adjust (or hang-adjust general-hang-adjust)\n        #_(options (if (and p-lines\n                            p-count\n                            (pos? p-count)\n                            (not (<= indent-diff hang-diff))\n                            (not (<= (/ (dec p-lines) p-count) hang-expand)))\n                     (assoc options :dbg? true)\n                     options))\n        options (if (or p-what b-what) (assoc options :dbg? true) options)\n        result\n          (if (not b-lines)\n            true\n            (and p-lines\n                 ; Does the last line fit, including the collection ending\n                 ; stuff?\n                 ; Do we really need this anymore?\n                 (<= p-last-maxwidth (- width (fix-rightcnt rightcnt)))\n                 ; Does it widest line fit?\n                 ; Do we have a problem if the widest line has a rightcnt?\n                 (<= p-maxwidth width)\n                 ;      (<= p-maxwidth (- width (fix-rightcnt rightcnt)))\n                 (or (zero? p-lines)\n                     (and ; do we have lines to operate on?\n                          (> b-lines 0)\n                          (> p-count 0)\n                          ; if the hang and the flow are the same size, why not\n                          ; hang?\n                          (if (and (= p-lines b-lines) hang-if-equal-flow?)\n                            true\n                            ; is the difference between the indents so small\n                            ; that\n                            ; we don't care?\n                            (and (if (<= indent-diff hang-diff)\n                                   true\n                                   ; Do the number of lines in the hang exceed\n                                   ; the number\n                                   ; of elements in the hang?\n                                   (<= (/ (dec p-lines) p-count) hang-expand))\n                                 (if hang-size (< p-lines hang-size) true)\n                                 (let [factor (if (= fn-style :hang)\n                                                hang-type-flow\n                                                hang-flow)]\n                                   ; if we have more than n lines, take the\n                                   ; shortest\n                                   (if (> p-lines hang-flow-limit)\n                                     (<= (dec p-lines) b-lines)\n                                     ; if we have less then n lines, we don't\n                                     ; necessarily\n                                     ; take the shortest\n                                     ; once we did (dec p-lines) here, fwiw\n                                     ; then we tried it w/out the dec, now we\n                                     ; let you\n                                     ; set it in :tuning.  The whole point of\n                                     ; having a\n                                     ; hang-adjust of -1 is to allow hangs when\n                                     ; the\n                                     ; number of lines in a hang is the same as\n                                     ; the\n                                     ; number of lines in a flow.\n                                     ;(< (/ p-lines b-lines) factor)))))))]\n                                     (< (/ (+ p-lines hang-adjust) b-lines)\n                                        factor)))))))))]\n    (dbg options\n         (if result \"++++++\" \"XXXXXX\")\n         \"p-what\" p-what\n         \"good-enough? caller:\" caller\n         \"fn-style:\" fn-style\n         \"width:\" width\n         \"rightcnt:\" rightcnt\n         \"hang-expand:\" hang-expand\n         \"p-count:\" p-count\n         \"p-lines:\" p-lines\n         \"p-maxwidth:\" p-maxwidth\n         \"indent-diff:\" indent-diff\n         \"hang-diff:\" hang-diff\n         \"p-last-maxwidth:\" p-last-maxwidth\n         \"b-lines:\" b-lines\n         \"b-maxwidth:\" b-maxwidth)\n    result))\n\n;;\n;; # Utility Functions\n;;\n\n(defn in-hang\n  \"Add :in-hang? true to the options map.\"\n  [options]\n  (if (:in-hang? options)\n    options\n    (if (:do-in-hang? options)\n      (assoc options :in-hang? (or (:depth options) true))\n      options)))\n\n(defn contains-nil?\n  \"Scan a collection, and return the number of nils or empty collections\n  present (if any), and nil otherwise.\"\n  [coll]\n  (let [n (count (filter #(if (coll? %) (empty? %) (nil? %)) coll))]\n    (when (not (zero? n)) n)))\n\n(defn concat-no-nil-alt\n  \"Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes.\"\n  [& rest]\n  (loop [coll rest\n         out (transient [])]\n    (let [c (first coll)]\n      (if-not c\n        (persistent! out)\n        (when (or (and (coll? c) (not (empty? c))) (not (nil? c)))\n          (recur (next coll) (conj! out c)))))))\n\n(defn concat-no-nil\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (nil? o) (reduced nil) (conj! v o))))\n                 (transient [])\n                 rest)]\n    (when result (persistent! result))))\n\n(defn force-vector\n  \"Ensure that whatever we have is a vector.\"\n  [coll]\n  (if (vector? coll) coll (into [] coll)))\n\n(defn keyword-fn?\n  \"Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map.\"\n  [options s]\n  (let [[left right] (clojure.string/split s #\"^:\")]\n    (when right ((:fn-map options) right))))\n\n;;\n;; # Work with style-vecs and analyze results\n;;\n\n;; Transients don't help here, though they don't hurt much either.\n\n(defn accumulate-ll\n  \"Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s\"\n  [count-comment? [out cur-len just-eol? just-comment? :as in] s tag eol?]\n  (let [comment? (or (= tag :comment) (= tag :comment-inline))\n        count-s (if (and comment? (not count-comment?)) 0 (count s))]\n    (cond\n      #_((and comment? (not just-eol?))\n          ; if a comment and we didn't just do\n          ; a newline, then terminate the previous\n          ; line and do a line just with the comment\n          (assoc in\n            0 (conj out cur-len count-s)\n            1 0\n            2 true))\n      ; if we are told to terminate the line or it\n      ; is a comment, we terminate the line with the\n      ; size of the string added to it\n      (or (and eol? (not (and just-eol? (zero? count-s)))) comment?)\n        [(conj out (+ cur-len count-s)) 0 true comment?]\n      ;(assoc in 0 (conj out (+ cur-len count-s)) 1 0 2 true 3 comment?)\n      ; no reason to terminate the line, just accumulate\n      ; the size in cur-len\n      :else [out (+ cur-len count-s) nil comment?])))\n; (assoc in 1 (+ cur-len count-s) 2 nil 3 comment?))))\n\n(defn generate-ll\n  [count-comment? [out cur-len just-eol? just-comment? :as in]\n   [s _ tag :as element]]\n  (let [[l r] (if (or (= tag :whitespace) (= tag :indent) (= tag :newline))\n                (split-lf-2 s)\n                #_(clojure.string/split s #\"\\n\" 2)\n                (list s))\n        ; if tag = :comment, shouldn't have \\n and\n        ; therefore shouldn't have r\n        ; if r is non-nil, then we had a newline, so we want to\n        ; terminate the current line\n        ; if we are already in a comment and we have something\n        ; that is not whitespace, then we want to terminate the\n        ; current line\n        in (accumulate-ll count-comment? in l tag (not (nil? r)))\n        in (if (empty? r) in (accumulate-ll count-comment? in r tag nil))]\n    in))\n\n\n(defn line-lengths-iter\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important.\"\n  [options ind style-vec]\n  (let [count-comment? (:count? (:comment options))\n        ind (if (coll? ind) (first ind) ind)]\n    (loop [next-vec style-vec\n           current-string nil\n           line-length ind\n           previous-comment? nil\n           out []]\n      (if (or (and (empty? next-vec) (empty? current-string)))\n        ; A trailing newline isn't counted.\n        (cond (and (zero? line-length) (not previous-comment?)) out\n              previous-comment? (conj out line-length 0)\n              :else (conj out line-length))\n        (let [advance? (empty? current-string)\n              [next-string _ tag] (when advance? (first next-vec))\n              comment? (or (= tag :comment) (= tag :comment-inline))\n              s (if advance? next-string current-string)\n              [l r] (when s\n                      ; if we have a current-string, then we are looking for\n                      ; newlines\n                      (cond (and comment? (not count-comment?)) [\"\"]\n                            (or (and advance?\n                                     (or (= tag :whitespace)\n                                         (= tag :newline)\n                                         (= tag :indent)))\n                                current-string)\n                              (split-lf-2 s)\n                            :else [s]))\n              ; If r non-nil, we had a newline at end of l.\n              ; If we had a previous-comment, then we want to\n              ; imply a newline unless we have a newline at the\n              ; start of s.\n              ; If r is non-nil, and l is empty, then the newline\n              ; was at the front of r, in which case we don't need to\n              ; do an implied newline for the comment (if any).\n              ; Choices:\n              ;  leave l and r alone\n              ;  l becomes nil and r is (str l r)\n              force-newline? (and previous-comment? (not (empty? l)))\n              #_(prn \"l:\" l\n                     \"r:\" r\n                     \"force-newline?\" force-newline?\n                     \"comment?\" comment?)\n              r (if force-newline? (str l r) r)\n              l (if force-newline? nil l)\n              new-line-length (+ line-length (count l))]\n          #_(prn \"current-string:\" current-string\n                 \"line-length:\" line-length\n                 \"advance?\" advance?\n                 \"s:\" s\n                 \"l:\" l\n                 \"r:\" r\n                 \"new-line-length:\" new-line-length)\n          (recur (if advance? (next next-vec) next-vec)\n                 r\n                 (if r 0 new-line-length)\n                 comment?\n                 (if r (conj out new-line-length) out)))))))\n\n(defn line-lengths\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character.\"\n  [options ind style-vec]\n  (let [length-vec\n          (first ; this final accumulate-ll is to terminate the last line,\n                 ; the one in progress\n                 (let [count-comment? (:count? (:comment options))\n                       [_ _ just-eol? just-comment? :as result]\n                         (reduce (partial generate-ll count-comment?)\n                           [[] (if (coll? ind) (first ind) ind) nil nil]\n                           style-vec)]\n                   (if (and just-eol? (not just-comment?))\n                     result\n                     (accumulate-ll count-comment?\n                                    (assoc result 2 nil)\n                                    \"\"\n                                    nil\n                                    true))))]\n    #_(prn \"line-lengths: style-vec:\" style-vec\n           \"ind:\" ind\n           \"length-vec:\" length-vec)\n    length-vec))\n\n(defn single-line?\n  \"This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one.\"\n  [style-vec]\n  #_(prn \"style-vec:\" style-vec)\n  (not (reduce #(or %1 %2)\n         false\n         (map #(clojure.string/includes? (first %) \"\\n\") style-vec))))\n\n(defn find-what\n  \"Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from.\"\n  [style-vec]\n  (loop [s-vec style-vec]\n    (when s-vec\n      (let [[what _ this] (first s-vec)]\n        (if (= this :element) what (recur (next s-vec)))))))\n\n; Debugging help to find differences between line-lengths and\n; line-lengths-iter.  Surprisingly helpful!\n#_(defonce lldiff (atom []))\n\n(defn style-lines\n  \"Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector.\"\n  [options ind style-vec]\n  (when (and style-vec (not (empty? style-vec)) (not (contains-nil? style-vec)))\n    (let [;lengths (line-lengths options ind style-vec)\n          lengths (line-lengths-iter options ind style-vec)\n          result [(count lengths) (apply max lengths) lengths]\n          dbg-ge (:dbg-ge options)\n          what (when (and dbg-ge (= (find-what style-vec) dbg-ge)) dbg-ge)]\n      #_(when (not= lengths lengths-iter) (swap! lldiff conj style-vec))\n      (if what (conj result what) result))))\n\n(defn fzfit\n  \"Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise.\"\n  [{:keys [width rightcnt dbg?], :as options}\n   [line-count max-width :as style-lines-return]]\n  (dbg options\n       \"fzfit: fixed-rightcnt:\" (fix-rightcnt rightcnt)\n       \"line-count:\" line-count\n       \"max-width:\" max-width\n       \"width:\" width)\n  (when style-lines-return\n    (if (<= max-width (- width (fix-rightcnt rightcnt))) line-count nil)))\n\n(defn fzfit-one-line\n  \"Given the return from style-lines  and options, \n  return true if it fits on a single line.\"\n  [options style-lines-return]\n  (let [lines (fzfit options style-lines-return)]\n    (and (number? lines) (= lines 1))))\n\n;;\n;; # Handle Rightmost Size\n;;\n\n(defn rightmost\n  \"Increase the rightmost count, if any, and return one if not.\"\n  [options]\n  (assoc options :rightcnt (inc (:rightcnt options 0))))\n\n(defn not-rightmost\n  \"Remove the rightmost count.\"\n  [options]\n  (dissoc options :rightcnt))\n\n(defn c-r-pair\n  \"Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!\"\n  [commas? rightmost-pair? rightmost? options]\n  (if-not rightmost?\n    (not-rightmost options)\n    (if rightmost-pair?\n      options\n      (if commas?\n        (rightmost (not-rightmost options))\n        (not-rightmost options)))))\n\n(defn fix-rightcnt\n  \"Handle issue with rightcnt.\"\n  [rightcnt]\n  (if (number? rightcnt) rightcnt 0))\n\n;;\n;; # First pass at color -- turn string or type into keyword color\n;;\n\n;;\n;; ## Translate from a string to a keyword as needed.\n;;\n\n(def str->key\n  {\"(\" :paren,\n   \")\" :paren,\n   \"[\" :bracket,\n   \"]\" :bracket,\n   \"{\" :brace,\n   \"}\" :brace,\n   \"#{\" :hash-brace,\n   \"#(\" :hash-paren,\n   \"#_\" :uneval,\n   \"'\" :quote,\n   \"`\" :quote,\n   \"~\" :quote,\n   \"~@\" :quote,\n   \"@\" :deref})\n\n\n(defn zcolor-map\n  \"Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings.\"\n  [{:keys [color-map], :as options} key-or-str]\n  (color-map (if (keyword? key-or-str) key-or-str (str->key key-or-str))))\n\n\n;;\n;; ## Pretty Printer Code\n;;\n\n(declare fzprint*)\n(declare fzprint-flow-seq)\n\n(defn hangflow\n  \"Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil.\"\n  [hangflow? hang-or-flow style-vec]\n  (when style-vec (if hangflow? [hang-or-flow style-vec] style-vec)))\n\n(defn fzprint-hang-unless-fail\n  \"Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time.\"\n  [options hindent findent fzfn zloc]\n  (dbg options \"fzprint-hang-unless-fail:\" (zstring (zfirst zloc)))\n  (let [hanging (fzfn (in-hang options) hindent zloc)]\n    (dbg-form\n      options\n      \"fzprint-hang-unless-fail: exit:\"\n      (if (and hanging (fzfit options (style-lines options hindent hanging)))\n        [:hang hanging]\n        ; hang didn't work, do flow\n        (do (dbg options \"fzprint-hang-unless-fail: hang failed, doing flow\")\n            [:flow\n             (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]]\n                            (fzfn options findent zloc))])))))\n\n(defn replace-color\n  \"Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct.\"\n  [local-color style-vec]\n  (if (= (count style-vec) 1)\n    (let [[[string color element]] style-vec] [[string local-color element]])\n    style-vec))\n\n(declare fzprint-binding-vec)\n(declare middle-element?)\n\n(defn fzprint-two-up\n  \"Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  This will return a\n  style-vec (or nil), unless hangflow? is true, in which case it\n  will return [:hang <style-vec>] or [:flow <style-vec>] so that\n  the upstream folks know whether this was a hang or flow and can\n  do the right thing based on that.\"\n  [caller\n   {:keys [one-line? dbg? dbg-indent in-hang? do-in-hang? map-depth],\n    {:keys [hang? dbg-local? dbg-cnt? indent indent-arg flow? key-color\n            key-depth-color key-value-color]}\n      caller,\n    :as options} ind commas? justify-width rightmost-pair?\n   [lloc rloc xloc :as pair]]\n  (if dbg-cnt? (println \"two-up: caller:\" caller \"hang?\" hang? \"dbg?\" dbg?))\n  (if (or dbg? dbg-local?)\n    (println (or dbg-indent \"\")\n             \"==========================\" (str \"\\n\" (or dbg-indent \"\"))\n             \"fzprint-two-up:\" (zstring lloc)\n             \"caller:\" caller\n             \"count:\" (count pair)\n             \"ind:\" ind\n             \"indent:\" indent\n             \"indent-arg:\" indent-arg\n             \"justify-width:\" justify-width\n             \"one-line?:\" one-line?\n             \"hang?:\" hang?\n             \"in-hang?\" in-hang?\n             \"do-in-hang?\" do-in-hang?\n             \"flow?\" flow?\n             \"commas?\" commas?\n             \"rightmost-pair?\" rightmost-pair?))\n  (let [local-hang? (or one-line? hang?)\n        indent (or indent indent-arg)\n        local-options\n          (if (not local-hang?) (assoc options :one-line? true) options)\n        loptions (c-r-pair commas? rightmost-pair? nil options)\n        roptions (c-r-pair commas? rightmost-pair? :rightmost options)\n        local-roptions\n          (c-r-pair commas? rightmost-pair? :rightmost local-options)\n        ; If we have a key-value-color map, and the key we have matches any\n        ; of the keys in the map, then merge the resulting color-map elements\n        ; into the current color-map.  Could be problematic if lloc is a\n        ; modifier, but at present modifiers are only for extend and\n        ; key-value-color is only for maps, so they can't both show up\n        ; at once.\n        value-color-map (and key-value-color (key-value-color (zsexpr lloc)))\n        local-roptions (if value-color-map\n                         (merge-deep local-roptions\n                                     {:color-map value-color-map})\n                         local-roptions)\n        roptions (if value-color-map\n                   (merge-deep roptions {:color-map value-color-map})\n                   roptions)\n        ; It is possible that lloc is a modifier, and if we have exactly\n        ; three things, we will pull rloc in with it, and move xloc to rloc.\n        ; If it is just two, we'll leave it to be handled normally.\n        ; Which might need to be re-thought due to justification, but since\n        ; we are really only talking :extend here, maybe not.\n        modifier-set (:modifiers (options caller))\n        modifier? (or (and modifier-set\n                           (modifier-set (zstring lloc))\n                           (> (count pair) 2))\n                      (middle-element? options rloc))\n        ; Figure out if we want to color keys based on their depth, and if so,\n        ; figure out the color for this one.\n        local-color (get key-depth-color (dec map-depth))\n        ; Doesn't work if we have a modifier, but at this point, key-color\n        ; is only for maps and modifiers are only for extend.\n        local-color (if key-color (key-color (zsexpr lloc)) local-color)\n        #_local-color\n        #_(cond (and map-depth (= caller :map) (= map-depth 2)) :green\n                (and map-depth (= caller :map) (= map-depth 1)) :blue\n                (and map-depth (= caller :map) (= map-depth 3)) :yellow\n                (and map-depth (= caller :map) (= map-depth 4)) :red\n                :else nil)\n        arg-1 (fzprint* loptions ind lloc)\n        arg-1 (if local-color (replace-color local-color arg-1) arg-1)\n        ; If we are going to print the second thing on the line, we need\n        ; to know how big the first thing is, so we can see if the second\n        ; thing fits on the line.\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (style-lines options ind arg-1)\n        ; If arg-1 already takes multiple lines, we aren't going to do\n        ; anything interesting with a modifier.\n        _ (dbg options\n               \"fzprint-two-up before modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        modifier?\n          (if (and arg-1-line-count (> arg-1-line-count 1)) nil modifier?)\n        ; See if we can merge the first and second things and have them\n        ; stay on the same line?\n        combined-arg-1 (if modifier?\n                         (concat-no-nil arg-1\n                                        [[(str \" \") :none :whitespace]]\n                                        (fzprint* (in-hang loptions)\n                                                  (+ ind arg-1-max-width)\n                                                  rloc))\n                         arg-1)\n        ; If they fit, then they are the new arg-1\n        arg-1 (if combined-arg-1 combined-arg-1 arg-1)\n        ; If they fit, then we are still doing modifier if we are already\n        modifier? (if combined-arg-1 modifier? nil)\n        ; If they fit, we need to recalculate the size of arg-1\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (if combined-arg-1 (style-lines options ind arg-1) arg-1-lines)\n        _ (dbg options\n               \"fzprint-two-up after modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        lloc (if modifier? rloc lloc)\n        rloc (if modifier? xloc rloc)\n        ;     arg-1-fit-oneline? (and (not force-nl?)\n        ;                             (fzfit-one-line loptions arg-1-lines))\n        arg-1-fit-oneline? (and (not flow?)\n                                (fzfit-one-line loptions arg-1-lines))\n        arg-1-fit? (or arg-1-fit-oneline?\n                       (when (not one-line?) (fzfit loptions arg-1-lines)))\n        ; sometimes arg-1-max-width is nil because fzprint* returned nil,\n        ; but we need to have something for later code to use as a number\n        arg-1-width (- (or arg-1-max-width 0) ind)]\n    ; If we don't *have* an arg-1, no point in continuing...\n    ;  If arg-1 doesn't fit, maybe that's just how it is!\n    ;  If we are in-hang, then we can bail, but otherwise, not.\n    (when (and arg-1 (or arg-1-fit? (not in-hang?)))\n      (cond\n        (= (count pair) 1) [:hang (fzprint* roptions ind lloc)]\n        (or (= (count pair) 2) (and modifier? (= (count pair) 3)))\n          ;concat-no-nil\n          ;  arg-1\n          ; We used to think:\n          ; We will always do hanging, either fully or with one-line? true,\n          ; we will then do flow if hanging didn't do anything or if it did,\n          ; we will try to see if flow is better.\n          ;\n          ; But now, we don't do hang if arg-1-fit-oneline? is false, since\n          ; we won't use it.\n          (let [hanging-width (if justify-width justify-width arg-1-width)\n                hanging-spaces\n                  (if justify-width (inc (- justify-width arg-1-width)) 1)\n                hanging-indent (+ 1 hanging-width ind)\n                flow-indent (+ indent ind)]\n            (if (and (zstring lloc)\n                     (keyword-fn? options (zstring lloc))\n                     (zvector? rloc))\n              ; This is an embedded :let or :when-let or something\n              ; Presently we assume that anything with a vector after something\n              ; that is a keyword must be one of these, but we could check\n              ; for a :binding fn-style instead which might make more sense.\n              (let [[hang-or-flow style-vec] (fzprint-hang-unless-fail\n                                               loptions\n                                               hanging-indent\n                                               flow-indent\n                                               fzprint-binding-vec\n                                               rloc)\n                    arg-1 (if (= hang-or-flow :hang)\n                            (concat-no-nil arg-1\n                                           [[(blanks hanging-spaces) :none\n                                             :whitespace]])\n                            arg-1)]\n                [hang-or-flow (concat-no-nil arg-1 style-vec)])\n              ; This is a normal two element pair thing\n              (let [; Perhaps someday we could figure out if we are already\n                    ; completely in flow to this point, and be smarter about\n                    ; possibly dealing with the hang or flow now.  But for\n                    ; now, we will simply do hang even if arg-1 didn't fit\n                    ; on one line if the flow indent isn't better than the\n                    ; hang indent.\n                    _ (dbg options\n                           \"fzprint-two-up: before hang.  hanging tried?\"\n                           (and arg-1-fit-oneline?\n                                (and (not flow?)\n                                     (>= flow-indent hanging-indent))))\n                    hanging (when (or arg-1-fit-oneline?\n                                      (and (not flow?)\n                                           (>= flow-indent hanging-indent)))\n                              (fzprint* (if (< flow-indent hanging-indent)\n                                          (in-hang local-roptions)\n                                          local-roptions)\n                                        hanging-indent\n                                        rloc))\n                    hang-count (zcount rloc)\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging:\"\n                                 hanging-indent\n                                 hanging)\n                    hanging-lines (style-lines options hanging-indent hanging)\n                    fit? (fzfit-one-line local-roptions hanging-lines)\n                    hanging-lines (if fit?\n                                    hanging-lines\n                                    (when (and (not one-line?) hang?)\n                                      hanging-lines))\n                    ; Don't flow if it fit, or it didn't fit and we were doing\n                    ; one line on input.  Do flow if we don't have\n                    ; hanging-lines\n                    ; and we were not one-line on input.\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging-2:\"\n                                 hanging-indent\n                                 hanging)\n                    flow-it? (and (or (and (not hanging-lines) (not one-line?))\n                                      (not (or fit? one-line?)))\n                                  ; this is for situations where the first\n                                  ; element is short and so the hanging indent\n                                  ; is the same as the flow indent, so there\n                                  ; is\n                                  ; no point in flow -- unless we don't have\n                                  ; any hanging-lines, in which case we better\n                                  ; do flow\n                                  (or (< flow-indent hanging-indent)\n                                      (not hanging-lines)))\n                    _ (dbg options\n                           \"fzprint-two-up: before flow. flow-it?\"\n                           flow-it?)\n                    flow (when flow-it? (fzprint* roptions flow-indent rloc))\n                    _ (log-lines options\n                                 \"fzprint-two-up: flow:\"\n                                 (+ indent ind)\n                                 flow)\n                    flow-lines (style-lines options (+ indent ind) flow)]\n                (when dbg-local?\n                  (prn \"fzprint-two-up: local-hang:\" local-hang?)\n                  (prn \"fzprint-two-up: one-line?:\" one-line?)\n                  (prn \"fzprint-two-up: hanging-indent:\" hanging-indent)\n                  (prn \"fzprint-two-up: hanging-lines:\" hanging-lines)\n                  (prn \"fzprint-two-up: flow?:\" flow?)\n                  (prn \"fzprint-two-up: flow-it?:\" flow-it?)\n                  (prn \"fzprint-two-up: fit?:\" fit?)\n                  (prn \"fzprint-two-up: flow-indent:\" flow-indent)\n                  (prn \"fzprint-two-up: hanging:\" (zstring lloc) hanging)\n                  (prn \"fzprint-two-up: (+ indent ind):\" (+ indent ind))\n                  (prn \"fzprint-two-up: flow:\" (zstring lloc) flow))\n                (dbg options \"fzprint-two-up: before good-enough\")\n                (if fit?\n                  [:hang\n                   (concat-no-nil arg-1\n                                  [[(blanks hanging-spaces) :none :whitespace]]\n                                  hanging)]\n                  (when (or hanging-lines flow-lines)\n                    (if (good-enough? caller\n                                      roptions\n                                      :none-two-up\n                                      hang-count\n                                      (- hanging-indent flow-indent)\n                                      hanging-lines\n                                      flow-lines)\n                      [:hang\n                       (concat-no-nil arg-1\n                                      [[(blanks hanging-spaces) :none\n                                        :whitespace]]\n                                      hanging)]\n                      (if justify-width\n                        nil\n                        [:flow\n                         (concat-no-nil arg-1\n                                        [[(str \"\\n\" (blanks (+ indent ind)))\n                                          :none :indent]]\n                                        flow)])))))))\n        :else [:flow ; The following always flows things of 3 or more\n               ; (absent modifers).  If the lloc is a single char,\n               ; then that can look kind of poor.  But that case\n               ; is rare enough that it probably isn't worth dealing\n               ; with.  Possibly a hang-remaining call might fix it.\n               (concat-no-nil\n                 arg-1\n                 #_(fzprint* loptions ind lloc)\n                 [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                 ; This is a real seq, not a zloc seq\n                 #_(fzprint-remaining-seq options\n                                          (+ indent ind)\n                                          nil\n                                          :force-nl\n                                          (next pair))\n                 (fzprint-flow-seq options\n                                   (+ indent ind)\n                                   (if modifier? (nnext pair) (next pair))\n                                   :force-nl))]))))\n\n;;\n;; # Two-up printing\n;;\n\n(defn fzprint-justify-width\n  \"Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line.\"\n  [caller {{:keys [justify?]} caller, :as options} ind coll]\n  (let [firsts (remove nil?\n                 (map #(when (> (count %) 1) (fzprint* options ind (first %)))\n                   coll))\n        #_(def just firsts)\n        style-seq (map (partial style-lines options ind) firsts)\n        #_(def styleseq style-seq)\n        each-one-line? (reduce #(when %1 (= (first %2) 1)) true style-seq)\n        #_(def eol each-one-line?)\n        justify-width (when each-one-line?\n                        (reduce #(max %1 (second %2)) 0 style-seq))]\n    (when justify-width (- justify-width ind))))\n\n(defn fit-within?\n  \"Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size.\"\n  ([size coll depth]\n   (reduce (fn [size element]\n             (or (if (= depth 0)\n                   (fit-within? size element (inc depth))\n                   (let [remaining (- size (count (zstring element)))]\n                     (when (pos? remaining) remaining)))\n                 (reduced nil)))\n     size\n     coll))\n  ([size coll] (fit-within? size coll 0)))\n\n(defn remove-hangflow\n  \"Convert a hangflow style-vec to a regular style-vec.\"\n  [hf-style-vec]\n  (when hf-style-vec (map second hf-style-vec)))\n\n(defn fzprint-map-two-up\n  \"Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil.\"\n  [caller\n   {{:keys [justify? force-nl?]} caller,\n    :keys [width rightcnt one-line? parallel?],\n    :as options} ind commas? coll]\n  (let [caller-map (caller options)\n        len (count coll)\n        justify-width (when (and justify? (not one-line?))\n                        (fzprint-justify-width caller options ind coll))\n        caller-options (when justify-width (options caller))]\n    (dbg-print options\n               \"fzprint-map-two-up: one-line?\" (:one-line? options)\n               \"justify?:\" justify?)\n    ; If it is one-line? and force-nl? and there is more than one thing,\n    ; this can't work.\n    (when (not (and one-line? force-nl? (> len 1)))\n      #_(def jo [])\n      (loop [justify-width justify-width\n             justify-options\n               (if justify-width\n                 (-> options\n                     (merge-deep {caller (caller-options :justify-hang)})\n                     (merge-deep {:tuning (caller-options :justify-tuning)}))\n                 options)]\n        #_(def jo (conj jo [justify-width justify-options]))\n        (let [beginning-coll (butlast coll)\n              beginning-remaining\n                (if one-line? (fit-within? (- width ind) beginning-coll) true)\n              _ (dbg options\n                     \"fzprint-map-two-up: remaining:\" (- width ind)\n                     \"beginning-remaining:\" beginning-remaining)\n              ;\"(butlast coll):\" (butlast coll))\n              beginning (when beginning-remaining\n                          (zpmap options\n                                 (partial fzprint-two-up\n                                          caller\n                                          justify-options\n                                          ind\n                                          commas?\n                                          justify-width\n                                          nil)\n                                 beginning-coll))\n              ; this line will fix the justify, but not necessarily\n              ; the rest of the problems with hangflow output -- like\n              ; the style-lines below.\n              beginning (if (contains-nil? beginning) nil beginning)\n              end-coll [(last coll)]\n              end-remaining (if one-line?\n                              (and beginning\n                                   (fit-within? (- beginning-remaining rightcnt)\n                                                end-coll))\n                              true)\n              _ (dbg options\n                     \"fzprint-map-two-up: beginning-remaining:\"\n                       beginning-remaining\n                     \"rightcnt:\" rightcnt\n                     \"end-remaining:\" end-remaining)\n              ;\"(last coll):\" (last coll))\n              end (when end-remaining\n                    (when-let [end-result (fzprint-two-up caller\n                                                          justify-options\n                                                          ind\n                                                          commas?\n                                                          justify-width\n                                                          :rightmost-pair\n                                                          (first end-coll))]\n                      [end-result]))\n              result (cond (= len 1) end\n                           :else (concat-no-nil beginning end))]\n          (dbg options\n               \"fzprint-map-two-up: len:\" len\n               \"(nil? end):\" (nil? end)\n               \"end:\" end\n               \"(nil? beginning):\" (nil? beginning)\n               \"beginning:\" beginning\n               \"(count end):\" (count end)\n               \"(count beginnging):\" (count beginning)\n               \"justify-width:\" justify-width\n               \"result:\" result)\n          ; if we got a result or we didn't but it wasn't because we\n          ; were trying to justify things\n          (if (or result (not justify-width))\n            result\n            ; try again, without justify-width\n            (recur nil options)))))))\n\n;;\n;; ## Support sorting of map keys\n;;\n\n(defn compare-keys\n  \"Do a key comparison that works well for numbers as well as\n  strings.\"\n  [x y]\n  (cond (and (number? x) (number? y)) (compare x y)\n        :else (compare (str x) (str y))))\n\n(defn compare-ordered-keys\n  \"Do a key comparison that places ordered keys first.\"\n  [key-value zdotdotdot x y]\n  (cond (and (key-value x) (key-value y)) (compare (key-value x) (key-value y))\n        (key-value x) -1\n        (key-value y) +1\n        (= zdotdotdot x) +1\n        (= zdotdotdot y) -1\n        :else (compare-keys x y)))\n\n(defn order-out\n  \"A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing.\"\n  [caller\n   {{:keys [sort? sort-in-code? key-order key-value]} caller,\n    :keys [in-code?],\n    :as options} access out]\n  (if (and sort? (if in-code? sort-in-code? true))\n    (sort #((partial compare-ordered-keys (or key-value {}) (zdotdotdot))\n             (zsexpr (access %1))\n             (zsexpr (access %2)))\n          out)\n    out))\n\n(defn pair-element?\n  \"This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this.\"\n  [zloc]\n  (or (zcomment? zloc) (zuneval? zloc)))\n\n(defn middle-element?\n  \"This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element.\"\n  [{:keys [in-code?], :as options} zloc]\n  ;  nil)\n  (when (= in-code? \"condp\") (= (zstring zloc) \":>>\")))\n\n;;\n;; # Ignore keys in maps\n;;\n\n(defn remove-key-seq\n  \"If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one.\"\n  [m ks]\n  (if (coll? ks)\n    (let [this-key (first ks)\n          next-key (next ks)]\n      (if next-key\n        (let [removed-map (remove-key-seq (get m this-key) (next ks))]\n          (if (empty? removed-map)\n            (dissoc m this-key)\n            (assoc m this-key removed-map)))\n        (dissoc m this-key)))\n    (dissoc m ks)))\n\n(defn ignore-key-seq-silent\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (remove-key-seq m ks))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found) m (dissoc m ks))))\n\n(defn ignore-key-seq\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc-in m ks :zprint-ignored))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc m ks :zprint-ignored))))\n\n(defn map-ignore\n  \"Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers.\"\n  [caller {{:keys [key-ignore key-ignore-silent]} caller, :as options} zloc]\n  (let [ignored-silent (if key-ignore-silent\n                         (reduce ignore-key-seq-silent zloc key-ignore-silent)\n                         zloc)\n        ignored (if key-ignore\n                  (reduce ignore-key-seq ignored-silent key-ignore)\n                  ignored-silent)]\n    ignored))\n\n;;\n;; # Pre-processing for two-up printing\n;;\n\n(defn partition-all-2-nc\n  \"Input is (zseqnws zloc) where one assumes that these are pairs.\n  Thus, a seq of zlocs.  Output is a sequence of seqs, where the\n  seqs are usually pairs, but might be single things.  Doesn't pair\n  up comments or #_(...) unevaled sexpressions.  The ones before\n  the first part of a pair come as a single element in what would\n  usually be a pair, and the ones between the first and second parts\n  of a pair come inside the pair.  There may be an arbitrary number\n  of elements between the first and second elements of the pair\n  (one per line).  If there are any comments or unevaled sexpressions,\n  don't sort the keys, as we might lose track of where the comments\n  or unevaled s-expressions go.\"\n  [{:as options, :keys [max-length]} coll]\n  (when-not (empty? coll)\n    (loop [remaining coll\n           no-sort? nil\n           index 0\n           out (transient [])]\n      (if-not remaining\n        [no-sort? (persistent! out)]\n        (let [[new-remaining pair-vec new-no-sort?]\n                (cond\n                  (pair-element? (first remaining)) [(next remaining)\n                                                     [(first remaining)] true]\n                  (or (pair-element? (second remaining))\n                      (middle-element? options (second remaining)))\n                    (let [[comment-seq rest-seq]\n                            ;(split-with pair-element? (next remaining))\n                            (split-with #(or (pair-element? %)\n                                             (middle-element? options %))\n                                        (next remaining))]\n                      [(next rest-seq)\n                       (into []\n                             (concat [(first remaining)]\n                                     comment-seq\n                                     [(first rest-seq)])) true])\n                  (= (count remaining) 1) [(next remaining) [(first remaining)]\n                                           nil]\n                  :else [(next (next remaining))\n                         [(first remaining) (second remaining)] nil])]\n          (recur (if (not= index max-length) new-remaining (list (zdotdotdot)))\n                 (or no-sort? new-no-sort?)\n                 (inc index)\n                 (conj! out pair-vec)))))))\n\n;;\n;; ## Multi-up printing pre-processing\n;;\n\n(defn cleave-end\n  \"Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq.\"\n  [coll]\n  (if (or (zsymbol? (first coll)) (zreader-cond-w-symbol? (first coll)))\n    ;(symbol? (first coll))\n    (list coll)\n    (let [rev-seq (reverse coll)\n          [split-non-coll _]\n            ;(split-with (comp not zcoll?) rev-seq)\n            (split-with #(not (or (zcoll? %) (zreader-cond-w-coll? %)))\n                        rev-seq)\n          #_(def sncce split-non-coll)\n          split-non-coll (map list (reverse split-non-coll))\n          remainder (take (- (count coll) (count split-non-coll)) coll)]\n      (if (empty? remainder)\n        split-non-coll\n        (concat (list remainder) split-non-coll)))))\n\n(defn partition-all-sym\n  \"Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things\"\n  [options modifier-set coll]\n  #_(prn \"partition-all-sym-static:\" modifier-set)\n  #_(def scoll coll)\n  (dbg options \"partition-all-sym: coll:\" (map zstring coll))\n  (let [part-sym (partition-by\n                   #(or (zsymbol? %) (znil? %) (zreader-cond-w-symbol? %))\n                   coll)\n        split-non-coll (mapcat cleave-end part-sym)]\n    #_(def ps part-sym)\n    #_(def snc split-non-coll)\n    (loop [remaining split-non-coll\n           out (transient [])]\n      #_(prn \"remaining:\" remaining)\n      #_(prn \"out:\" out)\n      ;(prn \"remaining:\" (map (comp zstring first) remaining))\n      ;(prn \"out:\" (map (comp zstring first) out))\n      (if (empty? remaining)\n        (persistent! out)\n        (let [[next-remaining new-out]\n                (cond\n                  (and (or (zsymbol? (ffirst remaining))\n                           (znil? (ffirst remaining))\n                           (zreader-cond-w-symbol? (ffirst remaining)))\n                       (not (empty? (second remaining))))\n                    ; We have a non-collection in (first remaining) and\n                    ; we might have more than one, either because we just\n                    ; have a bunch of non-colls with no colls\n                    ; or because we have a modifier and then one or more\n                    ; non-colls (possibly with their own modifiers).\n                    (if (= (count (first remaining)) 1)\n                      ; original\n                      (do #_(prn \"a:\")\n                          ; We have a single non-coll, pull the next seq\n                          ; of one or more seqs into a seq with it.\n                          ; This is where we marry up the non-coll with\n                          ; all of its associated colls.\n                          [(nthnext remaining 2)\n                           (conj! out\n                                  (concat (first remaining)\n                                          (second remaining)))])\n                      (do #_(prn \"b:\")\n                          (if (and modifier-set\n                                   (modifier-set (zstring (ffirst remaining))))\n                            (if (= (count (first remaining)) 2)\n                              ; We have exactly two things in\n                              ; (first remaining), and the first one is\n                              ; both a non-coll and a modifier, so we know\n                              ; that the second one is a non-coll, and we\n                              ; know that we have a (second remaining) from\n                              ; above, so we bring the second remaining\n                              ; into the first remaining like we did\n                              ; above\n                              (do #_(prn \"d:\")\n                                  [(nthnext remaining 2)\n                                   (conj! out\n                                          (concat (first remaining)\n                                                  (second remaining)))])\n                              ; We have a modifier as the first thing in a\n                              ; seq of non-colls and then some more non-colls\n                              ; after that (since we don't have exactly two,\n                              ; as that case was caught above).\n                              ; Pull the next one into a seq with it.\n                              ; Do we need to check that the next one is\n                              ; also a non-coll?  That shouldn't be\n                              ; necessary,as you won't get colls in\n                              ;with non-colls.\n                              (do #_(prn \"c:\")\n                                  [(if (next (next (first remaining)))\n                                     (cons (next (next (first remaining)))\n                                           (next remaining))\n                                     (next remaining))\n                                   (conj! out\n                                          (list (ffirst remaining)\n                                                (second (first remaining))))]))\n                            ; we have more than one non-coll in first\n                            ; remaining, so pull one out, and leave the\n                            ; next ones for the next loop\n                            [(cons (next (first remaining)) (next remaining))\n                             (conj! out (list (ffirst remaining)))])))\n                  :else [(next remaining) (conj! out (first remaining))])]\n          (recur next-remaining new-out))))))\n\n(defn rstr-vec\n  \"Create an r-str-vec with, possibly, a newline at the beginning if\n  the last thing before it is a comment.\"\n  ([options ind zloc r-str r-type]\n   (let [nl (when (zcomment? (zlast zloc))\n              [[(str \"\\n\" (blanks ind)) :none :indent]])]\n     (concat nl\n             [[r-str (zcolor-map options (or r-type r-str))\n               (or r-type :right)]])))\n  ([options ind zloc r-str] (rstr-vec options ind zloc r-str nil)))\n\n(defn fzprint-binding-vec\n  [{{:keys [nl-separator?]} :binding, :as options} ind zloc]\n  (dbg options \"fzprint-binding-vec:\" (zstring (zfirst zloc)))\n  (let [options (rightmost options)\n        l-str \"[\"\n        r-str \"]\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (inc ind) zloc r-str)]\n    (dbg-form options\n              \"fzprint-binding-vec exit:\"\n              (if (= (zcount zloc) 0)\n                (concat-no-nil l-str-vec r-str-vec)\n                (concat-no-nil\n                  l-str-vec\n                  (interpose-nl-hf\n                    (:binding options)\n                    (inc ind)\n                    (fzprint-map-two-up\n                      :binding\n                      options\n                      (inc ind)\n                      false\n                      (second (partition-all-2-nc options (zseqnws zloc)))))\n                  r-str-vec)))))\n\n(defn fzprint-hang\n  \"Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input.  For instance,\n  fzprint-pairs does a (zmap-right identity zloc).  Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc).\"\n  [{:keys [one-line?], :as options} caller hindent findent fzfn zloc-count zloc]\n  (dbg options \"fzprint-hang:\" (zstring (zfirst zloc)) \"caller:\" caller)\n  (let [hanging (when (and (not= hindent findent) ((options caller) :hang?))\n                  (concat-no-nil [[(str \" \") :none :whitespace]]\n                                 (fzfn (in-hang options) hindent zloc)))\n        hang-count (or zloc-count (zcount zloc))\n        hr-lines (style-lines options (dec hindent) hanging)\n        ;flow (fzfn options findent zloc)\n        ]\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]]\n                                (fzfn options findent zloc))\n            _ (log-lines options \"fzprint-hang: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg options\n                   \"fzprint-hang: ending: hang-count:\" hang-count\n                   \"hanging:\" hanging\n                   \"flow:\" flow)\n            hr-good? (when (:hang? (caller options))\n                       (good-enough? caller\n                                     options\n                                     :none-hang\n                                     hang-count\n                                     (- hindent findent)\n                                     hr-lines\n                                     fd-lines))]\n        (if hr-good? hanging flow)))))\n\n(defn fzprint-pairs\n  \"Always prints pairs on a different line from other pairs.\"\n  [{{:keys [nl-separator?]} :pair, :as options} ind zloc]\n  (dbg options \"fzprint-pairs:\" (zstring (zfirst zloc)))\n  (dbg-form\n    options\n    \"fzprint-pairs: exit:\"\n    (interpose-nl-hf\n      (:pair options)\n      ind\n      (fzprint-map-two-up\n        :pair\n        options\n        ind\n        false\n        (let [[_ part] (partition-all-2-nc options (zmap-right identity zloc))]\n          #_(def fp part)\n          (dbg options\n               \"fzprint-pairs: partition:\"\n               (map (comp zstring first) part))\n          part)))))\n\n(defn fzprint-extend\n  \"Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. This skips over zloc and does everything to the\n  right of it!\"\n  [{{:keys [nl-separator?]} :extend, :as options} ind zloc]\n  #_(def fezloc zloc)\n  (dbg options \"fzprint-extend:\" (zstring (zfirst zloc)))\n  (dbg-form\n    options\n    \"fzprint-extend: exit:\"\n    (interpose-nl-hf\n      (:extend options)\n      ind\n      (fzprint-map-two-up\n        :extend\n        (assoc options :fn-style :fn)\n        ind\n        false\n        (let [part (partition-all-sym options\n                                      (:modifiers (:extend options))\n                                      (zmap-right identity zloc))]\n          #_(def fe part)\n          (dbg options \"fzprint-extend: partition:\" (map #(map zstring %) part))\n          part)))))\n\n(defn concatv!\n  \"Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v.\"\n  [v & rest]\n  (loop [cols rest\n         out v]\n    (if cols\n      (recur (next cols)\n             (loop [col (first cols)\n                    out out]\n               (if col (recur (next col) (conj! out (first col))) out)))\n      out)))\n\n(defn fzprint-one-line\n  \"Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil.\"\n  [options ind zloc]\n  (dbg-print options \"fzprint-one-line:\")\n  (let [seq-right (zmap identity zloc)\n        len (count seq-right)\n        last-index (dec len)\n        gt-1? (> (count seq-right) 1)\n        options (assoc options :one-line? true)]\n    (loop [zloc-seq seq-right\n           new-ind (long ind)\n           index 0\n           out (transient [])]\n      (if (empty? zloc-seq)\n        (do (dbg options \"fzprint-one-line: exiting count:\" (count out))\n            (persistent! out))\n        (let [next-zloc (first zloc-seq)\n              [sep next-options]\n                (cond ; this needs to come first in case there\n                      ; is only one\n                      ; element in the list -- it needs to have\n                      ; the rightcnt\n                      ; passed through\n                      (= index last-index) [(if-not (zero? index)\n                                              [[\" \" :none :whitespace]])\n                                            options]\n                      (= index 0) [nil (not-rightmost options)]\n                      :else [[[\" \" :none :whitespace]] (not-rightmost options)])\n              next-out (fzprint* next-options new-ind next-zloc)\n              _ (log-lines options \"fzprint-one-line:\" new-ind next-out)\n              [line-count max-width :as next-lines]\n                (style-lines options new-ind next-out)]\n          (if-not (fzfit-one-line next-options next-lines)\n            (do (dbg options\n                     \"fzprint-one-line: failed, too wide or too many lines!\")\n                nil)\n            (recur (next zloc-seq)\n                   (inc (long max-width))\n                   (inc index)\n                   (concatv! out sep next-out))))))))\n\n(defn fzprint-seq\n  \"Take a seq of a zloc, created by (zmap identity zloc) when zloc\n  is a collection, or (zmap-right identity zloc) when zloc is already\n  inside of a collection, and return a seq of the fzprint* of each \n  element.  No spacing between any of these elements. Note that this\n  is not a style-vec, but a seq of style-vecs of each of the elements.\n  These would need to be concatenated together to become a style-vec.\n  ind is either a constant or a seq of indents, one for each element in\n  zloc-seq.\"\n  [{:keys [max-length], :as options} ind zloc-seq]\n  (let [len (count zloc-seq)\n        zloc-seq (if (> len max-length)\n                   (concat (take max-length zloc-seq) (list (zdotdotdot)))\n                   zloc-seq)]\n    (dbg options \"fzprint-seq: (count zloc-seq):\" len)\n    (when-not (empty? zloc-seq)\n      (let [left (zpmap options\n                        #(fzprint* (not-rightmost options) %1 %2)\n                        (if (coll? ind) ind (repeat ind))\n                        (butlast zloc-seq))\n            right [(fzprint* options\n                             (if (coll? ind) (last ind) ind)\n                             (last zloc-seq))]]\n        (cond (= len 1) right\n              :else (concat-no-nil left right))))))\n\n(defn fzprint-flow-seq\n  \"Take a seq of a zloc, created by (zmap identity zloc) or\n  and return a style-vec of the result.  Either it fits on one line, \n  or it is rendered on multiple lines.  You can force multiple lines \n  with force-nl?. If you want it to do less than everything in the \n  original zloc, modify the result of (zmap identity zloc) to just \n  contain what you want to print. ind is either a single indent,\n  or a seq of indents, one for each element in zloc-seq.\"\n  ([options ind zloc-seq force-nl?]\n   (dbg options \"fzprint-flow-seq: count zloc-seq:\" (count zloc-seq))\n   (let [coll-print (fzprint-seq options ind zloc-seq)\n         one-line (apply concat-no-nil\n                    (interpose [[\" \" :none :whitespace]] coll-print))\n         _ (log-lines options \"fzprint-flow-seq:\" ind one-line)\n         one-line-lines (style-lines options ind one-line)]\n     (dbg-form\n       options\n       \"fzprint-flow-seq: exit:\"\n       (if (and (not force-nl?) (fzfit-one-line options one-line-lines))\n         one-line\n         (apply concat-no-nil\n           (if (coll? ind)\n             (drop 1\n                   (interleave\n                     (map #(vector [(str \"\\n\" (blanks %)) :none :indent]) ind)\n                     coll-print))\n             (interpose [[(str \"\\n\" (blanks ind)) :none :indent]]\n               coll-print)))))))\n  ([options ind zloc-seq] (fzprint-flow-seq options ind zloc-seq nil)))\n\n\n(defn fzprint-hang-one\n  \"Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn.\"\n  [caller {:keys [one-line?], :as options} hindent findent zloc]\n  (dbg options \"fzprint-hang-one: hindent:\" hindent \"findent:\" findent)\n  (when (:dbg-hang options)\n    (println (dots (:pdepth options))\n             \"h1 caller:\"\n             caller\n             (zstring (if (zcoll? zloc) (zfirst zloc) zloc))))\n  (let [local-options (if (and (not one-line?) (not (:hang? (caller options))))\n                        (assoc options :one-line? true)\n                        options)\n        hanging (when (not= hindent findent)\n                  (fzprint* (in-hang local-options) hindent zloc))\n        hang-count (zcount zloc)\n        hanging (concat-no-nil [[\" \" :none :whitespace]] hanging)\n        _ (log-lines options \"fzprint-hang-one: hanging:\" (dec hindent) hanging)\n        hr-lines (style-lines options (dec hindent) hanging)]\n    _\n    (dbg options\n         \"fzprint-hang-one: hr-lines:\" hr-lines\n         \"hang-count:\" hang-count)\n    ; if hanging is nil and one-line? is true, then we didn't fit\n    ; and should exit\n    ;\n    ; if hanging is nil and one-line? is nil, and hang? nil,\n    ; then we we don't hang and this didn't fit on the same\n    ; line and we should contine\n    ;\n    ; if hanging is true, then if one-line? is true and fzfit-one-line\n    ; is true, then we just go with hanging\n    ;\n    ; if hanging is true and if fzfit-one-line is true, then we go\n    ; with hanging.  Which is probably the same as just above.\n    ;\n    ; if hanging is true and if one-line? is nil, and if hang? is\n    ; nil, and fzfit-one-line is true then it fit on one line and we\n    ; should go with hanging.\n    ;\n    ;\n    ; Summary:\n    ;\n    ; go with hanging if:\n    ;\n    ;  o fzfit-one-line true\n    ;  o one-line? true\n    ;\n    ; Otherwise, see about flow too\n    ;\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]]\n                                (fzprint* options findent zloc))\n            _ (log-lines options \"fzprint-hang-one: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg options \"fzprint-hang-one: fd-lines:\" fd-lines)\n            _ (dbg options\n                   \"fzprint-hang-one: ending: hang-count:\" hang-count\n                   \"hanging:\" (pr-str hanging)\n                   \"flow:\" (pr-str flow))\n            hr-good? (and (:hang? (caller options))\n                          (good-enough? caller\n                                        options\n                                        :none-hang-one\n                                        hang-count\n                                        (- hindent findent)\n                                        hr-lines\n                                        fd-lines))]\n        (if hr-good? hanging flow)))))\n\n;;\n;; # Constant pair support\n;;\n\n(defn count-constant-pairs\n  \"Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any whitespace in this, because this seq should have been\n  produced by zmap-right or its equivalent, which already skips the\n  whitespace.\"\n  [seq-right]\n  (loop [seq-right-rev (reverse seq-right)\n         element-count 0\n         ; since it is reversed, we need a constant second\n         constant-required? nil\n         pair-size 0]\n    (let [element (first seq-right-rev)]\n      (if (empty? seq-right-rev)\n        ; remove potential elements of this pair, since we haven't\n        ; seen the end of it\n        (- element-count pair-size)\n        (let [comment? (zcomment? element)]\n          (if (and (not comment?) constant-required? (not (zconstant? element)))\n            ; we counted the right-hand and any comments of this pair, but it\n            ; isn't a pair so exit now with whatever we have so far\n            (- element-count pair-size)\n            (recur (next seq-right-rev)\n                   (inc element-count)\n                   (if comment? constant-required? (not constant-required?))\n                   (if (and constant-required? (not comment?))\n                     ; must be a constant, so start count over\n                     0\n                     (inc pair-size)))))))))\n\n(defn constant-pair\n  \"Argument is result of (zmap-right identity zloc), that is to say\n  a seq of zlocs.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not\n  an empty seq.\"\n  [caller {{:keys [constant-pair? constant-pair-min]} caller, :as options}\n   seq-right]\n  (if constant-pair?\n    (let [paired-item-count (count-constant-pairs seq-right)\n          non-paired-item-count (- (count seq-right) paired-item-count)\n          _ (dbg options\n                 \"constant-pair: non-paired-items:\"\n                 non-paired-item-count)\n          pair-seq (when (>= paired-item-count constant-pair-min)\n                     (second (partition-all-2-nc options\n                                                 (drop non-paired-item-count\n                                                       seq-right))))]\n      [pair-seq non-paired-item-count])\n    [nil (count seq-right)]))\n\n;;\n;; # Take into account constant pairs\n;;\n\n(declare interpose-either-nl-hf)\n\n(declare fzprint-hang-remaining)\n\n#_(defn fzprint-hang-remaining-perf-vs-format\n    \"zloc is already down inside a collection, it is not the collection\n  itself. Operate on what is to the right of zloc.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc.\"\n    ([caller\n      {:keys [dbg? depth perf-vs-format],\n       {:keys [hang? constant-pair? constant-pair-min hang-expand hang-diff\n               nl-separator?]}\n         caller,\n       :as options} hindent findent zloc fn-style zloc-count]\n     (when (:dbg-hang options)\n       (println (dots (:pdepth options)) \"hr\" (zstring zloc)))\n     (dbg options\n          \"fzprint-hang-remaining:\" (zstring zloc)\n          \"hindent:\" hindent\n          \"findent:\" findent\n          \"caller:\" caller\n          \"nl-separator?:\" nl-separator?)\n     ; (in-hang options) slows things down here, for some reason\n     (let [seq-right (zmap-right identity zloc)\n           seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n           [pair-seq non-paired-item-count]\n             (constant-pair caller options seq-right)\n           _ (dbg options\n                  \"fzprint-hang-remaining count pair-seq:\"\n                  (count pair-seq))\n           hang? (and hang?\n                      ; This is a key for \"don't hang no matter what\", it isn't\n                      ; about making it prettier. People call this routine with\n                      ; these values equal to ensure that it always flows.\n                      (not= hindent findent)\n                      ;flow-lines\n                      ;;TODO make this uneval!!!\n                      #_(or (<= (- hindent findent) hang-diff)\n                            (<= (/ (dec (first flow-lines)) (count seq-right))\n                                hang-expand)))\n           ; The zfuture options, below, kicks this off in a separate thread,\n           ; and the subsequent zat waits for it to complete.\n           hanging\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [hang-result\n                      (when hang?\n                        (if-not pair-seq\n                          ; There are no paired elements\n                          (apply concat-no-nil\n                            (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                         :indent]]\n                              (fzprint-seq (in-hang options)\n                                           hindent\n                                           seq-right)))\n                          (if (not (zero? non-paired-item-count))\n                            (concat-no-nil\n                              ; The elements that are not paired\n                              (dbg-form\n                                options\n                                \"fzprint-hang-remaining: mapv:\"\n                                (apply concat-no-nil\n                                  (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                               :indent]]\n                                    (zpmap\n                                      options\n                                      (partial fzprint*\n                                               (not-rightmost (in-hang options))\n                                               hindent)\n                                      (take non-paired-item-count seq-right)))))\n                              ; Got to separate them because they were done in\n                              ; two\n                              ; pieces\n                              [[(str \"\\n\" (blanks hindent)) :none :indent]]\n                              ; The elements that are paired\n                              (dbg-form options\n                                        \"fzprint-hang-remaining: fzprint-hang:\"\n                                        (interpose-nl-hf\n                                          (:pair options)\n                                          hindent\n                                          (fzprint-map-two-up :pair\n                                                              ;caller\n                                                              (in-hang options)\n                                                              hindent\n                                                              nil\n                                                              pair-seq))))\n                            ; All elements are paired\n                            (interpose-nl-hf\n                              (:pair options)\n                              hindent\n                              (fzprint-map-two-up :pair\n                                                  ;caller\n                                                  (in-hang options)\n                                                  hindent\n                                                  nil\n                                                  pair-seq)))))]\n                [hang-result (style-lines options hindent hang-result)]))\n           flow\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [flow-result\n                      (if-not pair-seq\n                        ; We don't have any constant pairs\n                        (apply concat-no-nil\n                          (interpose [[(str \"\\n\" (blanks findent)) :none\n                                       :indent]]\n                            (fzprint-seq options findent seq-right)))\n                        (if (not (zero? non-paired-item-count))\n                          ; We have constant pairs, ; but they follow\n                          ; some stuff that isn't paired.\n                          (concat-no-nil\n                            ; The elements that are not pairs\n                            (apply concat-no-nil\n                              (interpose [[(str \"\\n\" (blanks findent)) :none\n                                           :indent]]\n                                (zpmap options\n                                       (partial fzprint*\n                                                (not-rightmost options)\n                                                findent)\n                                       (take non-paired-item-count seq-right))))\n                            ; Got to separate them since we are doing them in\n                            ; two\n                            ; pieces\n                            [[(str \"\\n\" (blanks findent)) :none :indent]]\n                            ; The elements that are constant pairs\n                            (interpose-nl-hf (:pair options)\n                                             findent\n                                             (fzprint-map-two-up :pair\n                                                                 ;caller\n                                                                 options\n                                                                 findent\n                                                                 nil\n                                                                 pair-seq)))\n                          ; This code path is where we have all constant pairs.\n                          (interpose-nl-hf (:pair options)\n                                           findent\n                                           (fzprint-map-two-up :pair\n                                                               ;caller\n                                                               options\n                                                               findent\n                                                               nil\n                                                               pair-seq))))]\n                [flow-result (style-lines options findent flow-result)]))\n           ; Now that we have also kicked off a flow, let's see if there\n           ; is any point in waiting for it?\n           [hanging hanging-lines] (zat options hanging)\n           hang-count (count seq-right)\n           _ (log-lines options\n                        \"fzprint-hang-remaining: hanging:\"\n                        hindent\n                        hanging)\n           _ (dbg options\n                  \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                  \"hang-count:\" hang-count)\n           ; flow? is -- should we wait for the flow to complete, or ignore it?\n           flow?\n             (if perf-vs-format\n               (if (> depth perf-vs-format)\n                 ;this is \"if it hangs, take it\": (if hanging nil true)\n                 ;this is \"if it hangs and isn't too bad, take it\"\n                 (if (and hanging (number? (first hanging-lines)))\n                   (not (<= (/ (dec (first hanging-lines)) (count seq-right))\n                            hang-expand))\n                   true)\n                 true)\n               true)\n           #_(options (let [[_ _ _ b-what] flow-lines]\n                        (if b-what (assoc options :dbg? true) options)))\n           #_(dbg options\n                  \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring zloc)\n                  \"hindent:\" hindent\n                  \"findent:\" findent\n                  \"caller:\" caller\n                  \"hang?\" hang?\n                  \"hang-diff\" hang-diff)\n           ; Now determine if there is any point in doing a hang, because\n           ; if the flow is beyond the expand limit, there is really no\n           ; chance that the hang is not beyond the expand limit.\n           ; This is what good-enough? does:\n           ;  (<= (/ (dec p-lines) p-count) hang-expand)\n           ;  Also need to account for the indent diffs.\n           ; Would be nice to move this into a common routine, since this\n           ; duplicates logic in good-enough?\n           ;\n           ; Yes, and this caused a proble when I put in the\n           ; hang-if-equal-flow? option in good-enough, so that now\n           ; we can't cancel the hang even though we are beyond the hang-expand\n           ; because the hang might be the same as the flow, and in that case\n           ; we don't really care how long the hang-expand is. We could make\n           ; this a feature, by having a large-ish hang-expand and having it\n           ; override hang-if-equal-flow.  If we do that, we have to reorder\n           ; the checks in good-enough to put the hang-expand check first.\n           ; I can't see any great reason for doing a flow if the hang and\n           ; flow are equal, though, so we won't do that now.  And this\n           ; code comes out.\n           ; We used to calculate hang-count by doing the hang an then counting\n           ; the output.  But ultimately this is simple a series of map calls\n           ; to the elements of seq-right, so we go right to the source for this\n           ; number now.  That let's us move the interpose calls above this\n           ; point.\n           [flow flow-lines] (when flow? (zat options flow))]\n       (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n       (when dbg?\n         (if (zero? hang-count)\n           (println \"hang-count = 0:\" (str (zmap-right zstring zloc)))))\n       (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n       (if flow-lines\n         (if (good-enough? caller\n                           options\n                           fn-style\n                           hang-count\n                           (- hindent findent)\n                           hanging-lines\n                           flow-lines)\n           (concat-no-nil [[\" \" :none :whitespace]] hanging)\n           (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]] flow))\n         (when hanging-lines\n           (concat-no-nil [[\" \" :none :whitespace]] hanging)))))\n    ([caller options hindent findent zloc fn-style]\n     (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n;\n; This fzprint-hang-remaining doesn't overlap the hang and the flow,\n; but does the hang first, and if we are at a sufficient depth in\n; perf-vs-format, then we don't flow if the hang worked.  A better\n; approach would be to do the overlapped hang and flow unless we\n; were at or beyond that critical depth, and then do one or the other.\n; Even with the totally serial nature of this, it isn't terribly slower\n; when perf-vs-format is nil, and it is maybe 86% of the time it takes\n; when perf-vs-format is 5, for fzprint-list*.  Which isn't nothing.\n; Obviously only interesting on a function where it gets deeper than\n; whatever depth you specify.  Not going to use it now, but not going\n; to get rid of it either.\n;\n#_(defn fzprint-hang-remaining-serial\n    \"zloc is already down inside a collection, it is not the collection\n  itself. Operate on what is to the right of zloc.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc.\"\n    ([caller\n      {:keys [dbg? depth perf-vs-format],\n       {:keys [hang? constant-pair? constant-pair-min hang-expand hang-diff\n               nl-separator?]}\n         caller,\n       :as options} hindent findent zloc fn-style zloc-count]\n     (when (:dbg-hang options)\n       (println (dots (:pdepth options)) \"hr\" (zstring zloc)))\n     (dbg options\n          \"fzprint-hang-remaining:\" (zstring zloc)\n          \"hindent:\" hindent\n          \"findent:\" findent\n          \"caller:\" caller\n          \"nl-separator?:\" nl-separator?)\n     ; (in-hang options) slows things down here, for some reason\n     (let [seq-right (zmap-right identity zloc)\n           seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n           [pair-seq non-paired-item-count]\n             (constant-pair caller options seq-right)\n           _ (dbg options\n                  \"fzprint-hang-remaining count pair-seq:\"\n                  (count pair-seq))\n           hang? (and hang?\n                      ; This is a key for \"don't hang no matter what\", it isn't\n                      ; about making it prettier. People call this routine with\n                      ; these values equal to ensure that it always flows.\n                      (not= hindent findent)\n                      ;flow-lines\n                      ;;TODO make this uneval!!!\n                      #_(or (<= (- hindent findent) hang-diff)\n                            (<= (/ (dec (first flow-lines)) (count seq-right))\n                                hang-expand)))\n           ; The zfuture options, below, kicks this off in a separate thread,\n           ; and the subsequent zat waits for it to complete.\n           hanging\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [hang-result\n                      (when hang?\n                        (if-not pair-seq\n                          ; There are no paired elements\n                          (apply concat-no-nil\n                            (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                         :indent]]\n                              (fzprint-seq (in-hang options)\n                                           hindent\n                                           seq-right)))\n                          (if (not (zero? non-paired-item-count))\n                            (concat-no-nil\n                              ; The elements that are not paired\n                              (dbg-form\n                                options\n                                \"fzprint-hang-remaining: mapv:\"\n                                (apply concat-no-nil\n                                  (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                               :indent]]\n                                    (zpmap\n                                      options\n                                      (partial fzprint*\n                                               (not-rightmost (in-hang options))\n                                               hindent)\n                                      (take non-paired-item-count seq-right)))))\n                              ; Got to separate them because they were done in\n                              ; two\n                              ; pieces\n                              [[(str \"\\n\" (blanks hindent)) :none :indent]]\n                              ; The elements that are paired\n                              (dbg-form options\n                                        \"fzprint-hang-remaining: fzprint-hang:\"\n                                        (interpose-nl-hf\n                                          (:pair options)\n                                          hindent\n                                          (fzprint-map-two-up :pair\n                                                              ;caller\n                                                              (in-hang options)\n                                                              hindent\n                                                              nil\n                                                              pair-seq))))\n                            ; All elements are paired\n                            (interpose-nl-hf\n                              (:pair options)\n                              hindent\n                              (fzprint-map-two-up :pair\n                                                  ;caller\n                                                  (in-hang options)\n                                                  hindent\n                                                  nil\n                                                  pair-seq)))))]\n                [hang-result (style-lines options hindent hang-result)]))\n           [hanging hanging-lines] (zat options hanging)\n           hang-count (count seq-right)\n           _ (log-lines options\n                        \"fzprint-hang-remaining: hanging:\"\n                        hindent\n                        hanging)\n           _ (dbg options\n                  \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                  \"hang-count:\" hang-count)\n           flow?\n             (if perf-vs-format\n               (if (> depth perf-vs-format)\n                 ;this is \"if it hangs, take it\": (if hanging nil true)\n                 ;this is \"if it hangs and isn't too bad, take it\"\n                 (if (and hanging (number? (first hanging-lines)))\n                   (not (<= (/ (dec (first hanging-lines)) (count seq-right))\n                            hang-expand))\n                   true)\n                 true)\n               true)\n           flow\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [flow-result\n                      (when flow?\n                        (if-not pair-seq\n                          ; We don't have any constant pairs\n                          (apply concat-no-nil\n                            (interpose [[(str \"\\n\" (blanks findent)) :none\n                                         :indent]]\n                              (fzprint-seq options findent seq-right)))\n                          (if (not (zero? non-paired-item-count))\n                            ; We have constant pairs, ; but they follow\n                            ; some stuff that isn't paired.\n                            (concat-no-nil\n                              ; The elements that are not pairs\n                              (apply concat-no-nil\n                                (interpose [[(str \"\\n\" (blanks findent)) :none\n                                             :indent]]\n                                  (zpmap options\n                                         (partial fzprint*\n                                                  (not-rightmost options)\n                                                  findent)\n                                         (take non-paired-item-count\n                                               seq-right))))\n                              ; Got to separate them since we are doing them in\n                              ; two\n                              ; pieces\n                              [[(str \"\\n\" (blanks findent)) :none :indent]]\n                              ; The elements that are constant pairs\n                              (interpose-nl-hf (:pair options)\n                                               findent\n                                               (fzprint-map-two-up :pair\n                                                                   ;caller\n                                                                   options\n                                                                   findent\n                                                                   nil\n                                                                   pair-seq)))\n                            ; This code path is where we have all constant\n                            ; pairs.\n                            (interpose-nl-hf (:pair options)\n                                             findent\n                                             (fzprint-map-two-up :pair\n                                                                 ;caller\n                                                                 options\n                                                                 findent\n                                                                 nil\n                                                                 pair-seq)))))]\n                [flow-result (style-lines options findent flow-result)]))\n           #_(options (let [[_ _ _ b-what] flow-lines]\n                        (if b-what (assoc options :dbg? true) options)))\n           #_(dbg options\n                  \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring zloc)\n                  \"hindent:\" hindent\n                  \"findent:\" findent\n                  \"caller:\" caller\n                  \"hang?\" hang?\n                  \"hang-diff\" hang-diff)\n           ; Now determine if there is any point in doing a hang, because\n           ; if the flow is beyond the expand limit, there is really no\n           ; chance that the hang is not beyond the expand limit.\n           ; This is what good-enough? does:\n           ;  (<= (/ (dec p-lines) p-count) hang-expand)\n           ;  Also need to account for the indent diffs.\n           ; Would be nice to move this into a common routine, since this\n           ; duplicates logic in good-enough?\n           ;\n           ; Yes, and this caused a proble when I put in the\n           ; hang-if-equal-flow? option in good-enough, so that now\n           ; we can't cancel the hang even though we are beyond the hang-expand\n           ; because the hang might be the same as the flow, and in that case\n           ; we don't really care how long the hang-expand is. We could make\n           ; this a feature, by having a large-ish hang-expand and having it\n           ; override hang-if-equal-flow.  If we do that, we have to reorder\n           ; the checks in good-enough to put the hang-expand check first.\n           ; I can't see any great reason for doing a flow if the hang and\n           ; flow are equal, though, so we won't do that now.  And this\n           ; code comes out.\n           ; We used to calculate hang-count by doing the hang an then counting\n           ; the output.  But ultimately this is simple a series of map calls\n           ; to the elements of seq-right, so we go right to the source for this\n           ; number now.  That let's us move the interpose calls above this\n           ; point.\n           [flow flow-lines] (zat options flow)]\n       (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n       (when dbg?\n         (if (zero? hang-count)\n           (println \"hang-count = 0:\" (str (zmap-right zstring zloc)))))\n       (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n       (if flow-lines\n         (if (good-enough? caller\n                           options\n                           fn-style\n                           hang-count\n                           (- hindent findent)\n                           hanging-lines\n                           flow-lines)\n           (concat-no-nil [[\" \" :none :whitespace]] hanging)\n           (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]] flow))\n         (when hanging-lines\n           (concat-no-nil [[\" \" :none :whitespace]] hanging)))))\n    ([caller options hindent findent zloc fn-style]\n     (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n(defn fzprint-hang-remaining ;-original\n  \"zloc is already down inside a collection, it is not the collection\n  itself. Operate on what is to the right of zloc.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc.\"\n  ([caller\n    {:keys [dbg? width],\n     {:keys [hang? constant-pair? constant-pair-min hang-avoid hang-expand\n             hang-diff nl-separator?]}\n       caller,\n     :as options} hindent findent zloc fn-style zloc-count]\n   (when (:dbg-hang options)\n     (println (dots (:pdepth options)) \"hr\" (zstring zloc)))\n   (dbg options\n        \"fzprint-hang-remaining:\" (zstring zloc)\n        \"hindent:\" hindent\n        \"findent:\" findent\n        \"caller:\" caller\n        \"nl-separator?:\" nl-separator?)\n   ; (in-hang options) slows things down here, for some reason\n   (let [seq-right (zmap-right identity zloc)\n         seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n         [pair-seq non-paired-item-count]\n           (constant-pair caller options seq-right)\n         _ (dbg options\n                \"fzprint-hang-remaining count pair-seq:\"\n                (count pair-seq))\n         flow\n           (#?@(:clj [zfuture options]\n                :cljs [do])\n            (let [flow-result\n                    (if-not pair-seq\n                      ; We don't have any constant pairs\n                      (apply concat-no-nil\n                        (interpose [[(str \"\\n\" (blanks findent)) :none :indent]]\n                          (fzprint-seq options findent seq-right)))\n                      (if (not (zero? non-paired-item-count))\n                        ; We have constant pairs, ; but they follow\n                        ; some stuff that isn't paired.\n                        (concat-no-nil\n                          ; The elements that are not pairs\n                          (apply concat-no-nil\n                            (interpose [[(str \"\\n\" (blanks findent)) :none\n                                         :indent]]\n                              (zpmap options\n                                     (partial fzprint*\n                                              (not-rightmost options)\n                                              findent)\n                                     (take non-paired-item-count seq-right))))\n                          ; Got to separate them since we are doing them in\n                          ; two\n                          ; pieces\n                          [[(str \"\\n\" (blanks findent)) :none :indent]]\n                          ; The elements that are constant pairs\n                          (interpose-nl-hf (:pair options)\n                                           findent\n                                           (fzprint-map-two-up :pair\n                                                               ;caller\n                                                               options\n                                                               findent\n                                                               nil\n                                                               pair-seq)))\n                        ; This code path is where we have all constant pairs.\n                        (interpose-nl-hf (:pair options)\n                                         findent\n                                         (fzprint-map-two-up :pair\n                                                             ;caller\n                                                             options\n                                                             findent\n                                                             nil\n                                                             pair-seq))))]\n              [flow-result (style-lines options findent flow-result)]))\n         #_(options (let [[_ _ _ b-what] flow-lines]\n                      (if b-what (assoc options :dbg? true) options)))\n         #_(dbg options\n                \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring zloc)\n                \"hindent:\" hindent\n                \"findent:\" findent\n                \"caller:\" caller\n                \"hang?\" hang?\n                \"hang-diff\" hang-diff)\n         ; Now determine if there is any point in doing a hang, because\n         ; if the flow is beyond the expand limit, there is really no\n         ; chance that the hang is not beyond the expand limit.\n         ; This is what good-enough? does:\n         ;  (<= (/ (dec p-lines) p-count) hang-expand)\n         ;  Also need to account for the indent diffs.\n         ; Would be nice to move this into a common routine, since this\n         ; duplicates logic in good-enough?\n         ;\n         ; Yes, and this caused a proble when I put in the\n         ; hang-if-equal-flow? option in good-enough, so that now\n         ; we can't cancel the hang even though we are beyond the hang-expand\n         ; because the hang might be the same as the flow, and in that case\n         ; we don't really care how long the hang-expand is. We could make\n         ; this a feature, by having a large-ish hang-expand and having it\n         ; override hang-if-equal-flow.  If we do that, we have to reorder\n         ; the checks in good-enough to put the hang-expand check first.\n         ; I can't see any great reason for doing a flow if the hang and\n         ; flow are equal, though, so we won't do that now.  And this\n         ; code comes out.\n         ;\n         hang? (and hang?\n                    ; This is a key for \"don't hang no matter what\", it isn't\n                    ; about making it prettier. People call this routine with\n                    ; these values equal to ensure that it always flows.\n                    (not= hindent findent)\n                    ; This is not the original, below.\n                    (or (not hang-avoid)\n                        (< (count seq-right) (* (- width hindent) hang-avoid)))\n                    ;flow-lines\n                    ;;TODO make this uneval!!!\n                    #_(or (<= (- hindent findent) hang-diff)\n                          (<= (/ (dec (first flow-lines)) (count seq-right))\n                              hang-expand)))\n         hanging\n           (#?@(:clj [zfuture options]\n                :cljs [do])\n            (let [hang-result\n                    (when hang?\n                      (if-not pair-seq\n                        ; There are no paired elements\n                        (apply concat-no-nil\n                          (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                       :indent]]\n                            (fzprint-seq (in-hang options) hindent seq-right)))\n                        (if (not (zero? non-paired-item-count))\n                          (concat-no-nil\n                            ; The elements that are not paired\n                            (dbg-form\n                              options\n                              \"fzprint-hang-remaining: mapv:\"\n                              (apply concat-no-nil\n                                (interpose [[(str \"\\n\" (blanks hindent)) :none\n                                             :indent]]\n                                  (zpmap\n                                    options\n                                    (partial fzprint*\n                                             (not-rightmost (in-hang options))\n                                             hindent)\n                                    (take non-paired-item-count seq-right)))))\n                            ; Got to separate them because they were done in two\n                            ; pieces\n                            [[(str \"\\n\" (blanks hindent)) :none :indent]]\n                            ; The elements that are paired\n                            (dbg-form options\n                                      \"fzprint-hang-remaining: fzprint-hang:\"\n                                      (interpose-nl-hf\n                                        (:pair options)\n                                        hindent\n                                        (fzprint-map-two-up :pair\n                                                            ;caller\n                                                            (in-hang options)\n                                                            hindent\n                                                            nil\n                                                            pair-seq))))\n                          ; All elements are paired\n                          (interpose-nl-hf (:pair options)\n                                           hindent\n                                           (fzprint-map-two-up :pair\n                                                               ;caller\n                                                               (in-hang options)\n                                                               hindent\n                                                               nil\n                                                               pair-seq)))))]\n              [hang-result (style-lines options hindent hang-result)]))\n         ; We used to calculate hang-count by doing the hang an then counting\n         ; the output.  But ultimately this is simple a series of map calls\n         ; to the elements of seq-right, so we go right to the source for this\n         ; number now.  That let's us move the interpose calls above this\n         ; point.\n         [flow flow-lines] (zat options flow)\n         [hanging hanging-lines] (zat options hanging)\n         hang-count (count seq-right)\n         _ (log-lines options\n                      \"fzprint-hang-remaining: hanging:\"\n                      hindent\n                      hanging)\n         _ (dbg options\n                \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                \"hang-count:\" hang-count)]\n     (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n     (when dbg?\n       (if (zero? hang-count)\n         (println \"hang-count = 0:\" (str (zmap-right zstring zloc)))))\n     (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n     (when flow-lines\n       (if (good-enough? caller\n                         options\n                         fn-style\n                         hang-count\n                         (- hindent findent)\n                         hanging-lines\n                         flow-lines)\n         (concat-no-nil [[\" \" :none :whitespace]] hanging)\n         (concat-no-nil [[(str \"\\n\" (blanks findent)) :none :indent]] flow)))))\n  ([caller options hindent findent zloc fn-style]\n   (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n;;\n;; # Utilities to modify list printing in various ways\n;;\n\n\n;;\n;; Which fn-styles use :list {:indent n} instead of\n;; :list {:indent-arg n}\n;;\n\n(def body-set\n  #{:binding :arg1-> :arg2 :arg2-fn :arg2-pair :pair-fn :fn :arg1-body\n    :arg1-pair-body :none-body :noarg1-body :flow-body})\n\n(def body-map\n  {:arg1-body :arg1,\n   :arg1-pair-body :arg1-pair,\n   :none-body :none,\n   :flow-body :flow,\n   :noarg1-body :noarg1,\n   :force-nl-body :force-nl})\n\n;;\n;; If the noarg1? value is set, this is the mapping for functions\n;; immediately below\n;; \n\n(def noarg1-set #{:noarg1 :arg1->})\n\n(def noarg1-map\n  {:arg1 :none,\n   :arg1-pair :pair-fn,\n   :arg1-extend :extend,\n   :arg2 :arg1,\n   :arg2-pair :arg1-pair})\n\n(defn noarg1\n  \"Set noarg1 in the options if it is the right fn-type.\"\n  [options fn-type]\n  (if (noarg1-set fn-type) (assoc options :no-arg1? true) options))\n\n(def fn-style->caller\n  {:arg1-pair-body :pair,\n   :arg1-pair :pair,\n   :arg2-pair :pair,\n   :extend :extend,\n   :binding :binding,\n   :arg1-extend :extend,\n   :arg2-extend :extend,\n   :pair-fn :pair})\n\n(defn allow-one-line?\n  \"Should we allow this function to print on a single line?\"\n  [{:keys [fn-force-nl fn-gt2-force-nl fn-gt3-force-nl], :as options} len\n   fn-style]\n  (not (or (fn-force-nl fn-style)\n           (and (> len 3) (fn-gt2-force-nl fn-style))\n           (and (> len 4) (fn-gt3-force-nl fn-style))\n           (if-let [future-caller (fn-style->caller fn-style)]\n             (let [caller-map (future-caller options)]\n               (or (:flow? caller-map) (:force-nl? caller-map)))))))\n\n(defn fzprint-list*\n  \"Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list.\"\n  [caller l-str r-str\n   {:keys [fn-map user-fn-map one-line? fn-style no-arg1? fn-force-nl],\n    {:keys [indent-arg indent]} caller,\n    :as options} ind zloc]\n  (let [len (zcount zloc)\n        l-str-len (count l-str)\n        arg-1-coll? (not (or (zkeyword? (zfirst zloc))\n                             (zsymbol? (zfirst zloc))))\n        fn-str (if-not arg-1-coll? (zstring (zfirst zloc)))\n        fn-style (or fn-style (fn-map fn-str) (user-fn-map fn-str))\n        ; if we don't have a function style, let's see if we can get\n        ; one by removing the namespacing\n        fn-style (if (and (not fn-style) fn-str)\n                   (fn-map (last (clojure.string/split fn-str #\"/\")))\n                   fn-style)\n        ; set indent based on fn-style\n        indent (if (body-set fn-style) indent (or indent-arg indent))\n        one-line-ok? (allow-one-line? options len fn-style)\n        ; remove -body from fn-style if it was there\n        fn-style (or (body-map fn-style) fn-style)\n        ; All styles except :hang need three elements minimum.\n        ; We could put this in the fn-map, but until there is more\n        ; than one exception, seems like too much mechanism.\n        fn-style (if (= fn-style :hang) fn-style (if (< len 3) nil fn-style))\n        fn-style (if no-arg1? (or (noarg1-map fn-style) fn-style) fn-style)\n        ; no-arg? only affect one level down...\n        options (if no-arg1? (dissoc options :no-arg1?) options)\n        ; If l-str isn't one char, create an indent adjustment.  Largely\n        ; for anonymous functions, which otherwise would have their own\n        ; :anon config to parallel :list, which would be just too much\n        indent-adj (dec l-str-len)\n        ; The default indent is keyed off of whether or not the first thing\n        ; in the list is itself a list, since that list could evaluate to a\n        ; fn.  You can't replace the zlist? with arg-1-coll?, since if you do\n        ; multi-arity functions aren't done right, since the argument vector\n        ; is a coll?, and so arg-1-coll? is set, and then you get a two space\n        ; indent for multi-arity functions, which is wrong.\n        ; We could, conceivably, use zvector? here to specifically handle\n        ; multi-arity functions.  Or we could remember we are in a defn and\n        ; do something special there, or we could at least decide that we\n        ; were in code when we did this zlist? thing, since that is all about\n        ; code.  That wouldn't work if it was the top-level form, but would\n        ; otherwise.\n        default-indent (if (zlist? (zfirst zloc)) indent l-str-len)\n        arg-1-indent (if-not (or arg-1-coll? (zcomment? (zfirst zloc)))\n                       (+ ind (inc l-str-len) (count fn-str)))\n        ; Tell people inside that we are in code.\n        ; We don't catch places where the first thing in a list is\n        ; a collection or a seq which yields a function.\n        options (if (not arg-1-coll?) (assoc options :in-code? fn-str) options)\n        options (assoc options :pdepth (inc (long (or (:pdepth options) 0))))\n        _ (when (:dbg-hang options)\n            (println (dots (:pdepth options)) \"fzs\" fn-str))\n        new-ind (+ indent ind)\n        one-line-ind (+ l-str-len ind)\n        options (if fn-style (dissoc options :fn-style) options)\n        loptions (not-rightmost options)\n        roptions options\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n        _ (dbg options\n               \"fzprint-list*:\" (zstring zloc)\n               \"fn-str\" fn-str\n               \"fn-style:\" fn-style\n               \"ind:\" ind\n               \"indent:\" indent\n               \"default-indent:\" default-indent\n               \"one-line-ok?\" one-line-ok?\n               \"arg-1-coll?\" arg-1-coll?\n               \"arg-1-indent:\" arg-1-indent\n               \"l-str:\" (str \"'\" l-str \"'\")\n               \"indent-adj:\" indent-adj\n               \"len:\" len\n               \"one-line?:\" one-line?\n               \"rightcnt:\" (:rightcnt options))\n        one-line (if (zero? len)\n                   :empty\n                   (when one-line-ok?\n                     (fzprint-one-line options one-line-ind zloc)))]\n    (cond\n      one-line (if (= one-line :empty)\n                 (concat-no-nil l-str-vec r-str-vec)\n                 (concat-no-nil l-str-vec one-line r-str-vec))\n      ; If we are in :one-line mode, and it didn't fit on one line,\n      ; we are done!  We don't see this debugging, below.  Suppose\n      ; we never get here?\n      one-line?\n        (dbg options \"fzprint-list*:\" fn-str \" one-line did not work!!!\")\n      (dbg options \"fzprint-list*: fn-style:\" fn-style) nil\n      (= len 0) (concat-no-nil l-str-vec r-str-vec)\n      (= len 1) (concat-no-nil l-str-vec\n                               (fzprint* roptions one-line-ind (zfirst zloc))\n                               r-str-vec)\n      ; needs (> len 2) but we already checked for that above in fn-style\n      (and (= fn-style :binding) (zvector? (zsecond zloc)))\n        (let [[hang-or-flow binding-style-vec] (fzprint-hang-unless-fail\n                                                 loptions\n                                                 arg-1-indent\n                                                 (+ indent ind)\n                                                 fzprint-binding-vec\n                                                 (zsecond zloc))\n              binding-style-vec (if (= hang-or-flow :hang)\n                                  (concat-no-nil [[\" \" :none :whitespace]]\n                                                 binding-style-vec)\n                                  binding-style-vec)]\n          (concat-no-nil l-str-vec\n                         ; TODO: get rid of inc ind\n                         (fzprint* loptions (inc ind) (zfirst zloc))\n                         binding-style-vec\n                         [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                         ; here we use options, because fzprint-flow-seq\n                         ; will sort it out\n                         (fzprint-flow-seq options\n                                           (+ indent ind)\n                                           (nthnext (zmap identity zloc) 2)\n                                           :force-nl)\n                         r-str-vec))\n      (= fn-style :pair-fn) (concat-no-nil\n                              l-str-vec\n                              (fzprint* loptions (inc ind) (zfirst zloc))\n                              ;    [[(str \" \") :none :whitespace]]\n                              (fzprint-hang\n                                options\n                                :pair-fn\n                                arg-1-indent\n                                (+ indent ind)\n                                fzprint-pairs\n                                (count (zmap-right identity (znthnext zloc 0)))\n                                (znthnext zloc 0))\n                              r-str-vec)\n      (= fn-style :extend)\n        (concat-no-nil l-str-vec\n                       (fzprint* loptions (inc ind) (zfirst zloc))\n                       [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                       ; I think fzprint-pairs will sort out which\n                       ; is and isn't the rightmost because of two-up\n                       (fzprint-extend options (+ indent ind) (znthnext zloc 0))\n                       r-str-vec)\n      ; needs (> len 2) but we already checked for that above in fn-style\n      (or (and (= fn-style :fn) (not (zlist? (zsecond zloc))))\n          (= fn-style :arg2)\n          (= fn-style :arg2-fn)\n          (= fn-style :arg2-pair)\n          (= fn-style :arg2-extend))\n        (let [second-element (fzprint-hang-one caller\n                                               (if (= len 2) options loptions)\n                                               arg-1-indent\n                                               (+ indent ind)\n                                               (zsecond zloc))\n              [line-count max-width]\n                (style-lines loptions arg-1-indent second-element)\n              third (zthird zloc)\n              first-three\n                (when second-element\n                  (concat-no-nil\n                    (fzprint* loptions\n                              ;(inc ind)\n                              (+ indent ind)\n                              (zfirst zloc))\n                    second-element\n                    (if (or (= fn-style :arg2)\n                            (= fn-style :arg2-pair)\n                            (= fn-style :arg2-fn)\n                            (and (zvector? third) (= line-count 1)))\n                      (fzprint-hang-one caller\n                                        (if (= len 3) options loptions)\n                                        ;(inc max-width)\n                                        max-width\n                                        (+ indent ind)\n                                        third)\n                      (concat-no-nil [[(str \"\\n\" (blanks (+ indent ind))) :none\n                                       :indent]]\n                                     (fzprint* (if (= len 3) options loptions)\n                                               (+ indent ind)\n                                               third)))))]\n          (when first-three\n            (if (= len 3)\n              (concat-no-nil l-str-vec first-three r-str-vec)\n              (concat-no-nil\n                l-str-vec\n                first-three\n                (cond\n                  (= fn-style :arg2-pair)\n                    (concat-no-nil\n                      [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                      (fzprint-pairs options (+ indent ind) (znthnext zloc 2)))\n                  (= fn-style :arg2-extend)\n                    (concat-no-nil\n                      [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                      (fzprint-extend options (+ indent ind) (znthnext zloc 2)))\n                  :else (fzprint-hang-remaining caller\n                                                ;options\n                                                (if (= fn-style :arg2-fn)\n                                                  (assoc options :fn-style :fn)\n                                                  options)\n                                                (+ indent ind)\n                                                ; force flow\n                                                (+ indent ind)\n                                                (znthnext zloc 2)\n                                                fn-style))\n                r-str-vec))))\n      (and (= fn-style :arg1-mixin) (> len 3))\n        (let [arg-vec-index (or (zfind #(or (zvector? %)\n                                            (when (zlist? %)\n                                              (zvector? (zfirst %))))\n                                       zloc)\n                                0)\n              doc-string? (string? (zsexpr (zthird zloc)))\n              mixin-start (if doc-string? 4 3)\n              mixin-length (- arg-vec-index mixin-start)\n              mixins? (pos? mixin-length)\n              doc-string (when doc-string?\n                           (fzprint-hang-one caller\n                                             loptions\n                                             (+ indent ind)\n                                             ; force flow\n                                             (+ indent ind)\n                                             (zthird zloc)))\n              ; Have to deal with no arg-vec-index!!\n              mixins\n                (when mixins?\n                  (let [mixin-sentinal (fzprint-hang-one caller\n                                                         loptions\n                                                         (+ indent ind)\n                                                         ; force flow\n                                                         (+ indent ind)\n                                                         (if doc-string?\n                                                           (zfourth zloc)\n                                                           (zthird zloc)))\n                        [line-count max-width]\n                          (style-lines loptions (+ indent ind) mixin-sentinal)]\n                    (concat-no-nil mixin-sentinal\n                                   (fzprint-hang-remaining\n                                     caller\n                                     loptions\n                                     ; Apparently hang-remaining gives you a\n                                     ; space after the current thing, so we\n                                     ; need to account for it now, since\n                                     ; max-width is the end of the current\n                                     ; thing\n                                     (inc max-width)\n                                     (dec (+ indent indent ind))\n                                     (znthnext zloc (if doc-string? 3 2))\n                                     fn-style\n                                     mixin-length))))]\n          (concat-no-nil\n            l-str-vec\n            (fzprint* loptions (inc ind) (zfirst zloc))\n            (fzprint-hang-one caller\n                              (if (= len 2) options loptions)\n                              arg-1-indent\n                              (+ indent ind)\n                              (zsecond zloc))\n            (cond (and doc-string? mixins?) (concat-no-nil doc-string mixins)\n                  doc-string? doc-string\n                  mixins? mixins\n                  ; This is a hack, would be nice to have a better way to\n                  ; handle these situations.  Likely the only one so far.\n                  :else [[\"\" :none :whitespace]])\n            (fzprint-hang-remaining\n              caller\n              (noarg1 options fn-style)\n              (+ indent ind)\n              ; force flow\n              (+ indent ind)\n              (znthnext zloc\n                        (if mixins? (dec arg-vec-index) (if doc-string? 2 1)))\n              fn-style)\n            r-str-vec))\n      (or (= fn-style :arg1-pair)\n          (= fn-style :arg1)\n          (= fn-style :arg1-force-nl)\n          (= fn-style :arg1->))\n        (concat-no-nil\n          l-str-vec\n          (fzprint* loptions (inc ind) (zfirst zloc))\n          (fzprint-hang-one caller\n                            (if (= len 2) options loptions)\n                            arg-1-indent\n                            (+ indent ind)\n                            (zsecond zloc))\n          ; then either pair or remaining-seq\n          ; we don't do a full hanging here.\n          (when (> len 2)\n            (if (= fn-style :arg1-pair)\n              (concat-no-nil\n                [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                (fzprint-pairs options (+ indent ind) (znthnext zloc 1)))\n              (fzprint-hang-remaining caller\n                                      (noarg1 options fn-style)\n                                      (+ indent ind)\n                                      ; force flow\n                                      (+ indent ind)\n                                      (znthnext zloc 1)\n                                      fn-style)))\n          r-str-vec)\n      ; we know that (> len 2) if fn-style not= nil\n      (= fn-style :arg1-extend)\n        (cond\n          (zvector? (zsecond zloc))\n            (concat-no-nil\n              l-str-vec\n              (fzprint* loptions (inc ind) (zfirst zloc))\n              [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n              (fzprint* loptions (inc ind) (zsecond zloc))\n              [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n              ; This needs to be (znthnext zloc 1) and not 2 because\n              ; fzprint-extend does (zmap-right identity zloc), skipping\n              ; the first one!\n              (fzprint-extend options (+ indent ind) (znthnext zloc 1))\n              r-str-vec)\n          :else (concat-no-nil\n                  l-str-vec\n                  (fzprint* loptions (inc ind) (zfirst zloc))\n                  (fzprint-hang-one caller\n                                    (if (= len 2) options loptions)\n                                    arg-1-indent\n                                    (+ indent ind)\n                                    (zsecond zloc))\n                  [[(str \"\\n\" (blanks (+ indent ind))) :none :indent]]\n                  (fzprint-extend options (+ indent ind) (znthnext zloc 1))\n                  r-str-vec))\n      ;\n      ; Unspecified seq, might be a fn, might not.\n      ; If (first zloc) is a seq, we won't have an\n      ; arg-1-indent.  In that case, just flow it\n      ; out with remaining seq.  Since we already\n      ; know that it won't fit on one line.  If it\n      ; might be a fn, try hanging and flow and do\n      ; what we like better.  Note that default-indent\n      ; might be 1 here, which means that we are pretty\n      ; sure that the (zfirst zloc) isn't a function\n      ; and we aren't doing code.\n      ;\n      :else\n        (concat-no-nil\n          l-str-vec\n          (fzprint* loptions (+ l-str-len ind) (zfirst zloc))\n          (if (and arg-1-indent (not= fn-style :flow))\n            (fzprint-hang-remaining caller\n                                    (noarg1 options fn-style)\n                                    arg-1-indent\n                                    (+ indent ind indent-adj)\n                                    (znthnext zloc 0)\n                                    fn-style)\n            ; This might be a collection as the first thing, or it\n            ; might be a :flow type.  Do different indents for these.\n            (let [local-indent (if (= fn-style :flow)\n                                 (+ indent ind)\n                                 (+ default-indent ind indent-adj))]\n              (concat-no-nil [[(str \"\\n\" (blanks local-indent)) :none :indent]]\n                             (fzprint-flow-seq (noarg1 options fn-style)\n                                               local-indent\n                                               (nthnext (zmap identity zloc) 1)\n                                               :force-nl))))\n          r-str-vec))))\n\n(defn fzprint-list\n  \"Pretty print and focus style a :list element.\"\n  [options ind zloc]\n  (fzprint-list* :list \"(\" \")\" (rightmost options) ind zloc))\n\n(defn fzprint-anon-fn\n  \"Pretty print and focus style a fn element.\"\n  [options ind zloc]\n  (fzprint-list* :list \"#(\" \")\" (rightmost options) ind zloc))\n\n(defn any-zcoll?\n  \"Return true if there are any collections in the collection.\"\n  [options ind zloc]\n  (let [coll?-seq (zmap zcoll? zloc)] (reduce #(or %1 %2) nil coll?-seq)))\n\n;;\n;; # Put things on the same line\n;;\n\n(defn wrap-zmap\n  \"Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin.\"\n  [caller\n   {:keys [width rightcnt max-length],\n    {:keys [wrap-after-multi?]} caller,\n    :as options} ind coll-print]\n  #_(prn \"wz:\" coll-print)\n  (let [last-index (dec (count coll-print))\n        rightcnt (fix-rightcnt rightcnt)]\n    (loop [cur-seq coll-print\n           cur-ind ind\n           index 0\n           previous-newline? false\n           ; transient here slows things down, interestingly enough\n           out []]\n      (if-not cur-seq\n        out\n        (let [next-seq (first cur-seq)]\n          (when next-seq\n            (let [multi? (> (count (first cur-seq)) 1)\n                  this-seq (first cur-seq)\n                  _ (log-lines options \"wrap-zmap:\" ind this-seq)\n                  _ (dbg options \"wrap-zmap: ind:\" ind \"this-seq:\" this-seq)\n                  [linecnt max-width lines] (style-lines options ind this-seq)\n                  last-width (last lines)\n                  len (- last-width ind)\n                  len (max 0 len)\n                  newline? (= (nth (first this-seq) 2) :newline)\n                  width (if (= index last-index) (- width rightcnt) width)\n                  ; need to check size, and if one line and fits, should fit\n                  fit? (and (not newline?)\n                            (or (zero? index)\n                                (and (if multi? (= linecnt 1) true)\n                                     (<= (+ cur-ind len) width))))\n                  new-ind (cond\n                            (or (= (nth (first this-seq) 2) :comment)\n                                (= (nth (first this-seq) 2) :comment-inline))\n                              (inc width)\n                            (and multi? (> linecnt 1) (not wrap-after-multi?))\n                              width\n                            fit? (+ cur-ind len 1)\n                            newline? ind\n                            :else (+ ind len 1))]\n              #_(prn \"------ this-seq:\" this-seq\n                     \"lines:\" lines\n                     \"linecnt:\" linecnt\n                     \"multi?\" multi?\n                     \"newline?:\" newline?\n                     \"previous-newline?:\" previous-newline?\n                     \"linecnt:\" linecnt\n                     \"max-width:\" max-width\n                     \"last-width:\" last-width\n                     \"len:\" len\n                     \"cur-ind:\" cur-ind\n                     \"new-ind:\" new-ind\n                     \"width:\" width\n                     \"fit?\" fit?)\n              ; need to figure out what to do with a comment,\n              ; want to force next line to not fit whether or not\n              ; this line fit.  Comments are already multi-line, and\n              ; it is really not clear what multi? does in this routine\n              (recur\n                (next cur-seq)\n                new-ind\n                (inc index)\n                newline?\n                ; TODO: concat-no-nil fails here, why?\n                (concat\n                  out\n                  (if fit?\n                    (if (not (zero? index))\n                      (concat-no-nil [[\" \" :none :whitespace]] this-seq)\n                      this-seq)\n                    (if newline?\n                      [[(str \"\\n\" (blanks (dec new-ind))) :none :indent]]\n                      (if previous-newline?\n                        (concat-no-nil [[\" \" :none :indent]] this-seq)\n                        (concat-no-nil [[(str \"\\n\" (blanks ind)) :none :indent]]\n                                       this-seq)))))))))))))\n(defn remove-nl\n  \"Remove any [_ _ :newline] from the seq.\"\n  [coll]\n  (remove #(= (nth (first %) 2) :newline) coll))\n\n(defn internal-validate\n  \"Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error.\"\n  [options error-str]\n  (let [errors (validate-options options)\n        errors (when errors\n                 (str \"Options resulting from \" error-str\n                      \" had these errors: \" errors))]\n    (if (not (empty? errors))\n      (throw (#?(:clj Exception.\n                 :cljs js/Error.)\n              errors))\n      options)))\n\n(defn fzprint-vec*\n  \"Print basic stuff like a vector or a set.  Several options for how to\n  print them.\"\n  [caller l-str r-str\n   {:keys [rightcnt in-code?],\n    {:keys [wrap-coll? wrap? binding? option-fn-first respect-nl? sort?\n            sort-in-code?]}\n      caller,\n    :as options} ind zloc]\n  (if (and binding? (= (:depth options) 1))\n    (fzprint-binding-vec options ind zloc)\n    (let [l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          r-str-vec (rstr-vec options ind zloc r-str)\n          new-options (when option-fn-first\n                        (let [first-sexpr (zsexpr (zfirst-no-comment zloc))]\n                          (internal-validate\n                            (option-fn-first options first-sexpr)\n                            (str \":vector :option-fn-first called with \"\n                                 first-sexpr))))\n          #_(prn \"new-options:\" new-options)\n          {{:keys [wrap-coll? wrap? binding? option-fn-first respect-nl? sort?\n                   sort-in-code?]}\n             caller,\n           :as options}\n            (merge-deep options new-options)\n          ; If sort? is true, then respect-nl? makes no sense.  At present,\n          ; sort? and respect-nl? are not both supported for the same structure,\n          ; so this doesn't really matter, but if in the future they were, this\n          ; would help.\n          respect-nl? (and respect-nl? (not sort?))\n          new-ind (+ (count l-str) ind)\n          _ (dbg-pr options \"fzprint-vec*:\" (zstring zloc) \"new-ind:\" new-ind)\n          zloc-seq\n            (if respect-nl? (zmap-w-nl identity zloc) (zmap identity zloc))\n          zloc-seq (if (and sort? (if in-code? sort-in-code? true))\n                     (order-out caller options identity zloc-seq)\n                     zloc-seq)\n          coll-print (if (zero? (zcount zloc))\n                       [[[\"\" :none :whitespace]]]\n                       (fzprint-seq options new-ind zloc-seq))\n          _ (dbg-pr options \"fzprint-vec*: coll-print:\" coll-print)\n          ; If we got any nils from fzprint-seq and we were in :one-line mode\n          ; then give up -- it didn't fit on one line.\n          coll-print (if-not (contains-nil? coll-print) coll-print)\n          one-line (when coll-print\n                     ; should not be necessary with contains-nil? above\n                     (apply concat-no-nil\n                       (interpose [[\" \" :none :whitespace]]\n                         ; This causes single line things to also respect-nl\n                         ; when it is enabled.  Could be separately controlled\n                         ; instead of with :respect-nl? if desired.\n                         (if respect-nl? coll-print (remove-nl coll-print)))))\n          _ (log-lines options \"fzprint-vec*:\" new-ind one-line)\n          one-line-lines (style-lines options new-ind one-line)]\n      (when one-line-lines\n        (if (fzfit-one-line options one-line-lines)\n          (concat-no-nil l-str-vec one-line r-str-vec)\n          (if (or (and (not wrap-coll?) (any-zcoll? options new-ind zloc))\n                  (not wrap?))\n            (concat-no-nil l-str-vec\n                           (apply concat-no-nil\n                             (interpose [[(str \"\\n\" (blanks new-ind)) :none\n                                          :indent]]\n                               (remove-nl coll-print)))\n                           r-str-vec)\n            ; Since there are either no collections in this vector or set or\n            ; whatever, or if there are, it is ok to wrap them, print it\n            ; wrapped on the same line as much as possible:\n            ;           [a b c d e f\n            ;            g h i j]\n            (concat-no-nil\n              l-str-vec\n              (do (dbg options \"fzprint-vec*: wrap coll-print:\" coll-print)\n                  (wrap-zmap caller options new-ind coll-print))\n              r-str-vec)))))))\n\n(defn fzprint-vec\n  [options ind zloc]\n  (fzprint-vec* :vector \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-array\n  [options ind zloc]\n  (fzprint-vec* :array \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-set\n  \"Pretty print and focus style a :set element.\"\n  [options ind zloc]\n  (fzprint-vec* :set \"#{\" \"}\" (rightmost options) ind zloc))\n\n; not clear transient helps here\n(defn interpose-either\n  \"Do the same as interpose, but different seps depending on pred?.\"\n  [sep-true sep-nil pred? coll]\n  (loop [coll coll\n         out (transient [])\n         interpose? nil]\n    (if (empty? coll)\n      (persistent! out)\n      (recur (next coll)\n             (if interpose?\n               (conj-it! out sep-true (first coll))\n               (if (zero? (count out))\n                 (conj! out (first coll))\n                 (conj-it! out sep-nil (first coll))))\n             (pred? (first coll))))))\n\n; transient helped a lot here\n(defn interpose-either-nl-hf\n  \"Do the same as interpose, but different seps depending on pred-fn\n  return and nl-separator?.\"\n  [sep-true sep-true-nl sep-nil sep-nil-nl\n   {:keys [nl-separator? nl-separator-flow?], :as suboptions} ;nl-separator?\n   pred-fn coll]\n  (loop [coll coll\n         out (transient [])\n         interpose? nil\n         add-nl? nil]\n    (if (empty? coll)\n      (apply concat-no-nil (persistent! out))\n      (let [[hangflow style-vec] (first coll)]\n        (recur (next coll)\n               (if interpose?\n                 (conj-it! out (if add-nl? sep-true-nl sep-true) style-vec)\n                 (if (zero? (count out))\n                   ;(empty? out)\n                   (conj! out style-vec)\n                   (conj-it! out (if add-nl? sep-nil-nl sep-nil) style-vec)))\n               (when pred-fn (pred-fn style-vec))\n               ; should we put an extra new-line before the next element?\n               ; Two styles here:\n               ;  o  always put one if the previous pair contained a new-line\n               ;     which could be (but is not) the default\n               ;     To do this you would do:\n               ;       (and nl-separator? (not (single-line? style-vec)))\n               ;  o  put one only if the previous right hand part of the\n               ;     pair did a flow (which is the current default)\n               ;     To do this, you look for whether or not the return\n               ;     from fzprint-map-two-up said it was a flow\n               (and nl-separator? (= hangflow :flow)))))))\n\n(defn interpose-nl-hf\n  \"Put a single or double line between pairs returned from fzprint-map-two-up.\n  The first argument is the map resulting from (:map options) or (:pair options)\n  or whatever.  It should have :nl-separator? and :nl-separator-flow? in it.\"\n  [suboptions ind coll]\n  (interpose-either-nl-hf nil\n                          nil\n                          [[(str \"\\n\" (blanks ind)) :none :indent]]\n                          [[(str \"\\n\") :none :indent]\n                           [(str \"\\n\" (blanks ind)) :none :indent]]\n                          suboptions\n                          #_(:nl-separator? suboptions)\n                          nil\n                          coll))\n\n(defn fzprint-map*\n  [caller l-str r-str\n   {:keys [one-line? ztype map-depth in-code?],\n    {:keys [comma? key-ignore key-ignore-silent nl-separator? force-nl? lift-ns?\n            lift-ns-in-code?]}\n      caller,\n    :as options} ind zloc]\n  (let [options (assoc options :map-depth (inc map-depth))\n        zloc (if (and (= ztype :sexpr) (or key-ignore key-ignore-silent))\n               (map-ignore caller options zloc)\n               zloc)\n        [no-sort? pair-seq] (partition-all-2-nc options (zseqnws zloc))\n        [ns lift-pair-seq] (when (and lift-ns?\n                                      (if in-code? lift-ns-in-code? true))\n                             (zlift-ns pair-seq))\n        l-str (if ns (str \"#:\" ns l-str) l-str)\n        pair-seq (or lift-pair-seq pair-seq)\n        pair-seq\n          (if no-sort? pair-seq (order-out caller options first pair-seq))\n        indent (count l-str)\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str)]\n    (if (empty? pair-seq)\n      (concat-no-nil l-str-vec r-str-vec)\n      (let [_ (dbg options\n                   \"fzprint-map*:\" (zstring zloc)\n                   \"ind:\" ind\n                   \"comma?\" comma?\n                   \"rightcnt:\" (:rightcnt options))\n            ; A possible one line representation of this map, but this is\n            ; optimistic and needs to be validated.\n            pair-print-one-line\n              (fzprint-map-two-up\n                caller\n                (if one-line? options (assoc options :one-line? true))\n                (+ indent ind)\n                comma?\n                pair-seq)\n            pair-print-one-line (remove-hangflow pair-print-one-line)\n            ; Does it fit on line line?\n            pair-print-one-line\n              (when (fzfit-one-line\n                      options\n                      (style-lines options (+ indent ind) pair-print-one-line))\n                pair-print-one-line)\n            one-line (when pair-print-one-line\n                       (apply concat-no-nil\n                         (interpose-either [[\", \" :none :whitespace]]\n                                           [[\" \" :none :whitespace]]\n                                           (constantly comma?)\n                                           pair-print-one-line)))\n            one-line-lines (style-lines options (+ indent ind) one-line)\n            one-line (when (fzfit-one-line options one-line-lines) one-line)]\n        (if one-line\n          (concat-no-nil l-str-vec one-line r-str-vec)\n          ; It didn't fit on one line.\n          (when (not one-line?)\n            ; We weren't required to fit it on one line\n            (let [pair-print (fzprint-map-two-up caller\n                                                 options\n                                                 (+ indent ind)\n                                                 comma?\n                                                 pair-seq)]\n              (concat-no-nil l-str-vec\n                             ;(apply concat-no-nil\n                             (interpose-either-nl-hf\n                               [[\",\" ;(str \",\" (blanks (inc ind)))\n                                 :none :whitespace]\n                                [(str \"\\n\" (blanks (inc ind))) :none :indent]]\n                               [[\",\" ;(str \",\" (blanks (inc ind)))\n                                 :none :whitespace]\n                                [(str \"\\n\" (blanks (inc ind))) :none :indent]\n                                [(str \"\\n\" (blanks (inc ind))) :none :indent]]\n                               [[(str \"\\n\" (blanks (inc ind))) :none :indent]]\n                               [[(str \"\\n\" (blanks (inc ind))) :none :indent]\n                                [(str \"\\n\" (blanks (inc ind))) :none :indent]]\n                               (:map options)\n                               ;nl-separator?\n                               #(and comma?\n                                     (not= (nth (first %) 2) :comment)\n                                     (not= (nth (first %) 2) :comment-inline))\n                               pair-print)\n                             ; )\n                             r-str-vec))))))))\n\n(defn fzprint-map\n  \"Format a real map. ONLY WORKES ON STRUCTURES AT PRESENT\"\n  [options ind zloc]\n  (let [[ns lifted-map] nil]\n    ;(zlift-ns zloc)]\n    (if ns\n      (fzprint-map* :map\n                    (str \"#:\" ns \"{\")\n                    \"}\"\n                    (rightmost options)\n                    ind\n                    lifted-map)\n      (fzprint-map* :map \"{\" \"}\" (rightmost options) ind zloc))))\n\n(defn object-str?\n  \"Return true if the string starts with #object[\"\n  [s]\n  (re-find #\"^#object\\[\" s))\n\n(defn fzprint-object\n  \"Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]\"\n  ([options ind zloc zloc-value]\n   (fzprint-vec* :object\n                 \"#object[\"\n                 \"]\"\n                 options\n                 ind\n                 (zobj-to-vec zloc zloc-value)))\n  ([options ind zloc]\n   (fzprint-vec* :object \"#object[\" \"]\" options ind (zobj-to-vec zloc))))\n\n(defn hash-identity-str\n  \"Find the hash-code identity for an object.\"\n  [obj]\n  #?(:clj (Integer/toHexString (System/identityHashCode obj))\n     :cljs (str (hash obj))))\n\n; (with-out-str\n;    (printf \"%08x\" (System/identityHashCode obj))))\n\n(defn fzprint-atom\n  [{{:keys [object?]} :atom, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc (zderef zloc))\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n          arg-1 (str \"Atom@\" (hash-identity-str zloc))\n          arg-1-indent (+ ind indent 1 (count arg-1))]\n      (dbg-pr options\n              \"fzprint-atom: arg-1:\" arg-1\n              \"zstring arg-1:\" (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1 (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost options)\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       (zderef zloc))\n                     r-str-vec))))\n\n(defn fzprint-future-promise-delay-agent\n  \"Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc.\"\n  [options ind zloc]\n  (let [zloc-type (cond (zfuture? zloc) :future\n                        (zpromise? zloc) :promise\n                        (zdelay? zloc) :delay\n                        (zagent? zloc) :agent\n                        :else (throw (#?(:clj Exception.\n                                         :cljs js/Error.)\n                                      \"Not a future, promise, or delay:\"\n                                      (zstring zloc))))]\n    (if (and (:object? (options zloc-type)) (object-str? (zstring zloc)))\n      (if (or (= zloc-type :agent) (realized? zloc))\n        (fzprint-object options ind zloc (zderef zloc))\n        (fzprint-object options ind zloc))\n      (let [l-str \"#<\"\n            r-str \">\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n            type-str (case zloc-type\n                       :future \"Future@\"\n                       :promise \"Promise@\"\n                       :delay \"Delay@\"\n                       :agent \"Agent@\")\n            arg-1 (str type-str (hash-identity-str zloc))\n            #?@(:clj [arg-1\n                      (if (and (= zloc-type :agent) (agent-error zloc))\n                        (str arg-1 \" FAILED\")\n                        arg-1)])\n              arg-1-indent\n            (+ ind indent 1 (count arg-1)) zloc-realized?\n            (if (= zloc-type :agent) true (realized? zloc)) value\n            (if zloc-realized?\n              (zderef zloc)\n              (case zloc-type\n                :future \"pending\"\n                :promise \"not-delivered\"\n                :delay \"pending\"))\n              options\n            (if zloc-realized? options (assoc options :string-str? true))]\n        (dbg-pr options\n                \"fzprint-fpda: arg-1:\" arg-1\n                \"zstring arg-1:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :unknown\n                                         (rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         value)\n                       r-str-vec)))))\n\n(defn fzprint-fn-obj\n  \"Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper.\"\n  [{{:keys [object?]} :fn-obj, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc)\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options :fn) :left]]\n          r-str-vec (rstr-vec options (+ indent ind) zloc r-str :fn)\n          arg-1-left \"Fn@\"\n          arg-1-right (hash-identity-str zloc)\n          arg-1-indent (+ ind indent 1 (count arg-1-left) (count arg-1-right))\n          class-str (pr-str #?(:clj (class zloc)\n                               :cljs (type zloc)))\n          #?@(:clj [[class-name & more]\n                    (s/split (s/replace-first class-str #\"\\$\" \"/\") #\"\\$\") color\n                    (if (re-find #\"clojure\" class-name)\n                      (zcolor-map options :fn)\n                      :none) arg-2 (str class-name (when more \"[fn]\"))]\n              :cljs [name-js (str (.-name zloc)) color\n                     (if (or (re-find #\"^clojure\" name-js)\n                             (re-find #\"^cljs\" name-js))\n                       (zcolor-map options :fn)\n                       :none) name-split (clojure.string/split name-js #\"\\$\")\n                     arg-2\n                     (str (apply str (interpose \".\" (butlast name-split)))\n                          \"/\"\n                          (last name-split))])]\n      (dbg-pr options\n              \"fzprint-fn-obj: arg-1:\"\n              arg-1-left\n              arg-1-right\n              \"zstring arg-1:\"\n              (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1-left (zcolor-map options :fn) :element]]\n                     [[arg-1-right (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost (assoc options\n                                                    :string-str? true\n                                                    :string-color color))\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       arg-2)\n                     r-str-vec))))\n\n(defn fzprint-ns\n  [options ind zloc]\n  (let [l-str \"#<\"\n        r-str \">\"\n        indent (count l-str)\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n        arg-1 \"Namespace\"\n        arg-1-indent (+ ind indent 1 (count arg-1))]\n    (dbg-pr options\n            \"fzprint-atom: arg-1:\" arg-1\n            \"zstring arg-1:\" (zstring zloc))\n    (concat-no-nil l-str-vec\n                   [[arg-1 (zcolor-map options :none) :element]]\n                   (fzprint-hang-one :unknown\n                                     (rightmost options)\n                                     arg-1-indent\n                                     (+ indent ind)\n                                     (ns-name zloc))\n                   r-str-vec)))\n\n(defn fzprint-record\n  [{{:keys [record-type? to-string?]} :record, :as options} ind zloc]\n  (if to-string?\n    (fzprint* options ind (. zloc toString))\n    (if-not record-type?\n      ; if not printing as record-type, turn it into map\n      (fzprint* options ind (into {} zloc))\n      (let [l-str \"#\"\n            r-str \"\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n            arg-1 (pr-str #?(:clj (class zloc)\n                             :cljs (type zloc)))\n            arg-1 (let [tokens (clojure.string/split arg-1 #\"\\.\")]\n                    (apply str\n                      (conj (into [] (interpose \".\" (butlast tokens)))\n                            \"/\"\n                            (last tokens))))\n            arg-1-indent (+ ind indent 1 (count arg-1))]\n        (dbg-pr options\n                \"fzprint-record: arg-1:\" arg-1\n                \"zstring zloc:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :record\n                                         options\n                                         ;(rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         ; this only works because\n                                         ; we never actually get here\n                                         ; with a zipper, just an sexpr\n                                         (into {} zloc))\n                       r-str-vec)))))\n\n(defn fzprint-uneval\n  \"Trim the #_ off the front of the uneval, and try to print it.\"\n  [options ind zloc]\n  (let [l-str \"#_\"\n        r-str \"\"\n        indent (count l-str)\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n        uloc (zparseuneval zloc)\n        #_(def zs (zstring zloc))\n        #_(def un uloc)]\n    (dbg-pr options\n            \"fzprint-uneval: zloc:\" (zstring zloc)\n            \"uloc:\" (zstring uloc))\n    (concat-no-nil l-str-vec\n                   (fzprint* (assoc options\n                               :color-map (:color-map (:uneval options)))\n                             (+ indent ind)\n                             uloc)\n                   r-str-vec)))\n\n(defn fzprint-meta\n  \"Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost.\"\n  [options ind zloc]\n  (let [l-str \"^\"\n        r-str \"\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)]\n    (dbg-pr options \"fzprint-meta: zloc:\" (zstring zloc))\n    (concat-no-nil\n      l-str-vec\n      (fzprint-flow-seq\n        ; No rightmost, because this isn't a collection.\n        ; This is essentially two separate things.\n        options\n        ; no indent for second line, as the leading ^ is\n        ; not a normal collection beginning\n        ; TODO: change this to (+ (count l-str) ind)\n        (apply vector (+ (count l-str) ind) (repeat (dec (zcount zloc)) ind))\n        ;[(inc ind) ind]\n        (zmap identity zloc))\n      r-str-vec)))\n\n\n(defn fzprint-reader-macro\n  \"Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used.\"\n  [options ind zloc]\n  (let [zstr (zstring (zfirst zloc))\n        ; rewrite-cljs parses #?@ differently from rewrite-clj.  In\n        ; rewrite-cljs zfirst is ?@, not ?, so deal with that.\n        ; Not clear which is correct, I could see it go either way.\n        alt-at? (and (= (count zstr) 2) (= (subs zstr 1 2) \"@\"))\n        reader-cond? (= (subs zstr 0 1) \"?\")\n        ; are we dealing with a namespaced map?\n        namespaced? (= (subs zstr 0 1) \":\")\n        at? (or (= (ztag (zsecond zloc)) :deref) alt-at?)\n        l-str (cond (and reader-cond? at?) \"#?@\"\n                    (and reader-cond? (zcoll? (zsecond zloc))) \"#?\"\n                    reader-cond?\n                      (throw (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"Unknown reader macro: '\" (zstring zloc)\n                                   \"' zfirst zloc: \" (zstring (zfirst zloc)))))\n                    namespaced? (str \"#\" zstr)\n                    :else \"#\")\n        r-str \"\"\n        ; Error to debug zpst\n        #_(when (:dbg-bug? options) (+ \"a\" \"b\"))\n        indent (count l-str)\n        ; we may want to color this based on something other than\n        ; its actual character string\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str)\n        floc\n          (if (and at? (not alt-at?)) (zfirst (zsecond zloc)) (zsecond zloc))]\n    (dbg-pr options\n            \"fzprint-reader-macro: zloc:\" (zstring zloc)\n            \"floc:\" (zstring floc)\n            \"l-str:\" l-str)\n    (concat-no-nil\n      l-str-vec\n      ; Because there is a token here in the zipper, we need something to\n      ; make the focus positioning come out right.\n      [[\"\" :none :element]]\n      (if reader-cond?\n        ; yes rightmost, this is a collection\n        (fzprint-map* :reader-cond\n                      \"(\"\n                      \")\"\n                      (rightmost options)\n                      (+ indent ind)\n                      floc)\n        ; not reader-cond?\n        (fzprint-flow-seq options\n                          (+ indent ind)\n                          (let [zloc-seq (zmap identity zloc)]\n                            (if namespaced? (next zloc-seq) zloc-seq))))\n      r-str-vec)))\n\n(defn fzprint-prefix*\n  \"Print the single item after a variety of prefix characters.\"\n  [options ind zloc l-str]\n  (let [r-str \"\"\n        indent (count l-str)\n        ; Since this is a single item, no point in figure an indent\n        ; based on the l-str length.\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        ; Either these both have to be :element, or :left and :right\n        r-str-vec (rstr-vec options (+ indent ind) zloc r-str :right)\n        floc (zfirst zloc)\n        #_(def zqs (zstring zloc))\n        #_(def qun floc)]\n    (dbg-pr options\n            \"fzprint-prefix*: zloc:\" (zstring zloc)\n            \"floc:\" (zstring floc))\n    (concat-no-nil l-str-vec\n                   ; no rightmost, as we don't know if this is a collection\n                   (fzprint* options (+ indent ind) floc)\n                   r-str-vec)))\n\n\n(def prefix-tags\n  {:quote \"'\",\n   :syntax-quote \"`\",\n   :unquote \"~\",\n   :unquote-splicing \"~@\",\n   :deref \"@\",\n   :var \"#'\",\n   :uneval \"#_\"})\n\n(defn prefix-options\n  \"Change options as necessary based on prefix tag.\"\n  [options prefix-tag]\n  (cond (= prefix-tag :uneval) (assoc options\n                                 :color-map (:color-map (:uneval options)))\n        (= prefix-tag :syntax-quote) (assoc-in options\n                                       [:color-map :paren]\n                                       (:syntax-quote-paren (:color-map\n                                                              options)))\n        :else options))\n\n;; Fix fzprint* to look at cursor to see if there is one, and\n;; fzprint to set cursor with binding.  If this works, might pass\n;; it around.  Maybe pass ctx to everyone and they can look at it\n;; or something.  But for testing, let's just do this.\n\n;;\n;; # The center of the zprint universe\n;;\n;; Looked into alternative ways to dispatch this, but at the end of\n;; the day, this looked like the best.\n;;\n\n(defn fzprint*\n  \"The pretty print part of fzprint.\"\n  [{:keys [width rightcnt fn-map hex? shift-seq dbg? dbg-print? in-hang?\n           one-line? string-str? string-color depth max-depth trim-comments?\n           in-code? max-hang-depth max-hang-span max-hang-count],\n    :as options} indent zloc]\n  (let [avail (- width indent)\n        ; note that depth affects how comments are printed, toward the end\n        options (assoc options :depth (inc depth))\n        options (if (or dbg? dbg-print?)\n                  (assoc options\n                    :dbg-indent (str (get options :dbg-indent \"\")\n                                     (cond one-line? \"o\"\n                                           in-hang? \"h\"\n                                           :else \".\")))\n                  options)\n        _ (dbg options\n               \"fzprint* **** rightcnt:\"\n               rightcnt\n               (pr-str (zstring zloc)))\n        dbg-data @fzprint-dbg\n        dbg-focus? (and dbg? (= dbg-data (second (zfind-path zloc))))\n        options (if dbg-focus? (assoc options :dbg :on) options)\n        _ (if dbg-focus? (println \"fzprint dbg-data:\" dbg-data))]\n    #_(def zlocx zloc)\n    (cond (and (> depth max-depth) (zcoll? zloc))\n            (if (= zloc (zdotdotdot))\n              [[\"...\" (zcolor-map options :none) :element]]\n              [[\"##\" (zcolor-map options :keyword) :element]])\n          (and in-hang?\n               (not in-code?)\n               ;(> (/ indent width) 0.3)\n               (or (> (- depth in-hang?) max-hang-span)\n                   (and (not one-line?)\n                        (> (zcount zloc) max-hang-count)\n                        (> depth max-hang-depth))))\n            nil\n          (zrecord? zloc) (fzprint-record options indent zloc)\n          (zlist? zloc) (fzprint-list options indent zloc)\n          (zvector? zloc) (fzprint-vec options indent zloc)\n          (zmap? zloc) (fzprint-map options indent zloc)\n          (zset? zloc) (fzprint-set options indent zloc)\n          (zanonfn? zloc) (fzprint-anon-fn options indent zloc)\n          (zfn-obj? zloc) (fzprint-fn-obj options indent zloc)\n          (zarray? zloc)\n            (if (:object? (:array options))\n              (fzprint-object options indent zloc)\n              (fzprint-array #?(:clj (if (:hex? (:array options))\n                                       (assoc options\n                                         :hex? (:hex? (:array options))\n                                         :shift-seq (zarray-to-shift-seq zloc))\n                                       options)\n                                :cljs options)\n                             indent\n                             (zexpandarray zloc)))\n          (zatom? zloc) (fzprint-atom options indent zloc)\n          (zmeta? zloc) (fzprint-meta options indent zloc)\n          (prefix-tags (ztag zloc)) (fzprint-prefix*\n                                      (prefix-options options (ztag zloc))\n                                      indent\n                                      zloc\n                                      (prefix-tags (ztag zloc)))\n          (zns? zloc) (fzprint-ns options indent zloc)\n          (or (zpromise? zloc) (zfuture? zloc) (zdelay? zloc) (zagent? zloc))\n            (fzprint-future-promise-delay-agent options indent zloc)\n          (zreader-macro? zloc) (fzprint-reader-macro options indent zloc)\n          ; This is needed to not be there for newlines in parse-string-all,\n          ; but is needed for respect-nl? support.\n          (and (= (ztag zloc) :newline) (> depth 0)) [[\"\\n\" :none :newline]]\n          :else\n            (let [zstr (zstring zloc)\n                  overflow-in-hang?\n                    (and in-hang?\n                         (> (+ (count zstr) indent (or rightcnt 0)) width))]\n              (cond\n                (zcomment? zloc)\n                  (let [zcomment\n                          ; Do we have a file-level comment that is way too\n                          ; long??\n                          (if (and (zero? depth) (not trim-comments?))\n                            zstr\n                            (clojure.string/replace zstr \"\\n\" \"\"))\n                        ; Only check for inline comments if we are doing them\n                        ; otherwise we get left with :comment-inline element\n                        ; types that don't go away\n                        inline-spaces (when (:inline? (:comment options))\n                                        (zinlinecomment? zloc))]\n                    (if (and (:count? (:comment options)) overflow-in-hang?)\n                      (do (dbg options \"fzprint*: overflow comment ========\")\n                          nil)\n                      #_[[zcomment (zcolor-map options :comment) :comment]]\n                      (if inline-spaces\n                        [[zcomment (zcolor-map options :comment) :comment-inline\n                          inline-spaces]]\n                        [[zcomment (zcolor-map options :comment) :comment]])))\n                ; Really just testing for whitespace, comments filtered above\n                (zwhitespaceorcomment? zloc) [[zstr :none :whitespace]]\n                ; At this point, having filtered out whitespace and\n                ; comments above, now we expect zsexpr will work for all of\n                ; the remaining things.\n                ;\n                ; If we are going to overflow, and we are doing a hang, let's\n                ; stop now!\n                overflow-in-hang?\n                  (do (dbg options \"fzprint*: overflow <<<<<<<<<<\") nil)\n                (zkeyword? zloc) [[zstr (zcolor-map options :keyword) :element]]\n                (string? (zsexpr zloc))\n                  [[(if string-str?\n                      (str (zsexpr zloc))\n                      ; zstr\n                      (zstring zloc))\n                    (if string-color string-color (zcolor-map options :string))\n                    :element]]\n                (showfn? fn-map (zsexpr zloc)) [[zstr (zcolor-map options :fn)\n                                                 :element]]\n                (show-user-fn? options (zsexpr zloc))\n                  [[zstr (zcolor-map options :user-fn) :element]]\n                (number? (zsexpr zloc))\n                  [[(if hex? (znumstr zloc hex? shift-seq) zstr)\n                    (zcolor-map options :number) :element]]\n                (nil? (zsexpr zloc)) [[zstr (zcolor-map options :nil) :element]]\n                :else [[zstr (zcolor-map options :none) :element]])))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width [s color stype :as element] start]\n  (if-not (= stype :comment)\n    element\n    (let [comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            ;(empty? out)\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)\n        #_(clojure.string/split s #\"\\n\")]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec.\"\n  [style-vec]\n  (butlast (reductions loc-vec 0 style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], :as options} style-vec]\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec style-vec)\n        #_(def stc start-col)\n        _ (dbg options \"fzprint-wrap-comments: style-vec:\" (pr-str style-vec))\n        _ (dbg options \"fzprint-wrap-comments: start-col:\" start-col)\n        wrap-style-vec (mapv (partial wrap-comment width) style-vec start-col)\n        #_(def wsv wrap-style-vec)\n        _ (dbg options \"fzprint-wrap-comments: wrap:\" (pr-str style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (loop [cvec style-vec\n         out []]\n    (if-not cvec\n      out\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            new-element (cond (and (= e :indent) (= ne :comment-inline))\n                                [(blanks nn) c :whitespace]\n                              (= e :comment-inline) [s c :comment]\n                              :else element)]\n        (recur (next cvec) (conj out new-element))))))\n\n;;\n;; # External interface to all fzprint functions\n;;\n\n(defn fzprint\n  \"The pretty print part of fzprint.\"\n  [options indent zloc]\n  #_(def opt options)\n  #_(println \"fzprint: indent:\" indent \"(:indent options)\" (:indent options))\n  ; if we are doing specs, find the docstring and modify it with\n  ; the spec output.\n  #_(println \"fn-name:\" (:fn-name options))\n  #_(println \"spec:\" (:value (:spec options)))\n  (let [zloc (if-not (and (= (:ztype options) :zipper) (:value (:spec options)))\n               zloc\n               (add-spec-to-docstring zloc (:value (:spec options))))\n        style-vec (fzprint* (assoc options\n                              :depth 0\n                              :map-depth 0)\n                            indent\n                            zloc)]\n    style-vec))\n\n;    (if (= (:ztype options) :sexpr)\n;      style-vec\n;      (if (:wrap? (:comment options))\n;        (fzprint-wrap-comments options style-vec)\n;        style-vec))))\n\n;;\n;; # Basic functions for testing results -- used only for tests\n;;\n\n(defn line-count \"Count lines in a string.\" [s] (inc (count (re-seq #\"\\n\" s))))\n\n(defn line-widths\n  \"Return a vector the lengths of lines.\"\n  [s]\n  (map count (clojure.string/split s #\"\\n\")))\n\n(defn max-width\n  \"Split a string into lines, and figure the max width.\"\n  [s]\n  (reduce max (line-widths s)))\n\n;;\n;; # Tab Expansion\n;;\n\n(defn expand-tabs\n  \"Takes a string, and expands tabs inside of the string based\n  on a tab-size argument.\"\n  ([tab-size s]\n   (apply str\n     (loop [char-seq (seq s)\n            cur-len (long 0)\n            out (transient [])]\n       (if (empty? char-seq)\n         (persistent! out)\n         (let [this-char (first char-seq)\n               tab-expansion (if (= this-char \\tab)\n                               (- tab-size (mod cur-len tab-size))\n                               nil)]\n           (recur (rest char-seq)\n                  (if (= this-char \\newline)\n                    0\n                    (+ cur-len (long (or tab-expansion 1))))\n                  (if tab-expansion\n                    (apply conj-it! out (seq (blanks tab-expansion)))\n                    (conj! out this-char))))))))\n  ([s] (expand-tabs 8 s)))\n\n;;\n;; # Needed for expectations testing\n;;\n;; Seems defrecord doesn't work in test environment, which is pretty odd.\n;;\n\n(defrecord r [left right])\n(defn make-record [l r] (new r l r))\n\n;;\n;; End of testing functions\n;;","~:reader-features",["^L",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.zprint/blanks","n","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","zprint.zprint/dots","zprint.zprint/indent","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","zprint.zprint/conj-it!","seq37055","self__4718__auto__","cljs.core/seq","rest","out","cljs.core/first","more","cljs.core/next","cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2","zprint.zprint/split-lf","s","input","cljs.core/not","next-lf","clojure.string.index_of.cljs$core$IFn$_invoke$arity$2","chunk","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","zprint.zprint/split-lf-2","temp__5718__auto__","G__37057","zprint.zprint/zpmap","js/Error","options","f","coll","cljs.core.map.cljs$core$IFn$_invoke$arity$2","coll1","coll2","cljs.core.map.cljs$core$IFn$_invoke$arity$3","zprint.zprint/zat","value","zprint.zprint/fzprint-dbg","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","p__37058","map__37059","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","zprint.zprint/log-lines","dbg-print?","dbg-indent","in-hang?","dbg-output","ind","style-vec","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","zprint.zprint/showfn?","fn-map","f-str","or__4131__auto__","cljs.core/re-find","cljs.core/Symbol","e37061","cljs.core/meta","G__37062","cljs.core/name","e","zprint.zprint/show-user-fn?","user-fn-map","e37063","cljs.core/empty?","zprint.zprint/right-separator-map","p__37064","p__37065","p__37066","map__37067","map__37068","map__37069","vec__37070","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__37073","zprint.zprint/good-enough?","caller","width","rightcnt","dbg?","hang-flow","hang-type-flow","hang-flow-limit","general-hang-adjust","hang-if-equal-flow?","hang-expand","hang-diff","hang-size","hang-adjust","fn-style","p-count","indent-diff","p-lines","p-maxwidth","p-length-seq","p-what","b-lines","b-maxwidth","_","b-what","p-last-maxwidth","cljs.core/last","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","result","and__4120__auto__","zprint.zprint/fix-rightcnt","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","factor","zprint.zprint/in-hang","zprint.zprint/contains-nil?","cljs.core/count","p1__37104#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/coll?","zprint.zprint/concat-no-nil-alt","seq37105","cljs.core/transient","c","cljs.core/persistent!","zprint.zprint/concat-no-nil","seq37106","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","v","o","cljs.core/reduced","cljs.core/conj!","zprint.zprint/force-vector","cljs.core/vector?","cljs.core.into.cljs$core$IFn$_invoke$arity$2","zprint.zprint/keyword-fn?","vec__37109","left","right","clojure.string.split.cljs$core$IFn$_invoke$arity$2","fexpr__37112","p__37113","vec__37114","zprint.zprint/accumulate-ll","count-comment?","cur-len","just-eol?","just-comment?","in","tag","eol?","comment?","count-s","p__37120","p__37121","vec__37122","vec__37125","zprint.zprint/generate-ll","element","vec__37129","l","r","cljs.core/List","zprint.zprint/line-lengths-iter","next-vec","current-string","line-length","previous-comment?","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","vec__37143","vec__37146","advance?","next-string","force-newline?","new-line-length","zprint.zprint/line-lengths","length-vec","vec__37149","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","zprint.zprint/single-line?","p1__37164#","p2__37165#","p1__37166#","clojure.string/includes?","zprint.zprint/find-what","s-vec","vec__37167","what","this","zprint.zprint/style-lines","lengths","cljs.core/max","dbg-ge","p__37173","p__37174","map__37175","vec__37176","zprint.zprint/fzfit","line-count","max-width","style-lines-return","zprint.zprint/fzfit-one-line","lines","zprint.zprint/rightmost","zprint.zprint/not-rightmost","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","zprint.zprint/c-r-pair","commas?","rightmost-pair?","rightmost?","zprint.zprint/str->key","p__37180","map__37181","zprint.zprint/zcolor-map","color-map","key-or-str","G__37183","cljs.core/Keyword","zprint.zprint/hangflow","hangflow?","hang-or-flow","zprint.zprint/fzprint-hang-unless-fail","hindent","findent","fzfn","zloc","G__37184","zprint.zfns/zstring","zprint.zfns/zfirst","hanging","G__37185","G__37186","G__37187","value__37009__auto__","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic","zprint.zprint/replace-color","local-color","vec__37188","vec__37191","string","color","p__37194","p__37195","map__37196","map__37197","vec__37198","zprint.zprint/fzprint-two-up","one-line?","do-in-hang?","map-depth","hang?","dbg-local?","dbg-cnt?","indent","indent-arg","flow?","key-color","key-depth-color","key-value-color","justify-width","lloc","rloc","xloc","pair","vec__37203","vec__37206","local-hang?","local-options","loptions","roptions","local-roptions","value-color-map","G__37209","zprint.zfns/zsexpr","zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic","modifier-set","modifier?","G__37213","zprint.zprint/middle-element?","G__37214","arg-1","zprint.zprint/fzprint*","arg-1-line-count","arg-1-max-width","arg-1-lines","combined-arg-1","G__37215","G__37216","G__37217","arg-1-fit-oneline?","arg-1-fit?","arg-1-width","hanging-width","hanging-spaces","hanging-indent","flow-indent","zprint.zfns/zvector?","vec__37218","zprint.zprint/fzprint-binding-vec","G__37221","G__37222","G__37223","hang-count","zprint.zfns/zcount","hanging-lines","fit?","flow-it?","flow","flow-lines","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","G__37224","G__37225","G__37226","G__37227","zprint.zprint/fzprint-flow-seq","cljs.core/nnext","p__37233","map__37234","map__37235","zprint.zprint/fzprint-justify-width","justify?","firsts","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/nil?","p1__37228#","G__37238","G__37239","G__37240","style-seq","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","each-one-line?","p1__37229#","p2__37230#","p1__37231#","p2__37232#","x__4219__auto__","y__4220__auto__","cljs.core/second","G__37242","zprint.zprint/fit-within?","size","depth","zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3","remaining","zprint.zprint/remove-hangflow","hf-style-vec","p__37243","map__37244","map__37245","zprint.zprint/fzprint-map-two-up","force-nl?","parallel?","caller-map","len","caller-options","justify-options","G__37250","G__37251","beginning-coll","cljs.core/butlast","beginning-remaining","zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2","beginning","zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3","cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic","end-coll","end-remaining","end","temp__5720__auto__","end-result","zprint.zprint/compare-keys","x","y","cljs.core/compare","zprint.zprint/compare-ordered-keys","key-value","zdotdotdot","p__37254","map__37255","map__37256","zprint.zprint/order-out","sort?","sort-in-code?","key-order","in-code?","access","p1__37252#","p2__37253#","cljs.core.sort.cljs$core$IFn$_invoke$arity$2","G__37260","G__37261","fexpr__37259","zprint.zfns/zdotdotdot","G__37262","G__37263","zprint.zprint/pair-element?","zprint.zfns/zcomment?","zprint.zfns/zuneval?","p__37264","map__37265","zprint.zprint/remove-key-seq","m","ks","this-key","next-key","removed-map","G__37267","G__37268","zprint.zprint/ignore-key-seq-silent","cljs.core.get_in.cljs$core$IFn$_invoke$arity$3","cljs.core.get.cljs$core$IFn$_invoke$arity$3","zprint.zprint/ignore-key-seq","cljs.core/assoc-in","p__37269","map__37270","map__37271","zprint.zprint/map-ignore","key-ignore","key-ignore-silent","ignored-silent","ignored","p__37275","map__37276","zprint.zprint/partition-all-2-nc","max-length","no-sort?","index","vec__37284","new-remaining","pair-vec","new-no-sort?","vec__37287","comment-seq","rest-seq","p1__37274#","cljs.core/split-with","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","zprint.zprint/cleave-end","G__37292","zprint.zfns/zsymbol?","G__37293","zprint.zfns/zreader-cond-w-symbol?","vec__37294","rev-seq","cljs.core/reverse","split-non-coll","p1__37290#","zprint.zfns/zcoll?","zprint.zfns/zreader-cond-w-coll?","cljs.core/list","remainder","cljs.core.take.cljs$core$IFn$_invoke$arity$2","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","zprint.zprint/partition-all-sym","part-sym","p1__37297#","cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2","zprint.zfns/znil?","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","vec__37313","next-remaining","new-out","G__37322","cljs.core/ffirst","G__37324","G__37325","cljs.core/nthnext","G__37326","G__37327","cljs.core/cons","G__37329","zprint.zprint/rstr-vec","r-str","r-type","nl","G__37330","zprint.zfns/zlast","zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5","p__37331","map__37332","map__37333","nl-separator?","G__37336","l-str","l-str-vec","r-str-vec","zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4","G__37337","G__37338","G__37339","zprint.zprint/interpose-nl-hf","zprint.zfns/zseqnws","p__37340","map__37341","zprint.zprint/fzprint-hang","zloc-count","G__37343","G__37347","fexpr__37346","G__37348","G__37349","G__37350","hr-lines","fd-lines","hr-good?","p__37351","map__37352","map__37353","zprint.zprint/fzprint-pairs","G__37356","G__37357","G__37358","G__37359","vec__37360","part","zprint.zfns/zmap-right","cljs.core/identity","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","p__37364","map__37365","map__37366","zprint.zprint/fzprint-extend","G__37369","G__37370","G__37371","G__37372","p1__37363#","zprint.zprint/concatv!","seq37373","G__37374","self__4717__auto__","cols","col","zprint.zprint/fzprint-one-line","seq-right","zprint.zfns/zmap","last-index","gt-1?","zloc-seq","new-ind","cljs.core/long","vec__37381","vec__37384","next-zloc","sep","next-options","next-out","next-lines","zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic","p__37389","map__37390","zprint.zprint/fzprint-seq","p1__37387#","p2__37388#","zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4","G__37392","G__37393","G__37394","cljs.core.repeat.cljs$core$IFn$_invoke$arity$1","G__37395","G__37396","G__37397","G__37400","coll-print","one-line","cljs.core.interpose.cljs$core$IFn$_invoke$arity$2","one-line-lines","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","cljs.core.interleave.cljs$core$IFn$_invoke$arity$2","p1__37398#","cljs.core/PersistentVector","zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4","p__37401","map__37402","zprint.zprint/fzprint-hang-one","G__37404","G__37405","G__37406","G__37407","zprint.zprint/count-constant-pairs","seq-right-rev","element-count","constant-required?","pair-size","zprint.zfns/zconstant?","p__37408","map__37409","map__37410","zprint.zprint/constant-pair","constant-pair?","constant-pair-min","paired-item-count","non-paired-item-count","pair-seq","G__37414","zprint.zprint/fzprint-hang-remaining","p__37415","map__37416","map__37417","hang-avoid","vec__37420","vec__37423","vec__37426","flow-result","G__37429","G__37430","G__37431","G__37432","G__37433","G__37434","hang-result","G__37435","G__37436","G__37437","G__37438","G__37439","G__37440","zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7","zprint.zprint/body-set","zprint.zprint/body-map","zprint.zprint/noarg1-set","zprint.zprint/noarg1-map","zprint.zprint/noarg1","fn-type","zprint.zprint/fn-style->caller","p__37441","map__37442","zprint.zprint/allow-one-line?","fn-force-nl","fn-gt2-force-nl","fn-gt3-force-nl","future-caller","p__37445","map__37446","map__37447","zprint.zprint/fzprint-list*","no-arg1?","l-str-len","arg-1-coll?","G__37451","zprint.zfns/zkeyword?","G__37452","fn-str","G__37453","G__37454","one-line-ok?","indent-adj","default-indent","G__37455","zprint.zfns/zlist?","arg-1-indent","G__37457","one-line-ind","G__37458","G__37459","G__37460","G__37462","zprint.zfns/zsecond","vec__37463","binding-style-vec","G__37466","G__37467","G__37468","G__37469","G__37470","G__37471","G__37472","G__37473","zprint.zfns/znthnext","G__37474","G__37475","G__37476","G__37480","vec__37481","second-element","third","zprint.zfns/zthird","first-three","G__37484","G__37485","G__37486","G__37487","G__37488","G__37489","zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6","arg-vec-index","G__37493","p1__37444#","G__37494","zprint.zfns/zfind","G__37495","doc-string?","G__37496","mixin-start","mixin-length","mixins?","doc-string","mixins","vec__37497","mixin-sentinal","zprint.zfns/zfourth","G__37500","G__37501","G__37502","G__37503","G__37504","G__37505","G__37506","G__37507","G__37508","G__37509","G__37510","G__37511","G__37512","G__37513","G__37514","G__37515","G__37516","G__37517","G__37518","G__37519","G__37520","G__37521","G__37522","local-indent","zprint.zprint/fzprint-list","zprint.zprint/fzprint-anon-fn","zprint.zprint/any-zcoll?","coll?-seq","p1__37523#","p2__37524#","p__37525","map__37526","map__37527","zprint.zprint/wrap-zmap","wrap-after-multi?","cur-seq","cur-ind","previous-newline?","next-seq","vec__37533","multi?","this-seq","linecnt","last-width","newline?","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","zprint.zprint/remove-nl","p1__37536#","zprint.zprint/internal-validate","error-str","errors","zprint.config.validate_options.cljs$core$IFn$_invoke$arity$1","p__37537","map__37538","map__37539","zprint.zprint/fzprint-vec*","wrap-coll?","wrap?","binding?","option-fn-first","respect-nl?","map__37542","map__37543","new-options","first-sexpr","G__37544","zprint.zfns/zfirst-no-comment","zprint.zfns/zmap-w-nl","zprint.zprint/fzprint-vec","zprint.zprint/fzprint-array","zprint.zprint/fzprint-set","zprint.zprint/interpose-either","sep-true","sep-nil","pred?","interpose?","zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic","G__37548","p__37549","map__37550","zprint.zprint/interpose-either-nl-hf","sep-true-nl","sep-nil-nl","nl-separator-flow?","suboptions","pred-fn","add-nl?","vec__37555","hangflow","p__37559","map__37560","map__37561","zprint.zprint/fzprint-map*","ztype","comma?","lift-ns?","lift-ns-in-code?","vec__37564","vec__37567","ns","lift-pair-seq","zprint.zfns/zlift-ns","pair-print-one-line","cljs.core/constantly","pair-print","p1__37558#","zprint.zprint/fzprint-map","vec__37570","lifted-map","zprint.zprint/object-str?","G__37574","zprint.zprint/fzprint-object","zloc-value","zprint.zfns/zobj-to-vec","zprint.zprint/hash-identity-str","obj","cljs.core/hash","p__37575","map__37576","map__37577","zprint.zprint/fzprint-atom","object?","zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4","zprint.zfns/zderef","zprint.zprint/fzprint-future-promise-delay-agent","zloc-type","zprint.zfns/zfuture?","zprint.zfns/zpromise?","zprint.zfns/zdelay?","zprint.zfns/zagent?","cljs.core/realized?","zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3","type-str","G__37580","zloc-realized?","G__37581","p__37582","map__37583","map__37584","zprint.zprint/fzprint-fn-obj","arg-1-left","arg-1-right","class-str","cljs.core/type","name-js","name-split","arg-2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","zprint.zprint/fzprint-ns","cljs.core/ns-name","p__37587","map__37588","map__37589","zprint.zprint/fzprint-record","record-type?","to-string?","G__37592","G__37593","G__37594","G__37595","G__37596","G__37597","tokens","zprint.zprint/fzprint-uneval","uloc","zprint.zfns/zparseuneval","G__37598","G__37599","G__37600","zprint.zprint/fzprint-meta","zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3","cljs.core/vector","zprint.zprint/fzprint-reader-macro","zstr","G__37601","alt-at?","reader-cond?","namespaced?","at?","G__37603","zprint.zfns/ztag","G__37605","G__37607","floc","G__37608","zprint.zprint/fzprint-prefix*","G__37609","G__37610","G__37611","zprint.zprint/prefix-tags","zprint.zprint/prefix-options","prefix-tag","p__37612","map__37613","hex?","shift-seq","string-str?","string-color","max-depth","trim-comments?","max-hang-depth","max-hang-span","max-hang-count","cljs.core/deref","avail","dbg-data","dbg-focus?","zprint.zfns/zfind-path","zprint.zfns/zrecord?","zprint.zfns/zmap?","zprint.zfns/zset?","zprint.zfns/zanonfn?","zprint.zfns/zfn-obj?","zprint.zfns/zarray?","zprint.zfns/zexpandarray","zprint.zfns/zatom?","zprint.zfns/zmeta?","G__37615","G__37616","zprint.zfns/zns?","zprint.zfns/zreader-macro?","overflow-in-hang?","zcomment","clojure.string/replace","inline-spaces","zprint.zfns/zinlinecomment?","zprint.zfns/zwhitespaceorcomment?","zprint.zfns/znumstr","zprint.zprint/last-space","from-index","x__4222__auto__","y__4223__auto__","seq-after-space","p1__37617#","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","space-index","zprint.zprint/next-space","p1__37618#","p__37619","vec__37620","zprint.zprint/wrap-comment","stype","start","comment-width","semi-str","rest-str","space-str","comment-str","last-space-index","next-comment","clojure.string/trimr","p__37623","vec__37624","zprint.zprint/loc-vec","split","zprint.zprint/style-loc-vec","cljs.core.reductions.cljs$core$IFn$_invoke$arity$3","zprint.zprint/lift-vec","out-vec","element-vec","zprint.zprint/lift-style-vec","p__37627","map__37628","zprint.zprint/fzprint-wrap-comments","start-col","wrap-style-vec","cljs.core.mapv.cljs$core$IFn$_invoke$arity$3","out-style-vec","p__37630","map__37631","zprint.zprint/fzprint-inline-comments","cvec","vec__37639","vec__37642","ne","nn","next-element","new-element","zprint.zprint/fzprint","zprint.zutil/add-spec-to-docstring","zprint.zprint/line-count","cljs.core/re-seq","zprint.zprint/line-widths","zprint.zprint/max-width","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","G__37646","zprint.zprint/expand-tabs","tab-size","char-seq","this-char","tab-expansion","cljs.core/mod","cljs.core/rest","zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2","this__4385__auto__","k__4386__auto__","this__4387__auto__","k37648","else__4388__auto__","G__37652","__extmap","this__4404__auto__","f__4405__auto__","init__4406__auto__","ret__4407__auto__","p__37653","vec__37654","k__4408__auto__","v__4409__auto__","this__4399__auto__","writer__4400__auto__","opts__4401__auto__","pr-pair__4402__auto__","keyval__4403__auto__","cljs.core/pr-sequential-writer","G__37647","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4383__auto__","__meta","this__4380__auto__","__hash","this__4389__auto__","this__4381__auto__","h__4243__auto__","fexpr__37657","coll__4382__auto__","cljs.core/hash-unordered-coll","this37649","other37650","this__4394__auto__","k__4395__auto__","cljs.core/contains?","cljs.core/-with-meta","cljs.core/not-empty","this__4392__auto__","k__4393__auto__","pred__37658","cljs.core/keyword-identical?","expr__37659","G__37661","G__37662","G__37663","G__37664","this__4397__auto__","cljs.core/MapEntry","this__4384__auto__","this__4390__auto__","entry__4391__auto__","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core/-conj","zprint.zprint/r","this__4428__auto__","writer__4429__auto__","cljs.core/-write","G__37651","extmap__4424__auto__","G__37665","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core/record?","zprint.zprint/->r","zprint.zprint/map->r","zprint.zprint/make-record"]]],"~:cache-keys",["~#cmap",[["^2O","rewrite_clj/node/token.cljs"],[1530397449000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^L",[]],"~:deps-syms",["^W","^V","~$rewrite-clj.node.protocols"]]],["~:macro","^V"],[1551476394000],["^2O","cljs/spec/gen/alpha.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$goog.Uri"]]],["^2O","cljs/tools/reader/impl/utils.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z","~$goog.string"]]],["^2O","goog/math/math.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","~$goog.array","~$goog.asserts"]]],["^2O","rewrite_clj/parser/core.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.node","~$rewrite-clj.reader","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","~$cljs.tools.reader.reader-types"]]],["^2O","rewrite_clj/parser/string.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^3;","^37"]]],["^2O","goog/array/array.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^39"]]],["^2O","rewrite_clj/zip/seqz.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.zip.base","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","~$rewrite-clj.zip.move","~$clojure.zip"]]],["^35","^3@"],[1549146540000],["^2O","rewrite_clj/zip/move.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.zip.whitespace","^3F"]]],["^2O","goog/debug/error.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","rewrite_clj/zip.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3A","^S","^3E","^3C","^3B","^3D","~$rewrite-clj.zip.removez","~$rewrite-clj.zip.seqz","^3F"]]],["^2O","rewrite_clj/zip/editz.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3A","^3E","^3H","~$rewrite-clj.zip.utils","^3G","^3:","^3F"]]],["^2O","cljs/tools/reader/edn.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$cljs.tools.reader.impl.errors","^3@","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^37","~$goog.string.StringBuffer"]]],["^2O","goog/dom/nodetype.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","cljs/tools/reader/impl/inspect.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V"]]],["^2O","zprint/config.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z","~$zprint.sutil","~$clojure.set","~$clojure.data","~$zprint.spec","~$cljs.reader"]]],["^35","~$cljs.spec.gen.alpha"],[1551476394000],["^2O","cljs/tools/reader.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3@","^3L","^3M","^3K","^38","^37","^3O"]]],["^2O","rewrite_clj/node/forms.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","rewrite_clj/zip/insert.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3A","^3G","^3:","^3F"]]],["^2O","rewrite_clj/zip/utils.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3F"]]],["^2O","goog/object/object.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],"~:SHADOW-TIMESTAMP",[1554046439000,1551476394000],["^2O","goog/math/long.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^39","~$goog.reflect"]]],["^2O","rewrite_clj/node/reader_macro.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34","~$rewrite-clj.node.whitespace"]]],["^2O","goog/string/internal.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","goog/functions/functions.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","rewrite_clj/zip/findz.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3A","^3E","^3:","^3G","^3F"]]],["^2O","clojure/walk.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V"]]],["^2O","goog/structs/map.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^2O","rewrite_clj/node/meta.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34","^3X"]]],["^2O","rewrite_clj/node/stringz.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34","^3N","^Z"]]],["^2O","rewrite_clj/node/comment.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","rewrite_clj/node/keyword.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","cljs/reader.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$goog.object","^3N","~$cljs.tools.reader.edn","^3O"]]],["^35","~$cljs.spec.alpha"],[1551476394000],["^2O","goog/asserts/asserts.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^2O","zprint/zutil.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z","^X","^S","^3:","^U","^3A","^3G","^3F"]]],["^2O","goog/uri/uri.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^38","^39","^37","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^2O","rewrite_clj/node/protocols.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z"]]],["^2O","rewrite_clj/node/seq.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","rewrite_clj/node/uneval.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","cljs/spec/alpha.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3[","~$clojure.walk","^3U","^Z"]]],["^2O","goog/base.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",[]]],["^2O","goog/structs/structs.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^38","^3["]]],["^2O","cljs/tools/reader/impl/errors.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3@","^Z","~$cljs.tools.reader.impl.inspect"]]],["^2O","rewrite_clj/node/whitespace.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","rewrite_clj/node/coercer.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.node.comment","~$rewrite-clj.node.forms","~$rewrite-clj.node.keyword","~$rewrite-clj.node.quote","~$rewrite-clj.node.stringz","~$rewrite-clj.node.uneval","~$rewrite-clj.node.meta","~$rewrite-clj.node.fn","^34","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.seq","~$rewrite-clj.node.token","^3X"]]],["^2O","clojure/string.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^37","^3O"]]],["^2O","rewrite_clj/parser.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.parser.core","^3:","^3;"]]],["^2O","rewrite_clj/parser/keyword.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^3@","^3;"]]],["^2O","zprint/zfns.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V"]]],["^2O","rewrite_clj/parser/token.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^3;","^37"]]],["^2O","goog/string/string.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","~$goog.string.internal"]]],["^2O","clojure/data.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3Q"]]],["^2O","goog/reflect/reflect.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","rewrite_clj/node/fn.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34","^49"]]],["^2O","rewrite_clj/node.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","~$rewrite-clj.node.coercer","^34","^4=","^4D","^3X","^4E","^4;","^4<","^4A","^4?","^4C","^4>","^4@","^4B"]]],["^2O","rewrite_clj/zip/removez.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3E","^3J","^3G","^3F"]]],["^2O","clojure/zip.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V"]]],["^2O","goog/string/stringbuffer.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","cljs/tools/reader/reader_types.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3L","^37","^3O"]]],["^2O","goog/iter/iter.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^38","^39","~$goog.functions","~$goog.math"]]],["^2O","zprint/spec.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^41"]]],["^2O","rewrite_clj/reader.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3N","^3@","^3M","^37","^34"]]],["^2O","zprint/sutil.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z","^X","^3T"]]],["^35","^F"],[1530397449000],["^2O","rewrite_clj/node/quote.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^34"]]],["^2O","cljs/tools/reader/impl/commons.cljs"],[1549146540000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3K","^3@","^3L"]]],["^2O","cljs/core.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["~$goog.math.Long","~$goog.math.Integer","^37","^3[","^38","^36","^3O"]]],["^2O","goog/math/integer.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W"]]],["^2O","zprint/zprint.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z","^X","^Y","^T","^[","^S","^U"]]],["^35","~$zprint.smacros"],[1530397449000],["^2O","clojure/set.cljs"],[1551476394000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V"]]],["^2O","goog/uri/utils.js"],[1551476395000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^38","^39","^37"]]],["^2O","rewrite_clj/zip/base.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^S","^3G","^3F"]]],["^2O","rewrite_clj/zip/whitespace.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^3F"]]],["^2O","zprint/ansi.cljc"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^Z"]]],["^35","^3T"],[1551476394000],["^2O","rewrite_clj/parser/whitespace.cljs"],[1530397449000,"^30",["^ ","^31",null,"^32",["^L",[]],"^33",["^W","^V","^3:","^3;"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/zprint.cljc","^7",1,"^8",5,"^9",1,"^:",18],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C"],"^D",["^ ","^E","^F","^G","^F","^H","^F","^I","^F","^J","^F"],"^K",["^L",[]],"^M","^N","^Q",null,"^R",["^ ","^S","^S","~$p","^S","^T","^T","^U","^U","^V","^V","^W","^W","^X","^X","^Y","^Y","~$s","^Z","~$z","^U","^Z","^Z","^[","^["],"^10",["^L",["^11","^12"]],"~:shadow/js-access-global",["^L",["Error"]],"^13",["^ ","^14","^X","^15","^X","^16","^X","^17","^X","^18","^X","^19","^X","^1:","^X","^1;","^X","^1<","^X","^1=","^X","^1>","^X","^1?","^X","^1@","^X","^1A","^X","^1B","^T","^1C","^X","^1D","^X","^1E","^X","^1F","^T","^1G","^X","^1H","^X","^1I","^X","^1J","^X","^1K","^X","^1L","^Y","^1M","^X","^1N","^X","^1O","^X","^1P","^X","^1Q","^[","^1R","^X","^1S","^X","^1T","^X","^1U","^X","^1V","^X","^1W","^X","^1X","^X","^1Y","^X","^1Z","^X","^1[","^X","^20","^X","^21","^X","^22","^X","^23","^X","^24","^X","^25","^X","^26","^X","^27","^X","^28","^X","^29","^X","^2:","^X","^2;","^X","^2<","^X","^2=","^X","^2>","^X","^2?","^X","^2@","^X","^2A","^X","^2B","^X","^2C","^X","^2D","^X","^2E","^X"],"~:defs",["^ ","~$body-set",["^ ","^M","~$zprint.zprint/body-set","^6","zprint/zprint.cljc","^7",2414,"^8",1,"^9",2414,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",2414,"^8",6,"^9",2414,"^:",14],"~:tag","~$cljs.core/ISet"],"~$allow-one-line?",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2455,"^8",7,"^9",2455,"^:",22,"~:arglists",["^2G",["~$quote",["^2G",[[["^ ","~:keys",["~$fn-force-nl","~$fn-gt2-force-nl","~$fn-gt3-force-nl"],"^2J","~$options"],"~$len","~$fn-style"]]]]],"~:doc","Should we allow this function to print on a single line?"],"^M","~$zprint.zprint/allow-one-line?","^6","zprint/zprint.cljc","^:",22,"~:method-params",["^2G",[["~$p__37441","^52","^53"]]],"~:protocol-impl",null,"~:arglists-meta",["^2G",[null,null]],"^8",1,"~:variadic?",false,"^7",2455,"~:ret-tag","~$boolean","^9",2455,"~:max-fixed-arity",3,"~:fn-var",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^4Z","^4[","^50"],"^2J","^51"],"^52","^53"]]]]],"^54","Should we allow this function to print on a single line?"],"~$replace-color",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",646,"^8",7,"^9",646,"^:",20,"^4W",["^2G",["^4X",["^2G",[["~$local-color","~$style-vec"]]]]],"^54","Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct."],"^M","~$zprint.zprint/replace-color","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^5@","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",646,"^5;",["^L",[null,"~$cljs.core/IVector"]],"^9",646,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5@","^5A"]]]]],"^54","Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct."],"~$fzprint-inline-comments",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3823,"^8",7,"^9",3823,"^:",30,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["~$width"],"^2J","^51"],"^5A"]]]]],"^54","Try to bring inline comments back onto the line on which they belong."],"^M","~$zprint.zprint/fzprint-inline-comments","^6","zprint/zprint.cljc","^:",30,"^56",["^2G",[["~$p__37630","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3823,"^5;",["^L",["~$clj","^5C"]],"^9",3823,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E"],"^2J","^51"],"^5A"]]]]],"^54","Try to bring inline comments back onto the line on which they belong."],"~$right-separator-map",["^ ","^M","~$zprint.zprint/right-separator-map","^6","zprint/zprint.cljc","^7",154,"^8",1,"^9",154,"^:",25,"^5",["^ ","^6","zprint/zprint.cljc","^7",154,"^8",6,"^9",154,"^:",25],"^4S","~$cljs.core/IMap"],"~$fzprint-justify-width",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",942,"^8",7,"^9",942,"^:",28,"^4W",["^2G",["^4X",["^2G",[["~$caller",["^2[",[["^ ","^4Y",["~$justify?"]],"^5M","^2J","^51"]],"~$ind","~$coll"]]]]],"^54","Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line."],"^M","~$zprint.zprint/fzprint-justify-width","^6","zprint/zprint.cljc","^:",28,"^56",["^2G",[["^5M","~$p__37233","^5O","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",942,"^5;",["^L",["~$number","~$clj-nil"]],"^9",942,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^5N"]],"^5M","^2J","^51"]],"^5O","^5P"]]]]],"^54","Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line."],"~$expand-tabs",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3888,"^8",7,"^9",3888,"^:",18,"^4W",["^2G",["^4X",["^2G",[["~$tab-size","~$s"],["~$s"]]]]],"^54","Takes a string, and expands tabs inside of the string based\n  on a tab-size argument.","~:top-fn",["^ ","^5:",false,"~:fixed-arity",2,"^5=",2,"^56",["^2G",[["^5V","~$s"],["~$s"]]],"^4W",["^2G",[["^5V","~$s"],["~$s"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/expand-tabs","^6","zprint/zprint.cljc","^:",18,"^5W",["^ ","^5:",false,"^5X",2,"^5=",2,"^56",["^2G",[["^5V","~$s"],["~$s"]]],"^4W",["^2G",[["^5V","~$s"],["~$s"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^5V","~$s"],["~$s"]]],"^58",null,"^5X",2,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"~:methods",[["^ ","^5X",2,"^5:",false,"^4S","~$any"],["^ ","^5X",1,"^5:",false,"^4S","^5["]],"^7",3888,"^9",3888,"^5=",2,"^5>",true,"^4W",["^2G",[["^5V","~$s"],["~$s"]]],"^54","Takes a string, and expands tabs inside of the string based\n  on a tab-size argument."],"~$fzprint-list",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2827,"^8",7,"^9",2827,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","~$zloc"]]]]],"^54","Pretty print and focus style a :list element."],"^M","~$zprint.zprint/fzprint-list","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2827,"^5;",["^L",["^5H","^5T"]],"^9",2827,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Pretty print and focus style a :list element."],"~$fzprint-hang-remaining",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2198,"^8",7,"^9",2198,"^:",29,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["~$dbg?","^5E"],["^ ","^4Y",["~$hang?","~$constant-pair?","~$constant-pair-min","~$hang-avoid","~$hang-expand","~$hang-diff","~$nl-separator?"]],"^5M","^2J","^51"]],"~$hindent","~$findent","^61","^53","~$zloc-count"],["^5M","^51","^6<","^6=","^61","^53"]]]]],"^54","zloc is already down inside a collection, it is not the collection\n  itself. Operate on what is to the right of zloc.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc.","^5W",["^ ","^5:",false,"^5X",7,"^5=",7,"^56",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^4W",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/fzprint-hang-remaining","^6","zprint/zprint.cljc","^:",29,"^5W",["^ ","^5:",false,"^5X",7,"^5=",7,"^56",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^4W",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^58",null,"^5X",7,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^5Z",[["^ ","^5X",7,"^5:",false,"^4S",["^L",["^5H","^5T"]]],["^ ","^5X",6,"^5:",false,"^4S",["^L",["^5H","^5T"]]]],"^7",2198,"^9",2198,"^5=",7,"^5>",true,"^4W",["^2G",[["^5M",["^2[",["^4Y",["^64","^5E"],["^ ","^4Y",["^65","^66","^67","^68","^69","^6:","^6;"]],"^5M","^2J","^51"]],"^6<","^6=","^61","^53","^6>"],["^5M","^51","^6<","^6=","^61","^53"]]],"^54","zloc is already down inside a collection, it is not the collection\n  itself. Operate on what is to the right of zloc.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc."],"~$blanks",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",30,"^8",7,"^9",30,"^:",13,"^4W",["^2G",["^4X",["^2G",[["~$n"]]]]],"^54","Produce a blank string of desired size."],"^M","~$zprint.zprint/blanks","^6","zprint/zprint.cljc","^:",13,"^56",["^2G",[["~$n"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",30,"^5;","^5[","^9",30,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$n"]]]]],"^54","Produce a blank string of desired size."],"~$remove-hangflow",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",976,"^8",7,"^9",976,"^:",22,"^4W",["^2G",["^4X",["^2G",[["~$hf-style-vec"]]]]],"^54","Convert a hangflow style-vec to a regular style-vec."],"^M","~$zprint.zprint/remove-hangflow","^6","zprint/zprint.cljc","^:",22,"^56",["^2G",[["^6C"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",976,"^5;",["^L",["~$cljs.core/LazySeq","^5T"]],"^9",976,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^6C"]]]]],"^54","Convert a hangflow style-vec to a regular style-vec."],"~$concat-no-nil-alt",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",278,"^8",7,"^9",278,"^:",24,"^4W",["^2G",["^4X",["^2G",[["~$&","~$rest"]]]]],"^54","Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes.","^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]]],"^M","~$zprint.zprint/concat-no-nil-alt","^6","zprint/zprint.cljc","^:",24,"^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]],"^56",[["^2G",["^6G"]]],"^58",null,"^5X",0,"^59",["^2G",[null]],"^8",1,"^5:",true,"^5Z",[["^ ","^5X",0,"^5:",true,"^4S",["^L",["^5H","^5T"]]]],"^7",278,"^5;","^5[","^9",278,"^5=",0,"^5>",true,"^4W",["^2G",[["~$&","^6G"]]],"^54","Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes."],"~$dots",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",35,"^8",7,"^9",35,"^:",11,"^4W",["^2G",["^4X",["^2G",[["~$n"]]]]],"^54","Produce a dot string of desired size."],"^M","~$zprint.zprint/dots","^6","zprint/zprint.cljc","^:",11,"^56",["^2G",[["~$n"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",35,"^5;","^5[","^9",35,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$n"]]]]],"^54","Produce a dot string of desired size."],"~$partition-all-sym",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1267,"^8",7,"^9",1267,"^:",24,"^4W",["^2G",["^4X",["^2G",[["^51","~$modifier-set","^5P"]]]]],"^54","Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things"],"^M","~$zprint.zprint/partition-all-sym","^6","zprint/zprint.cljc","^:",24,"^56",["^2G",[["^51","^6L","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1267,"^5;","^5H","^9",1267,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^6L","^5P"]]]]],"^54","Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things"],"~$conj-it!",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",42,"^8",7,"^9",42,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$&","^6G"]]]]],"^54","Make a version of conj! that take multiple arguments.","^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]]],"^M","~$zprint.zprint/conj-it!","^6","zprint/zprint.cljc","^:",15,"^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]],"^56",[["^2G",["^6G"]]],"^58",null,"^5X",0,"^59",["^2G",[null]],"^8",1,"^5:",true,"^5Z",[["^ ","^5X",0,"^5:",true,"^4S","^5["]],"^7",42,"^5;","^5[","^9",42,"^5=",0,"^5>",true,"^4W",["^2G",[["~$&","^6G"]]],"^54","Make a version of conj! that take multiple arguments."],"~$fzfit-one-line",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",539,"^8",7,"^9",539,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^51","~$style-lines-return"]]]]],"^54","Given the return from style-lines  and options, \n  return true if it fits on a single line."],"^M","~$zprint.zprint/fzfit-one-line","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["^51","^6Q"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",539,"^5;","^5<","^9",539,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^6Q"]]]]],"^54","Given the return from style-lines  and options, \n  return true if it fits on a single line."],"~$line-count",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3872,"^8",7,"^9",3872,"^:",17,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Count lines in a string."],"^M","~$zprint.zprint/line-count","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3872,"^5;","^5S","^9",3872,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Count lines in a string."],"~$concatv!",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1481,"^8",7,"^9",1481,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$v","~$&","^6G"]]]]],"^54","Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v.","^5W",["^ ","^5:",true,"^5X",1,"^5=",1,"^56",[["^2G",["~$v","^6G"]]],"^4W",["^2G",[["~$v","~$&","^6G"]]],"^59",["^2G",[null]]]],"^M","~$zprint.zprint/concatv!","^6","zprint/zprint.cljc","^:",15,"^5W",["^ ","^5:",true,"^5X",1,"^5=",1,"^56",[["^2G",["~$v","^6G"]]],"^4W",["^2G",[["~$v","~$&","^6G"]]],"^59",["^2G",[null]]],"^56",[["^2G",["~$v","^6G"]]],"^58",null,"^5X",1,"^59",["^2G",[null]],"^8",1,"^5:",true,"^5Z",[["^ ","^5X",1,"^5:",true]],"^7",1481,"^5;","^5[","^9",1481,"^5=",1,"^5>",true,"^4W",["^2G",[["~$v","~$&","^6G"]]],"^54","Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v."],"~$fzprint-seq",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1536,"^8",7,"^9",1536,"^:",18,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["~$max-length"],"^2J","^51"],"^5O","~$zloc-seq"]]]]],"^54","Take a seq of a zloc, created by (zmap identity zloc) when zloc\n  is a collection, or (zmap-right identity zloc) when zloc is already\n  inside of a collection, and return a seq of the fzprint* of each \n  element.  No spacing between any of these elements. Note that this\n  is not a style-vec, but a seq of style-vecs of each of the elements.\n  These would need to be concatenated together to become a style-vec.\n  ind is either a constant or a seq of indents, one for each element in\n  zloc-seq."],"^M","~$zprint.zprint/fzprint-seq","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["~$p__37389","^5O","^6Y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1536,"^5;",["^L",["^5H","^5C","^5T"]],"^9",1536,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^6X"],"^2J","^51"],"^5O","^6Y"]]]]],"^54","Take a seq of a zloc, created by (zmap identity zloc) when zloc\n  is a collection, or (zmap-right identity zloc) when zloc is already\n  inside of a collection, and return a seq of the fzprint* of each \n  element.  No spacing between any of these elements. Note that this\n  is not a style-vec, but a seq of style-vecs of each of the elements.\n  These would need to be concatenated together to become a style-vec.\n  ind is either a constant or a seq of indents, one for each element in\n  zloc-seq."],"~$loc-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3775,"^8",7,"^9",3775,"^:",14,"^4W",["^2G",["^4X",["^2G",[["~$start",["~$s"]]]]]],"^54","Takes the start of this vector and the vector itself."],"^M","~$zprint.zprint/loc-vec","^6","zprint/zprint.cljc","^:",14,"^56",["^2G",[["^71","~$p__37623"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3775,"^5;","^5S","^9",3775,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^71",["~$s"]]]]]],"^54","Takes the start of this vector and the vector itself."],"~$partition-all-2-nc",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1197,"^8",7,"^9",1197,"^:",25,"^4W",["^2G",["^4X",["^2G",[[["^ ","^2J","^51","^4Y",["^6X"]],"^5P"]]]]],"^54","Input is (zseqnws zloc) where one assumes that these are pairs.\n  Thus, a seq of zlocs.  Output is a sequence of seqs, where the\n  seqs are usually pairs, but might be single things.  Doesn't pair\n  up comments or #_(...) unevaled sexpressions.  The ones before\n  the first part of a pair come as a single element in what would\n  usually be a pair, and the ones between the first and second parts\n  of a pair come inside the pair.  There may be an arbitrary number\n  of elements between the first and second elements of the pair\n  (one per line).  If there are any comments or unevaled sexpressions,\n  don't sort the keys, as we might lose track of where the comments\n  or unevaled s-expressions go."],"^M","~$zprint.zprint/partition-all-2-nc","^6","zprint/zprint.cljc","^:",25,"^56",["^2G",[["~$p__37275","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1197,"^5;",["^L",["^5C","^5T"]],"^9",1197,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^2J","^51","^4Y",["^6X"]],"^5P"]]]]],"^54","Input is (zseqnws zloc) where one assumes that these are pairs.\n  Thus, a seq of zlocs.  Output is a sequence of seqs, where the\n  seqs are usually pairs, but might be single things.  Doesn't pair\n  up comments or #_(...) unevaled sexpressions.  The ones before\n  the first part of a pair come as a single element in what would\n  usually be a pair, and the ones between the first and second parts\n  of a pair come inside the pair.  There may be an arbitrary number\n  of elements between the first and second elements of the pair\n  (one per line).  If there are any comments or unevaled sexpressions,\n  don't sort the keys, as we might lose track of where the comments\n  or unevaled s-expressions go."],"~$fzprint-future-promise-delay-agent",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3251,"^8",7,"^9",3251,"^:",41,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc."],"^M","~$zprint.zprint/fzprint-future-promise-delay-agent","^6","zprint/zprint.cljc","^:",41,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3251,"^5;",["^L",["^5H","^5T"]],"^9",3251,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc."],"~$rightmost",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",550,"^8",7,"^9",550,"^:",16,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Increase the rightmost count, if any, and return one if not."],"^M","~$zprint.zprint/rightmost","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["^51"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",550,"^5;",["^L",["^5H","^5["]],"^9",550,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Increase the rightmost count, if any, and return one if not."],"~$split-lf-2",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",60,"^8",7,"^9",60,"^:",17,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Do split for newlines, instead of using regular expressions.\n  Maximum split is 2."],"^M","~$zprint.zprint/split-lf-2","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",60,"^5;","^5C","^9",60,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Do split for newlines, instead of using regular expressions.\n  Maximum split is 2."],"~$c-r-pair",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",560,"^8",7,"^9",560,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$commas?","~$rightmost-pair?","~$rightmost?","^51"]]]]],"^54","Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!"],"^M","~$zprint.zprint/c-r-pair","^6","zprint/zprint.cljc","^:",15,"^56",["^2G",[["^7>","^7?","^7@","^51"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",560,"^5;",["^L",[null,"^5H","^5[","^5T"]],"^9",560,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^7>","^7?","^7@","^51"]]]]],"^54","Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!"],"~$fzprint-fn-obj",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3307,"^8",7,"^9",3307,"^:",21,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["~$object?"]],"~:fn-obj","^2J","^51"]],"^5O","^61"]]]]],"^54","Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper."],"^M","~$zprint.zprint/fzprint-fn-obj","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["~$p__37582","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3307,"^5;",["^L",["^5H","^5T"]],"^9",3307,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^7C"]],"^7D","^2J","^51"]],"^5O","^61"]]]]],"^54","Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper."],"~$single-line?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",484,"^8",7,"^9",484,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one."],"^M","~$zprint.zprint/single-line?","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",484,"^5;","^5<","^9",484,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one."],"~$fzprint-map*",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3102,"^8",7,"^9",3102,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5M","~$l-str","~$r-str",["^2[",["^4Y",["~$one-line?","~$ztype","~$map-depth","~$in-code?"],["^ ","^4Y",["~$comma?","~$key-ignore","~$key-ignore-silent","^6;","~$force-nl?","~$lift-ns?","~$lift-ns-in-code?"]],"^5M","^2J","^51"]],"^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-map*","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5M","^7J","^7K","~$p__37559","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3102,"^5;",["^L",["^5H","^5T"]],"^9",3102,"^5=",6,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M","^7J","^7K",["^2[",["^4Y",["^7L","^7M","^7N","^7O"],["^ ","^4Y",["^7P","^7Q","^7R","^6;","^7S","^7T","^7U"]],"^5M","^2J","^51"]],"^5O","^61"]]]]]],"~$constant-pair",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1707,"^8",7,"^9",1707,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^66","^67"]],"^5M","^2J","^51"]],"~$seq-right"]]]]],"^54","Argument is result of (zmap-right identity zloc), that is to say\n  a seq of zlocs.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not\n  an empty seq."],"^M","~$zprint.zprint/constant-pair","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^5M","~$p__37408","^7Y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1707,"^5;","^5C","^9",1707,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^66","^67"]],"^5M","^2J","^51"]],"^7Y"]]]]],"^54","Argument is result of (zmap-right identity zloc), that is to say\n  a seq of zlocs.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not\n  an empty seq."],"~$order-out",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1104,"^8",7,"^9",1104,"^:",16,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["~$sort?","~$sort-in-code?","~$key-order","~$key-value"]],"^5M","^4Y",["^7O"],"^2J","^51"]],"~$access","~$out"]]]]],"^54","A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing."],"^M","~$zprint.zprint/order-out","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["^5M","~$p__37254","^85","^86"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1104,"^5;",["^L",[null,"~$seq","~$cljs.core/IList"]],"^9",1104,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^81","^82","^83","^84"]],"^5M","^4Y",["^7O"],"^2J","^51"]],"^85","^86"]]]]],"^54","A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing."],"~$fzprint-two-up",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",657,"^8",7,"^9",657,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^7L","^64","~$dbg-indent","~$in-hang?","~$do-in-hang?","^7N"],["^ ","^4Y",["^65","~$dbg-local?","~$dbg-cnt?","~$indent","~$indent-arg","~$flow?","~$key-color","~$key-depth-color","~$key-value-color"]],"^5M","^2J","^51"]],"^5O","^7>","~$justify-width","^7?",["~$lloc","~$rloc","~$xloc","^2J","~$pair"]]]]]],"^54","Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  This will return a\n  style-vec (or nil), unless hangflow? is true, in which case it\n  will return [:hang <style-vec>] or [:flow <style-vec>] so that\n  the upstream folks know whether this was a hang or flow and can\n  do the right thing based on that."],"^M","~$zprint.zprint/fzprint-two-up","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["^5M","~$p__37194","^5O","^7>","^8G","^7?","~$p__37195"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",657,"^5;",["^L",["^5C","^5T"]],"^9",657,"^5=",7,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^7L","^64","^8<","^8=","^8>","^7N"],["^ ","^4Y",["^65","^8?","^8@","^8A","^8B","^8C","^8D","^8E","^8F"]],"^5M","^2J","^51"]],"^5O","^7>","^8G","^7?",["^8H","^8I","^8J","^2J","^8K"]]]]]],"^54","Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  This will return a\n  style-vec (or nil), unless hangflow? is true, in which case it\n  will return [:hang <style-vec>] or [:flow <style-vec>] so that\n  the upstream folks know whether this was a hang or flow and can\n  do the right thing based on that."],"~$fzprint-prefix*",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3518,"^8",7,"^9",3518,"^:",22,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61","^7J"]]]]],"^54","Print the single item after a variety of prefix characters."],"^M","~$zprint.zprint/fzprint-prefix*","^6","zprint/zprint.cljc","^:",22,"^56",["^2G",[["^51","^5O","^61","^7J"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3518,"^5;",["^L",["^5H","^5T"]],"^9",3518,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61","^7J"]]]]],"^54","Print the single item after a variety of prefix characters."],"~$prefix-tags",["^ ","^M","~$zprint.zprint/prefix-tags","^6","zprint/zprint.cljc","^7",3540,"^8",1,"^9",3540,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",3540,"^8",6,"^9",3540,"^:",17],"^4S","^5K"],"~$fzprint-flow-seq",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1562,"^8",7,"^9",1562,"^:",23,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]]]],"^54","Take a seq of a zloc, created by (zmap identity zloc) or\n  and return a style-vec of the result.  Either it fits on one line, \n  or it is rendered on multiple lines.  You can force multiple lines \n  with force-nl?. If you want it to do less than everything in the \n  original zloc, modify the result of (zmap identity zloc) to just \n  contain what you want to print. ind is either a single indent,\n  or a seq of indents, one for each element in zloc-seq.","^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^4W",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/fzprint-flow-seq","^6","zprint/zprint.cljc","^:",23,"^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^4W",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^58",null,"^5X",4,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^5Z",[["^ ","^5X",4,"^5:",false,"^4S","^5["],["^ ","^5X",3,"^5:",false,"^4S","^5["]],"^7",1562,"^9",1562,"^5=",4,"^5>",true,"^4W",["^2G",[["^51","^5O","^6Y","^7S"],["^51","^5O","^6Y"]]],"^54","Take a seq of a zloc, created by (zmap identity zloc) or\n  and return a style-vec of the result.  Either it fits on one line, \n  or it is rendered on multiple lines.  You can force multiple lines \n  with force-nl?. If you want it to do less than everything in the \n  original zloc, modify the result of (zmap identity zloc) to just \n  contain what you want to print. ind is either a single indent,\n  or a seq of indents, one for each element in zloc-seq."],"~$noarg1-map",["^ ","^M","~$zprint.zprint/noarg1-map","^6","zprint/zprint.cljc","^7",2433,"^8",1,"^9",2433,"^:",16,"^5",["^ ","^6","zprint/zprint.cljc","^7",2433,"^8",6,"^9",2433,"^:",16],"^4S","^5K"],"~$zcolor-map",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",606,"^8",7,"^9",606,"^:",17,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["~$color-map"],"^2J","^51"],"~$key-or-str"]]]]],"^54","Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings."],"^M","~$zprint.zprint/zcolor-map","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["~$p__37180","^8Y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",606,"^5;","^5[","^9",606,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^8X"],"^2J","^51"],"^8Y"]]]]],"^54","Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings."],"~$fzprint-ns",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3356,"^8",7,"^9",3356,"^:",17,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-ns","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3356,"^5;",["^L",["^5H","^5T"]],"^9",3356,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"~$str->key",["^ ","^M","~$zprint.zprint/str->key","^6","zprint/zprint.cljc","^7",589,"^8",1,"^9",589,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",589,"^8",6,"^9",589,"^:",14],"^4S","^5K"],"~$fzprint-hang-one",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1593,"^8",7,"^9",1593,"^:",23,"^4W",["^2G",["^4X",["^2G",[["^5M",["^ ","^4Y",["^7L"],"^2J","^51"],"^6<","^6=","^61"]]]]],"^54","Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn."],"^M","~$zprint.zprint/fzprint-hang-one","^6","zprint/zprint.cljc","^:",23,"^56",["^2G",[["^5M","~$p__37401","^6<","^6=","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1593,"^5;",["^L",["^5H","^5T"]],"^9",1593,"^5=",5,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^ ","^4Y",["^7L"],"^2J","^51"],"^6<","^6=","^61"]]]]],"^54","Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn."],"~$fzprint-extend",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1456,"^8",7,"^9",1456,"^:",21,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"~:extend","^2J","^51"]],"^5O","^61"]]]]],"^54","Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. This skips over zloc and does everything to the\n  right of it!"],"^M","~$zprint.zprint/fzprint-extend","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["~$p__37364","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1456,"^5;","^5[","^9",1456,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"^98","^2J","^51"]],"^5O","^61"]]]]],"^54","Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. This skips over zloc and does everything to the\n  right of it!"],"~$find-what",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",494,"^8",7,"^9",494,"^:",16,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from."],"^M","~$zprint.zprint/find-what","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",494,"^5;",["^L",[null,"^5[","^5T"]],"^9",494,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from."],"~$fzprint-atom",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3228,"^8",7,"^9",3228,"^:",19,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^7C"]],"~:atom","^2J","^51"]],"^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-atom","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["~$p__37575","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3228,"^5;",["^L",["^5H","^5T"]],"^9",3228,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^7C"]],"^9>","^2J","^51"]],"^5O","^61"]]]]]],"~$fix-rightcnt",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",576,"^8",7,"^9",576,"^:",19,"^4W",["^2G",["^4X",["^2G",[["~$rightcnt"]]]]],"^54","Handle issue with rightcnt."],"^M","~$zprint.zprint/fix-rightcnt","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^9B"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",576,"^5;","^5S","^9",576,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^9B"]]]]],"^54","Handle issue with rightcnt."],"~$r",["^ ","~:num-fields",2,"~:protocols",["^L",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","^5K","~$cljs.core/ILookup"]],"^M","~$zprint.zprint/r","^6","zprint/zprint.cljc","^:",13,"~:type",true,"^8",12,"~:internal-ctor",true,"^7",3917,"~:record",true,"^9",3917,"^4S","~$function","~:skip-protocol-flag",["^L",["^9F","^9G","^9H","^9I","^9J","^9K","^9L","^9M","^9N","^9O","^9P","^9Q","^9R","^5K","^9S"]]],"~$remove-nl",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2927,"^8",7,"^9",2927,"^:",16,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Remove any [_ _ :newline] from the seq."],"^M","~$zprint.zprint/remove-nl","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2927,"^5;","^6E","^9",2927,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Remove any [_ _ :newline] from the seq."],"~$fzprint-map",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3187,"^8",7,"^9",3187,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Format a real map. ONLY WORKES ON STRUCTURES AT PRESENT"],"^M","~$zprint.zprint/fzprint-map","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3187,"^5;",["^L",["^5H","^5T"]],"^9",3187,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Format a real map. ONLY WORKES ON STRUCTURES AT PRESENT"],"~$fzprint-vec*",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2947,"^8",7,"^9",2947,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5M","^7J","^7K",["^2[",["^4Y",["^9B","^7O"],["^ ","^4Y",["~$wrap-coll?","~$wrap?","~$binding?","~$option-fn-first","~$respect-nl?","^81","^82"]],"^5M","^2J","^51"]],"^5O","^61"]]]]],"^54","Print basic stuff like a vector or a set.  Several options for how to\n  print them."],"^M","~$zprint.zprint/fzprint-vec*","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5M","^7J","^7K","~$p__37537","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2947,"^5;",["^L",["^5H","^5T"]],"^9",2947,"^5=",6,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M","^7J","^7K",["^2[",["^4Y",["^9B","^7O"],["^ ","^4Y",["^:3","^:4","^:5","^:6","^:7","^81","^82"]],"^5M","^2J","^51"]],"^5O","^61"]]]]],"^54","Print basic stuff like a vector or a set.  Several options for how to\n  print them."],"~$wrap-comment",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3726,"^8",7,"^9",3726,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5E",["~$s","~$color","~$stype","^2J","~$element"],"^71"]]]]],"^54","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"^M","~$zprint.zprint/wrap-comment","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5E","~$p__37619","^71"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3726,"^5;",["^L",[null,"^5H"]],"^9",3726,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5E",["~$s","^:;","^:<","^2J","^:="],"^71"]]]]],"^54","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"~$log-lines",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",99,"^8",7,"^9",99,"^:",16,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["~$dbg-print?","^8<","^8="],"^2J","^51"],"~$dbg-output","^5O","^5A"]]]]],"^54","Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging."],"^M","~$zprint.zprint/log-lines","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["~$p__37058","^:B","^5O","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",99,"^5;","^5T","^9",99,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^:A","^8<","^8="],"^2J","^51"],"^:B","^5O","^5A"]]]]],"^54","Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging."],"~$line-widths",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3874,"^8",7,"^9",3874,"^:",18,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Return a vector the lengths of lines."],"^M","~$zprint.zprint/line-widths","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3874,"^5;","^6E","^9",3874,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Return a vector the lengths of lines."],"^8A",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",40,"^8",7,"^9",40,"^:",13,"^4W",["^2G",["^4X",["^2G",[[]]]]],"^54","error"],"^M","~$zprint.zprint/indent","^6","zprint/zprint.cljc","^:",13,"^56",["^2G",[[]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",40,"^5;","^5T","^9",40,"^5=",0,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[]]]]],"^54","error"],"~$lift-style-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3802,"^8",7,"^9",3802,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"^M","~$zprint.zprint/lift-style-vec","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3802,"^5;",["^L",[null,"^5["]],"^9",3802,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"~$fzprint-map-two-up",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",981,"^8",7,"^9",981,"^:",25,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^5N","^7S"]],"^5M","^4Y",["^5E","^9B","^7L","~$parallel?"],"^2J","^51"]],"^5O","^7>","^5P"]]]]],"^54","Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil."],"^M","~$zprint.zprint/fzprint-map-two-up","^6","zprint/zprint.cljc","^:",25,"^56",["^2G",[["^5M","~$p__37243","^5O","^7>","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",981,"^5;",["^L",["^5H","^5C","^5T"]],"^9",981,"^5=",5,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^5N","^7S"]],"^5M","^4Y",["^5E","^9B","^7L","^:K"],"^2J","^51"]],"^5O","^7>","^5P"]]]]],"^54","Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil."],"~$rstr-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1362,"^8",7,"^9",1362,"^:",15,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61","^7K","~$r-type"],["^51","^5O","^61","^7K"]]]]],"^54","Create an r-str-vec with, possibly, a newline at the beginning if\n  the last thing before it is a comment.","^5W",["^ ","^5:",false,"^5X",5,"^5=",5,"^56",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^4W",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/rstr-vec","^6","zprint/zprint.cljc","^:",15,"^5W",["^ ","^5:",false,"^5X",5,"^5=",5,"^56",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^4W",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^58",null,"^5X",5,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^5Z",[["^ ","^5X",5,"^5:",false,"^4S","^6E"],["^ ","^5X",4,"^5:",false,"^4S","^6E"]],"^7",1362,"^9",1362,"^5=",5,"^5>",true,"^4W",["^2G",[["^51","^5O","^61","^7K","^:O"],["^51","^5O","^61","^7K"]]],"^54","Create an r-str-vec with, possibly, a newline at the beginning if\n  the last thing before it is a comment."],"~$zat",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",85,"^8",7,"^9",85,"^:",10,"^4W",["^2G",["^4X",["^2G",[["^51","~$value"]]]]],"^54","Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through."],"^M","~$zprint.zprint/zat","^6","zprint/zprint.cljc","^:",10,"^56",["^2G",[["^51","^:R"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",85,"^9",85,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^:R"]]]]],"^54","Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through."],"~$interpose-either",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3037,"^8",7,"^9",3037,"^:",23,"^4W",["^2G",["^4X",["^2G",[["~$sep-true","~$sep-nil","~$pred?","^5P"]]]]],"^54","Do the same as interpose, but different seps depending on pred?."],"^M","~$zprint.zprint/interpose-either","^6","zprint/zprint.cljc","^:",23,"^56",["^2G",[["^:U","^:V","^:W","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3037,"^5;","^5H","^9",3037,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^:U","^:V","^:W","^5P"]]]]],"^54","Do the same as interpose, but different seps depending on pred?."],"~$fzprint-hang",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1398,"^8",7,"^9",1398,"^:",19,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^7L"],"^2J","^51"],"^5M","^6<","^6=","~$fzfn","^6>","^61"]]]]],"^54","Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input.  For instance,\n  fzprint-pairs does a (zmap-right identity zloc).  Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc)."],"^M","~$zprint.zprint/fzprint-hang","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["~$p__37340","^5M","^6<","^6=","^:Z","^6>","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1398,"^5;",["^L",["^5H","^5T"]],"^9",1398,"^5=",7,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^7L"],"^2J","^51"],"^5M","^6<","^6=","^:Z","^6>","^61"]]]]],"^54","Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input.  For instance,\n  fzprint-pairs does a (zmap-right identity zloc).  Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc)."],"~$wrap-zmap",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2846,"^8",7,"^9",2846,"^:",16,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^5E","^9B","^6X"],["^ ","^4Y",["~$wrap-after-multi?"]],"^5M","^2J","^51"]],"^5O","~$coll-print"]]]]],"^54","Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin."],"^M","~$zprint.zprint/wrap-zmap","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["^5M","~$p__37525","^5O","^;3"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2846,"^5;",["^L",["^5C","^6E","^5T"]],"^9",2846,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^5E","^9B","^6X"],["^ ","^4Y",["^;2"]],"^5M","^2J","^51"]],"^5O","^;3"]]]]],"^54","Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin."],"~$good-enough?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",163,"^8",7,"^9",163,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^5E","^9B","^64"],["^ ","^4Y",["~$hang-flow","~$hang-type-flow","~$hang-flow-limit","~$general-hang-adjust","~$hang-if-equal-flow?"]],"~:tuning",["^ ","^4Y",["^69","^6:","~$hang-size","~$hang-adjust"]],"^5M","^2J","^51"]],"^53","~$p-count","~$indent-diff",["~$p-lines","~$p-maxwidth","~$p-length-seq","~$p-what"],["~$b-lines","~$b-maxwidth","~$_","~$b-what"]]]]]],"^54","Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang."],"^M","~$zprint.zprint/good-enough?","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5M","~$p__37064","^53","^;?","^;@","~$p__37065","~$p__37066"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",163,"^5;",["^L",[null,"^5<","^5[","^5T"]],"^9",163,"^5=",7,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",["^4Y",["^5E","^9B","^64"],["^ ","^4Y",["^;7","^;8","^;9","^;:","^;;"]],"^;<",["^ ","^4Y",["^69","^6:","^;=","^;>"]],"^5M","^2J","^51"]],"^53","^;?","^;@",["^;A","^;B","^;C","^;D"],["^;E","^;F","~$_","^;G"]]]]]],"^54","Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang."],"~$lift-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3790,"^8",7,"^9",3790,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$out-vec","^:="]]]]],"^54","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"^M","~$zprint.zprint/lift-vec","^6","zprint/zprint.cljc","^:",15,"^56",["^2G",[["^;M","^:="]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3790,"^5;",["^L",[null,"^5H"]],"^9",3790,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^;M","^:="]]]]],"^54","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"~$style-lines",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",507,"^8",7,"^9",507,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector."],"^M","~$zprint.zprint/style-lines","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^51","^5O","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",507,"^5;",["^L",["^5H","^5T"]],"^9",507,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector."],"~$hash-identity-str",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3219,"^8",7,"^9",3219,"^:",24,"^4W",["^2G",["^4X",["^2G",[["~$obj"]]]]],"^54","Find the hash-code identity for an object."],"^M","~$zprint.zprint/hash-identity-str","^6","zprint/zprint.cljc","^:",24,"^56",["^2G",[["^;R"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3219,"^5;","~$string","^9",3219,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^;R"]]]]],"^54","Find the hash-code identity for an object."],"~$last-space",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3699,"^8",7,"^9",3699,"^:",17,"^4W",["^2G",["^4X",["^2G",[["~$s","~$from-index"]]]]],"^54","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"^M","~$zprint.zprint/last-space","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["~$s","^;V"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3699,"^5;",["^L",["^5S","^5T"]],"^9",3699,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s","^;V"]]]]],"^54","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"~$fzprint-object",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3206,"^8",7,"^9",3206,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61","~$zloc-value"],["^51","^5O","^61"]]]]],"^54","Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]","^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^4W",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/fzprint-object","^6","zprint/zprint.cljc","^:",21,"^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^4W",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^58",null,"^5X",4,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^5Z",[["^ ","^5X",4,"^5:",false,"^4S",["^L",["^5H","^5T"]]],["^ ","^5X",3,"^5:",false,"^4S",["^L",["^5H","^5T"]]]],"^7",3206,"^9",3206,"^5=",4,"^5>",true,"^4W",["^2G",[["^51","^5O","^61","^;Y"],["^51","^5O","^61"]]],"^54","Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]"],"~$fzprint-set",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3031,"^8",7,"^9",3031,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Pretty print and focus style a :set element."],"^M","~$zprint.zprint/fzprint-set","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3031,"^5;",["^L",["^5H","^5T"]],"^9",3031,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Pretty print and focus style a :set element."],"~$fzprint-array",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3027,"^8",7,"^9",3027,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-array","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3027,"^5;",["^L",["^5H","^5T"]],"^9",3027,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"~$noarg1",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2440,"^8",7,"^9",2440,"^:",13,"^4W",["^2G",["^4X",["^2G",[["^51","~$fn-type"]]]]],"^54","Set noarg1 in the options if it is the right fn-type."],"^M","~$zprint.zprint/noarg1","^6","zprint/zprint.cljc","^:",13,"^56",["^2G",[["^51","^<4"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2440,"^5;",["^L",[null,"^5H","^5["]],"^9",2440,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^<4"]]]]],"^54","Set noarg1 in the options if it is the right fn-type."],"~$map-ignore",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1181,"^8",7,"^9",1181,"^:",17,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^7Q","^7R"]],"^5M","^2J","^51"]],"^61"]]]]],"^54","Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers."],"^M","~$zprint.zprint/map-ignore","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["^5M","~$p__37269","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1181,"^5;",["^L",[null,"^5["]],"^9",1181,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M",["^2[",[["^ ","^4Y",["^7Q","^7R"]],"^5M","^2J","^51"]],"^61"]]]]],"^54","Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers."],"~$accumulate-ll",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",321,"^8",7,"^9",321,"^:",20,"^4W",["^2G",["^4X",["^2G",[["~$count-comment?",["^86","~$cur-len","~$just-eol?","~$just-comment?","^2J","~$in"],"~$s","~$tag","~$eol?"]]]]],"^54","Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s"],"^M","~$zprint.zprint/accumulate-ll","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^<:","~$p__37113","~$s","^<?","^<@"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",321,"^5;","^5C","^9",321,"^5=",5,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^<:",["^86","^<;","^<<","^<=","^2J","^<>"],"~$s","^<?","^<@"]]]]],"^54","Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s"],"~$fzprint-anon-fn",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2832,"^8",7,"^9",2832,"^:",22,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Pretty print and focus style a fn element."],"^M","~$zprint.zprint/fzprint-anon-fn","^6","zprint/zprint.cljc","^:",22,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2832,"^5;",["^L",["^5H","^5T"]],"^9",2832,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Pretty print and focus style a fn element."],"~$in-hang",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",262,"^8",7,"^9",262,"^:",14,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Add :in-hang? true to the options map."],"^M","~$zprint.zprint/in-hang","^6","zprint/zprint.cljc","^:",14,"^56",["^2G",[["^51"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",262,"^5;",["^L",[null,"^5H","^5["]],"^9",262,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Add :in-hang? true to the options map."],"~$interpose-either-nl-hf",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3054,"^8",7,"^9",3054,"^:",29,"^4W",["^2G",["^4X",["^2G",[["^:U","~$sep-true-nl","^:V","~$sep-nil-nl",["^ ","^4Y",["^6;","~$nl-separator-flow?"],"^2J","~$suboptions"],"~$pred-fn","^5P"]]]]],"^54","Do the same as interpose, but different seps depending on pred-fn\n  return and nl-separator?."],"^M","~$zprint.zprint/interpose-either-nl-hf","^6","zprint/zprint.cljc","^:",29,"^56",["^2G",[["^:U","^<H","^:V","^<I","~$p__37549","^<L","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3054,"^5;","^5[","^9",3054,"^5=",7,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^:U","^<H","^:V","^<I",["^ ","^4Y",["^6;","^<J"],"^2J","^<K"],"^<L","^5P"]]]]],"^54","Do the same as interpose, but different seps depending on pred-fn\n  return and nl-separator?."],"~$fzprint-hang-unless-fail",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",627,"^8",7,"^9",627,"^:",31,"^4W",["^2G",["^4X",["^2G",[["^51","^6<","^6=","^:Z","^61"]]]]],"^54","Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time."],"^M","~$zprint.zprint/fzprint-hang-unless-fail","^6","zprint/zprint.cljc","^:",31,"^56",["^2G",[["^51","^6<","^6=","^:Z","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",627,"^5;","^5C","^9",627,"^5=",5,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^6<","^6=","^:Z","^61"]]]]],"^54","Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time."],"~$keyword-fn?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",308,"^8",7,"^9",308,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^51","~$s"]]]]],"^54","Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map."],"^M","~$zprint.zprint/keyword-fn?","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^51","~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",308,"^5;",["^L",["^5[","^5T"]],"^9",308,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","~$s"]]]]],"^54","Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map."],"~$not-rightmost",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",555,"^8",7,"^9",555,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Remove the rightmost count."],"^M","~$zprint.zprint/not-rightmost","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^51"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",555,"^5;",["^L",["^5H","^5T"]],"^9",555,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51"]]]]],"^54","Remove the rightmost count."],"~$zpmap",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",77,"^8",16,"^9",77,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^51","~$f","^5P"],["^51","~$f","~$coll1","~$coll2"]]]]],"^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]],"^4W",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/zpmap","^6","zprint/zprint.cljc","^:",21,"^5W",["^ ","^5:",false,"^5X",4,"^5=",4,"^56",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]],"^4W",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]],"^58",null,"^5X",4,"^59",["^2G",[null,null]],"^8",10,"^5:",false,"^5Z",[["^ ","^5X",3,"^5:",false,"^4S","^6E"],["^ ","^5X",4,"^5:",false,"^4S","^6E"]],"^7",77,"^9",77,"^5=",4,"^5>",true,"^4W",["^2G",[["^51","~$f","^5P"],["^51","~$f","^<V","^<W"]]]],"~$noarg1-set",["^ ","^M","~$zprint.zprint/noarg1-set","^6","zprint/zprint.cljc","^7",2431,"^8",1,"^9",2431,"^:",16,"^5",["^ ","^6","zprint/zprint.cljc","^7",2431,"^8",6,"^9",2431,"^:",16],"^4S","^4T"],"~$cleave-end",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1246,"^8",7,"^9",1246,"^:",17,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq."],"^M","~$zprint.zprint/cleave-end","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1246,"^5;","^5H","^9",1246,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq."],"~$object-str?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3201,"^8",7,"^9",3201,"^:",18,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Return true if the string starts with #object["],"^M","~$zprint.zprint/object-str?","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3201,"^5;",["^L",["^5H","^5C","^5[","~$cljs.core/MetaFn","^5T"]],"^9",3201,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Return true if the string starts with #object["],"~$fzprint-uneval",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3413,"^8",7,"^9",3413,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Trim the #_ off the front of the uneval, and try to print it."],"^M","~$zprint.zprint/fzprint-uneval","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3413,"^5;",["^L",["^5H","^5T"]],"^9",3413,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Trim the #_ off the front of the uneval, and try to print it."],"~$fzprint-list*",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2466,"^8",7,"^9",2466,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^5M","^7J","^7K",["^2[",["^4Y",["~$fn-map","~$user-fn-map","^7L","^53","~$no-arg1?","^4Z"],["^ ","^4Y",["^8B","^8A"]],"^5M","^2J","^51"]],"^5O","^61"]]]]],"^54","Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list."],"^M","~$zprint.zprint/fzprint-list*","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^5M","^7J","^7K","~$p__37445","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2466,"^5;",["^L",["^5H","^5T"]],"^9",2466,"^5=",6,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5M","^7J","^7K",["^2[",["^4Y",["^=7","^=8","^7L","^53","^=9","^4Z"],["^ ","^4Y",["^8B","^8A"]],"^5M","^2J","^51"]],"^5O","^61"]]]]],"^54","Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list."],"~$fzprint-reader-macro",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3460,"^8",7,"^9",3460,"^:",27,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used."],"^M","~$zprint.zprint/fzprint-reader-macro","^6","zprint/zprint.cljc","^:",27,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3460,"^5;",["^L",["^5H","^5T"]],"^9",3460,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used."],"~$line-lengths",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",448,"^8",7,"^9",448,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character."],"^M","~$zprint.zprint/line-lengths","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^51","^5O","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",448,"^5;",["^L",["^5[","^5T"]],"^9",448,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character."],"~$max-width",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3879,"^8",7,"^9",3879,"^:",16,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Split a string into lines, and figure the max width."],"^M","~$zprint.zprint/max-width","^6","zprint/zprint.cljc","^:",16,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3879,"^5;","^5[","^9",3879,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Split a string into lines, and figure the max width."],"~$fzprint-binding-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1373,"^8",7,"^9",1373,"^:",26,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"~:binding","^2J","^51"]],"^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-binding-vec","^6","zprint/zprint.cljc","^:",26,"^56",["^2G",[["~$p__37331","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1373,"^5;",["^L",["^5H","^5T"]],"^9",1373,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"^=C","^2J","^51"]],"^5O","^61"]]]]]],"~$fn-style->caller",["^ ","^M","~$zprint.zprint/fn-style->caller","^6","zprint/zprint.cljc","^7",2445,"^8",1,"^9",2445,"^:",22,"^5",["^ ","^6","zprint/zprint.cljc","^7",2445,"^8",6,"^9",2445,"^:",22],"^4S","^5K"],"~$fzprint-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3023,"^8",7,"^9",3023,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-vec","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3023,"^5;",["^L",["^5H","^5T"]],"^9",3023,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]]],"~$style-loc-vec",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3782,"^8",7,"^9",3782,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec."],"^M","~$zprint.zprint/style-loc-vec","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3782,"^5;","^89","^9",3782,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5A"]]]]],"^54","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec."],"~$remove-key-seq",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1142,"^8",7,"^9",1142,"^:",21,"^4W",["^2G",["^4X",["^2G",[["~$m","~$ks"]]]]],"^54","If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one."],"^M","~$zprint.zprint/remove-key-seq","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["~$m","^=M"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1142,"^5;",["^L",["^5H","^5[","^5T"]],"^9",1142,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$m","^=M"]]]]],"^54","If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one."],"~$hangflow",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",620,"^8",7,"^9",620,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$hangflow?","~$hang-or-flow","^5A"]]]]],"^54","Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil."],"^M","~$zprint.zprint/hangflow","^6","zprint/zprint.cljc","^:",15,"^56",["^2G",[["^=P","^=Q","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",620,"^5;",["^L",[null,"^5C","^5T"]],"^9",620,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^=P","^=Q","^5A"]]]]],"^54","Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil."],"~$fzprint-record",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3377,"^8",7,"^9",3377,"^:",21,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["~$record-type?","~$to-string?"]],"^9W","^2J","^51"]],"^5O","^61"]]]]]],"^M","~$zprint.zprint/fzprint-record","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["~$p__37587","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3377,"^5;",["^L",["^5H","^5[","^5T"]],"^9",3377,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^=T","^=U"]],"^9W","^2J","^51"]],"^5O","^61"]]]]]],"~$fzprint-one-line",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1494,"^8",7,"^9",1494,"^:",23,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil."],"^M","~$zprint.zprint/fzprint-one-line","^6","zprint/zprint.cljc","^:",23,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1494,"^5;",["^L",["^5H","^5T"]],"^9",1494,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil."],"~$fzfit",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",526,"^8",7,"^9",526,"^:",12,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E","^9B","^64"],"^2J","^51"],["^6S","^=@","^2J","^6Q"]]]]]],"^54","Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise."],"^M","~$zprint.zprint/fzfit","^6","zprint/zprint.cljc","^:",12,"^56",["^2G",[["~$p__37173","~$p__37174"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",526,"^5;",["^L",[null,"^5[","^5T"]],"^9",526,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E","^9B","^64"],"^2J","^51"],["^6S","^=@","^2J","^6Q"]]]]]],"^54","Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise."],"~$fzprint-meta",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3434,"^8",7,"^9",3434,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost."],"^M","~$zprint.zprint/fzprint-meta","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3434,"^5;",["^L",["^5H","^5T"]],"^9",3434,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost."],"~$fzprint-dbg",["^ ","^M","~$zprint.zprint/fzprint-dbg","^6","zprint/zprint.cljc","^7",97,"^8",1,"^9",97,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",97,"^8",6,"^9",97,"^:",17],"^4S","~$cljs.core/Atom"],"~$any-zcoll?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2837,"^8",7,"^9",2837,"^:",17,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Return true if there are any collections in the collection."],"^M","~$zprint.zprint/any-zcoll?","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["^51","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2837,"^5;",["^L",[null,"^5["]],"^9",2837,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^61"]]]]],"^54","Return true if there are any collections in the collection."],"~$contains-nil?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",271,"^8",7,"^9",271,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Scan a collection, and return the number of nils or empty collections\n  present (if any), and nil otherwise."],"^M","~$zprint.zprint/contains-nil?","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",271,"^5;",["^L",["^5S","^5T"]],"^9",271,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Scan a collection, and return the number of nils or empty collections\n  present (if any), and nil otherwise."],"~$showfn?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",114,"^8",7,"^9",114,"^:",14,"^4W",["^2G",["^4X",["^2G",[["^=7","~$f"]]]]],"^54","Show this thing as a function?"],"^M","~$zprint.zprint/showfn?","^6","zprint/zprint.cljc","^:",14,"^56",["^2G",[["^=7","~$f"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",114,"^5;",["^L",[null,"^5[","^5T"]],"^9",114,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^=7","~$f"]]]]],"^54","Show this thing as a function?"],"~$map->r",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^:",13,"^8",12,"^9V",true,"~:factory","~:map","^7",3917,"^9",3917,"^4W",["^2G",["^4X",["^2G",[["~$G__37651"]]]]],"^54","Factory function for zprint.zprint/r, taking a map of keywords to field values."],"^M","~$zprint.zprint/map->r","^6","zprint/zprint.cljc","^:",13,"^56",["^2G",[["^>@"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^9V",true,"^5:",false,"^>>","^>?","^7",3917,"^5;","^9T","^9",3917,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^>@"]]]]],"^54","Factory function for zprint.zprint/r, taking a map of keywords to field values."],"~$generate-ll",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",354,"^8",7,"^9",354,"^:",18,"^4W",["^2G",["^4X",["^2G",[["^<:",["^86","^<;","^<<","^<=","^2J","^<>"],["~$s","~$_","^<?","^2J","^:="]]]]]]],"^M","~$zprint.zprint/generate-ll","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["^<:","~$p__37120","~$p__37121"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",354,"^5;","^5C","^9",354,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^<:",["^86","^<;","^<<","^<=","^2J","^<>"],["~$s","~$_","^<?","^2J","^:="]]]]]]],"~$->r",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^:",13,"^8",12,"^9V",true,"^>>","~:positional","^7",3917,"^9",3917,"^4W",["^2G",["^4X",["^2G",[["~$left","~$right"]]]]],"^54","Positional factory function for zprint.zprint/r."],"^M","~$zprint.zprint/->r","^6","zprint/zprint.cljc","^:",13,"^56",["^2G",[["^>H","^>I"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^9V",true,"^5:",false,"^>>","^>G","^7",3917,"^5;","^9T","^9",3917,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^>H","^>I"]]]]],"^54","Positional factory function for zprint.zprint/r."],"~$ignore-key-seq",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1168,"^8",7,"^9",1168,"^:",21,"^4W",["^2G",["^4X",["^2G",[["~$m","^=M"]]]]],"^54","Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map."],"^M","~$zprint.zprint/ignore-key-seq","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["~$m","^=M"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1168,"^5;",["^L",[null,"^5H","^5["]],"^9",1168,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$m","^=M"]]]]],"^54","Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map."],"~$fzprint",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3843,"^8",7,"^9",3843,"^:",14,"^4W",["^2G",["^4X",["^2G",[["^51","^8A","^61"]]]]],"^54","The pretty print part of fzprint."],"^M","~$zprint.zprint/fzprint","^6","zprint/zprint.cljc","^:",14,"^56",["^2G",[["^51","^8A","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3843,"^5;",["^L",["^5H","^5C","^5[","^5T"]],"^9",3843,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^8A","^61"]]]]],"^54","The pretty print part of fzprint."],"~$internal-validate",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2932,"^8",7,"^9",2932,"^:",24,"^4W",["^2G",["^4X",["^2G",[["^51","~$error-str"]]]]],"^54","Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error."],"^M","~$zprint.zprint/internal-validate","^6","zprint/zprint.cljc","^:",24,"^56",["^2G",[["^51","^>P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",2932,"^9",2932,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^>P"]]]]],"^54","Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error."],"~$line-lengths-iter",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",373,"^8",7,"^9",373,"^:",24,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important."],"^M","~$zprint.zprint/line-lengths-iter","^6","zprint/zprint.cljc","^:",24,"^56",["^2G",[["^51","^5O","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",373,"^5;",["^L",["^5H","^5C"]],"^9",373,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^5O","^5A"]]]]],"^54","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important."],"~$count-constant-pairs",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1673,"^8",7,"^9",1673,"^:",27,"^4W",["^2G",["^4X",["^2G",[["^7Y"]]]]],"^54","Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any whitespace in this, because this seq should have been\n  produced by zmap-right or its equivalent, which already skips the\n  whitespace."],"^M","~$zprint.zprint/count-constant-pairs","^6","zprint/zprint.cljc","^:",27,"^56",["^2G",[["^7Y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1673,"^5;","^5S","^9",1673,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^7Y"]]]]],"^54","Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any whitespace in this, because this seq should have been\n  produced by zmap-right or its equivalent, which already skips the\n  whitespace."],"~$force-vector",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",303,"^8",7,"^9",303,"^:",19,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Ensure that whatever we have is a vector."],"^M","~$zprint.zprint/force-vector","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",303,"^5;",["^L",[null,"^5H","^5["]],"^9",303,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^5P"]]]]],"^54","Ensure that whatever we have is a vector."],"~$compare-ordered-keys",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1094,"^8",7,"^9",1094,"^:",27,"^4W",["^2G",["^4X",["^2G",[["^84","^1H","~$x","~$y"]]]]],"^54","Do a key comparison that places ordered keys first."],"^M","~$zprint.zprint/compare-ordered-keys","^6","zprint/zprint.cljc","^:",27,"^56",["^2G",[["^84","^1H","~$x","~$y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1094,"^5;","^5S","^9",1094,"^5=",4,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^84","^1H","~$x","~$y"]]]]],"^54","Do a key comparison that places ordered keys first."],"~$show-user-fn?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",134,"^8",7,"^9",134,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^51","~$f"]]]]],"^54","Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!"],"^M","~$zprint.zprint/show-user-fn?","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^51","~$f"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",134,"^5;",["^L",[null,"^5[","^5T"]],"^9",134,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","~$f"]]]]],"^54","Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!"],"~$concat-no-nil",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",291,"^8",7,"^9",291,"^:",20,"^4W",["^2G",["^4X",["^2G",[["~$&","^6G"]]]]],"^54","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil.","^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]]],"^M","~$zprint.zprint/concat-no-nil","^6","zprint/zprint.cljc","^:",20,"^5W",["^ ","^5:",true,"^5X",0,"^5=",0,"^56",[["^2G",["^6G"]]],"^4W",["^2G",[["~$&","^6G"]]],"^59",["^2G",[null]]],"^56",[["^2G",["^6G"]]],"^58",null,"^5X",0,"^59",["^2G",[null]],"^8",1,"^5:",true,"^5Z",[["^ ","^5X",0,"^5:",true,"^4S",["^L",["^5H","^5T"]]]],"^7",291,"^5;","^5[","^9",291,"^5=",0,"^5>",true,"^4W",["^2G",[["~$&","^6G"]]],"^54","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil."],"~$prefix-options",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3549,"^8",7,"^9",3549,"^:",21,"^4W",["^2G",["^4X",["^2G",[["^51","~$prefix-tag"]]]]],"^54","Change options as necessary based on prefix tag."],"^M","~$zprint.zprint/prefix-options","^6","zprint/zprint.cljc","^:",21,"^56",["^2G",[["^51","^?3"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3549,"^5;",["^L",[null,"^5H","^5["]],"^9",3549,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^51","^?3"]]]]],"^54","Change options as necessary based on prefix tag."],"~$next-space",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3713,"^8",7,"^9",3713,"^:",17,"^4W",["^2G",["^4X",["^2G",[["~$s","^;V"]]]]],"^54","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"^M","~$zprint.zprint/next-space","^6","zprint/zprint.cljc","^:",17,"^56",["^2G",[["~$s","^;V"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3713,"^5;",["^L",["^5S","^5T"]],"^9",3713,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s","^;V"]]]]],"^54","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"~$middle-element?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1130,"^8",7,"^9",1130,"^:",22,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^7O"],"^2J","^51"],"^61"]]]]],"^54","This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element."],"^M","~$zprint.zprint/middle-element?","^6","zprint/zprint.cljc","^:",22,"^56",["^2G",[["~$p__37264","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1130,"^5;",["^L",["^5<","^5T"]],"^9",1130,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^7O"],"^2J","^51"],"^61"]]]]],"^54","This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element."],"~$fit-within?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",959,"^8",7,"^9",959,"^:",18,"^4W",["^2G",["^4X",["^2G",[["~$size","^5P","~$depth"],["^?;","^5P"]]]]],"^54","Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size.","^5W",["^ ","^5:",false,"^5X",3,"^5=",3,"^56",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^4W",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^59",["^2G",[null,null]]]],"^M","~$zprint.zprint/fit-within?","^6","zprint/zprint.cljc","^:",18,"^5W",["^ ","^5:",false,"^5X",3,"^5=",3,"^56",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^4W",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^59",["^2G",[null,null]]],"^56",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^58",null,"^5X",3,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^5Z",[["^ ","^5X",3,"^5:",false,"^4S",["^L",[null,"^5["]]],["^ ","^5X",2,"^5:",false,"^4S",["^L",[null,"^5["]]]],"^7",959,"^9",959,"^5=",3,"^5>",true,"^4W",["^2G",[["^?;","^5P","^?<"],["^?;","^5P"]]],"^54","Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size."],"~$fzprint-pairs",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1434,"^8",7,"^9",1434,"^:",20,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"~:pair","^2J","^51"]],"^5O","^61"]]]]],"^54","Always prints pairs on a different line from other pairs."],"^M","~$zprint.zprint/fzprint-pairs","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["~$p__37351","^5O","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1434,"^5;","^5[","^9",1434,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^2[",[["^ ","^4Y",["^6;"]],"^??","^2J","^51"]],"^5O","^61"]]]]],"^54","Always prints pairs on a different line from other pairs."],"~$body-map",["^ ","^M","~$zprint.zprint/body-map","^6","zprint/zprint.cljc","^7",2418,"^8",1,"^9",2418,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",2418,"^8",6,"^9",2418,"^:",14],"^4S","^5K"],"~$fzprint-wrap-comments",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3808,"^8",7,"^9",3808,"^:",28,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E"],"^2J","^51"],"^5A"]]]]],"^54","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"^M","~$zprint.zprint/fzprint-wrap-comments","^6","zprint/zprint.cljc","^:",28,"^56",["^2G",[["~$p__37627","^5A"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3808,"^5;",["^L",[null,"^5["]],"^9",3808,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E"],"^2J","^51"],"^5A"]]]]],"^54","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"~$pair-element?",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1121,"^8",7,"^9",1121,"^:",20,"^4W",["^2G",["^4X",["^2G",[["^61"]]]]],"^54","This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this."],"^M","~$zprint.zprint/pair-element?","^6","zprint/zprint.cljc","^:",20,"^56",["^2G",[["^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1121,"^5;","^5[","^9",1121,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^61"]]]]],"^54","This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this."],"~$make-record",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3918,"^8",7,"^9",3918,"^:",18,"^4W",["^2G",["^4X",["^2G",[["~$l","~$r"]]]]]],"^M","~$zprint.zprint/make-record","^6","zprint/zprint.cljc","^:",18,"^56",["^2G",[["~$l","~$r"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3918,"^5;","~$r","^9",3918,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$l","~$r"]]]]]],"~$fzprint*",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3572,"^8",7,"^9",3572,"^:",15,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E","^9B","^=7","~$hex?","~$shift-seq","^64","^:A","^8=","^7L","~$string-str?","~$string-color","^?<","~$max-depth","~$trim-comments?","^7O","~$max-hang-depth","~$max-hang-span","~$max-hang-count"],"^2J","^51"],"^8A","^61"]]]]],"^54","The pretty print part of fzprint."],"^M","~$zprint.zprint/fzprint*","^6","zprint/zprint.cljc","^:",15,"^56",["^2G",[["~$p__37612","^8A","^61"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3572,"^5;",["^L",["^5H","^5C","^5[","^5T"]],"^9",3572,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[[["^ ","^4Y",["^5E","^9B","^=7","^?L","^?M","^64","^:A","^8=","^7L","^?N","^?O","^?<","^?P","^?Q","^7O","^?R","^?S","^?T"],"^2J","^51"],"^8A","^61"]]]]],"^54","The pretty print part of fzprint."],"~$split-lf",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",49,"^8",7,"^9",49,"^:",15,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Do split for newlines, instead of using regular expressions."],"^M","~$zprint.zprint/split-lf","^6","zprint/zprint.cljc","^:",15,"^56",["^2G",[["~$s"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",49,"^5;",["^L",["^5H","^5C"]],"^9",49,"^5=",1,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$s"]]]]],"^54","Do split for newlines, instead of using regular expressions."],"~$ignore-key-seq-silent",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1157,"^8",7,"^9",1157,"^:",28,"^4W",["^2G",["^4X",["^2G",[["~$m","^=M"]]]]],"^54","Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map."],"^M","~$zprint.zprint/ignore-key-seq-silent","^6","zprint/zprint.cljc","^:",28,"^56",["^2G",[["~$m","^=M"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1157,"^5;",["^L",[null,"^5H","^5[","^5T"]],"^9",1157,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$m","^=M"]]]]],"^54","Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map."],"~$compare-keys",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1087,"^8",7,"^9",1087,"^:",19,"^4W",["^2G",["^4X",["^2G",[["~$x","~$y"]]]]],"^54","Do a key comparison that works well for numbers as well as\n  strings."],"^M","~$zprint.zprint/compare-keys","^6","zprint/zprint.cljc","^:",19,"^56",["^2G",[["~$x","~$y"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",1087,"^5;","^5S","^9",1087,"^5=",2,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["~$x","~$y"]]]]],"^54","Do a key comparison that works well for numbers as well as\n  strings."],"~$interpose-nl-hf",["^ ","^4V",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3087,"^8",7,"^9",3087,"^:",22,"^4W",["^2G",["^4X",["^2G",[["^<K","^5O","^5P"]]]]],"^54","Put a single or double line between pairs returned from fzprint-map-two-up.\n  The first argument is the map resulting from (:map options) or (:pair options)\n  or whatever.  It should have :nl-separator? and :nl-separator-flow? in it."],"^M","~$zprint.zprint/interpose-nl-hf","^6","zprint/zprint.cljc","^:",22,"^56",["^2G",[["^<K","^5O","^5P"]]],"^58",null,"^59",["^2G",[null,null]],"^8",1,"^5:",false,"^7",3087,"^5;","^5[","^9",3087,"^5=",3,"^5>",true,"^4W",["^2G",["^4X",["^2G",[["^<K","^5O","^5P"]]]]],"^54","Put a single or double line between pairs returned from fzprint-map-two-up.\n  The first argument is the map resulting from (:map options) or (:pair options)\n  or whatever.  It should have :nl-separator? and :nl-separator-flow? in it."]],"^12",["^ ","^F","^F","^V","^V"],"~:cljs.analyzer/constants",["^ ","^10",["^L",["~:in-code?","~:comment-wrap","~:flow?","~:sort-in-code?","~:nl-separator?","~:hang-size","~:dbg","~:indent-arg","~:arg2-extend","~:arg2-pair","~:key-depth-color","~:wrap-coll?","~:constant-pair?","~:indent","~:max-length","^;<","~:comma?","~:record-type?","~:fn","~:justify?","~:fn-force-nl","~:max-hang-depth","~:dbg-hang","~:arg1-body","~:unquote-splicing","~:future","~:justify-tuning","~:zprint-not-found","~:arg2","~:whitespace","~:element","~:user-fn-map","~:hash-paren","~:pair-fn","^98","~:else","~:force-nl","~:number","~:zipper","~:arg1-extend","^>H","~:unknown","~:promise","~:arg1-pair","~:hang-expand","~:brace","~:unquote","^??","~:flow","~:noarg1","~:noarg1-body","^P","~:key-value-color","~:constant-pair-min","~:key-value","~:sexpr","~:in-hang?","~:dbg-ge","~:value","~:user-fn","~:rightcnt","~:dbg-indent","~:force-nl?","~:width","~:respect-nl?","~:uneval","~:key-ignore-silent","~:key-order","~:color-map","~:arg1-pair-body","~:key-ignore","~:agent","~:do-in-hang?","~:string","~:no-arg1?","~:vector","~:hex?","~:array","~:empty","~:object?","~:force-nl-body","~:map-depth","~:arg2-fn","~:hang-avoid","~:dbg-cnt?","~:hang-diff","~:paren","~:dbg-print?","~:zprint-ignored","^7D","~:count?","~:lift-ns-in-code?","~:fn-gt2-force-nl","~:spec","~:syntax-quote","^=C","~:inline?","~:modifiers","~:hang-type-flow","~:arg1-force-nl","~:wrap?","~:hang-adjust","~:dbg-local?","~:hang","~:dbg?","~:justify-hang","~:list","~:var","~:quote","~:keyword","~:ztype","~:wrap-after-multi?","~:flow-body","~:hang-flow","~:binding?","~:key-color","~:string-color","~:syntax-quote-paren","~:trim-comments?","~:general-hang-adjust","~:nil","~:max-hang-span","~:deref","~:bracket","^9W","~:comment","~:none-hang","~:comment-inline","~:none-hang-one","~:fn-style","~:lift-ns?","~:to-string?","~:right","~:fn-gt3-force-nl","~:one-line?","~:nl-separator-flow?","~:option-fn-first","~:string-str?","~:depth","~:hang-if-equal-flow?","~:arg1-mixin","~:on","~:max-depth","~:arg1->","~:set","~:fn-map","~:none-two-up","~:hang?","~:pdepth","~:none-body","~:hang-flow-limit","~:shift-seq","^9>","~:hash-brace","~:newline","~:rightmost-pair","~:max-hang-count","~:parallel?","~:sort?","~:delay","^>?","~:object","^>I","~:arg1","~:none","~:reader-cond","~:rightmost","~:left"]],"~:order",["^AZ","^A@","^A;","^P","^@R","^;<","^BF","^B7","^C>","^BL","^C3","^A1","^AX","^@9","^B:","^AB","^A?","^B=","^B<","^AK","^C2","^C9","^BQ","^BS","^@U","^@P","^@A","^CA","^B0","^@Q","^A<","^BP","^BA","^AY","^C@","^@S","^A2","^AD","^BO","^AG","^A4","^CI","^C;","^@6","^@;","^@>","^A7","^AW","^B;","^BH","^BZ","^AT","^CK","^B6","^C:","^@V","^@F","^AA","^CD","^B>","^@M","^CB","^CE","^@7","^AF","^A9","^@4","^@N","^A[","^AI","^AE","^@B","^BX","^=C","^@8","^CL","^BR","^??","^98","^BU","^@E","^@I","^C<","^BT","^@@","^A8","^AV","^@=","^@J","^@O","^@T","^A6","^AH","^AU","^BE","^C7","^C=","^AS","^CH","^A0","^A5","^@Y","^AM","^@<","^@G","^B2","^BY","^AQ","^C4","^B8","^B?","^BD","^@?","^B9","^BG","^C0","^AC","^AN","^AP","^C8","^B[","^@C","^BV","^B1","^BC","^A:","^>?","^CG","^9>","^AR","^@Z","^@L","^@[","^CF","^AJ","^C1","^7D","^BI","^9W","^@D","^BW","^CJ","^B4","^A3","^@K","^B@","^BJ","^C6","^C?","^CC","^@H","^AO","^BK","^BN","^@:","^C5","^BB","^B5","^AL","^A>","^@W","^BM","^@5","^@X","^A=","^B3","^>H","^>I"]],"^2K",["^ ","^12",["^L",[]],"^11",["^L",[]]],"^2L",["^ "],"^2M",["^W","^V","^Z","^X","^Y","^T","^[","^S","^U"]],"^P","^N","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^2[",[["^CP","~:static-fns"],true,["^CP","~:elide-asserts"],false,["^CP","~:optimize-constants"],null,["^CP","^2R"],null,["^CP","~:external-config"],null,["^CP","~:tooling-config"],null,["^CP","~:emit-constants"],null,["^CP","~:load-tests"],null,["^CP","~:infer-externs"],true,["^CP","^2T"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^CP","~:fn-invoke-direct"],null,["^CP","~:source-map"],"/dev/null"]]]